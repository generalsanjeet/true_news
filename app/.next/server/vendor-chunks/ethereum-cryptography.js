"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ethereum-cryptography";
exports.ids = ["vendor-chunks/ethereum-cryptography"];
exports.modules = {

/***/ "(ssr)/./node_modules/ethereum-cryptography/keccak.js":
/*!******************************************************!*\
  !*** ./node_modules/ethereum-cryptography/keccak.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.keccak512 = exports.keccak384 = exports.keccak256 = exports.keccak224 = void 0;\nconst sha3_1 = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/sha3.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ethereum-cryptography/utils.js\");\nexports.keccak224 = (0, utils_js_1.wrapHash)(sha3_1.keccak_224);\nexports.keccak256 = (()=>{\n    const k = (0, utils_js_1.wrapHash)(sha3_1.keccak_256);\n    k.create = sha3_1.keccak_256.create;\n    return k;\n})();\nexports.keccak384 = (0, utils_js_1.wrapHash)(sha3_1.keccak_384);\nexports.keccak512 = (0, utils_js_1.wrapHash)(sha3_1.keccak_512);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2Nhay5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsaUJBQWlCLEdBQUdBLGlCQUFpQixHQUFHQSxpQkFBaUIsR0FBR0EsaUJBQWlCLEdBQUcsS0FBSztBQUNyRixNQUFNTSxTQUFTQyxtQkFBT0EsQ0FBQyx5R0FBb0I7QUFDM0MsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsdUVBQVk7QUFDdkNQLGlCQUFpQixHQUFHLENBQUMsR0FBR1EsV0FBV0MsUUFBUSxFQUFFSCxPQUFPSSxVQUFVO0FBQzlEVixpQkFBaUIsR0FBRyxDQUFDO0lBQ2pCLE1BQU1XLElBQUksQ0FBQyxHQUFHSCxXQUFXQyxRQUFRLEVBQUVILE9BQU9NLFVBQVU7SUFDcERELEVBQUVFLE1BQU0sR0FBR1AsT0FBT00sVUFBVSxDQUFDQyxNQUFNO0lBQ25DLE9BQU9GO0FBQ1g7QUFDQVgsaUJBQWlCLEdBQUcsQ0FBQyxHQUFHUSxXQUFXQyxRQUFRLEVBQUVILE9BQU9RLFVBQVU7QUFDOURkLGlCQUFpQixHQUFHLENBQUMsR0FBR1EsV0FBV0MsUUFBUSxFQUFFSCxPQUFPUyxVQUFVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9rZWNjYWsuanM/OWIwMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMua2VjY2FrNTEyID0gZXhwb3J0cy5rZWNjYWszODQgPSBleHBvcnRzLmtlY2NhazI1NiA9IGV4cG9ydHMua2VjY2FrMjI0ID0gdm9pZCAwO1xuY29uc3Qgc2hhM18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2hhM1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbmV4cG9ydHMua2VjY2FrMjI0ID0gKDAsIHV0aWxzX2pzXzEud3JhcEhhc2gpKHNoYTNfMS5rZWNjYWtfMjI0KTtcbmV4cG9ydHMua2VjY2FrMjU2ID0gKCgpID0+IHtcbiAgICBjb25zdCBrID0gKDAsIHV0aWxzX2pzXzEud3JhcEhhc2gpKHNoYTNfMS5rZWNjYWtfMjU2KTtcbiAgICBrLmNyZWF0ZSA9IHNoYTNfMS5rZWNjYWtfMjU2LmNyZWF0ZTtcbiAgICByZXR1cm4gaztcbn0pKCk7XG5leHBvcnRzLmtlY2NhazM4NCA9ICgwLCB1dGlsc19qc18xLndyYXBIYXNoKShzaGEzXzEua2VjY2FrXzM4NCk7XG5leHBvcnRzLmtlY2NhazUxMiA9ICgwLCB1dGlsc19qc18xLndyYXBIYXNoKShzaGEzXzEua2VjY2FrXzUxMik7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJrZWNjYWs1MTIiLCJrZWNjYWszODQiLCJrZWNjYWsyNTYiLCJrZWNjYWsyMjQiLCJzaGEzXzEiLCJyZXF1aXJlIiwidXRpbHNfanNfMSIsIndyYXBIYXNoIiwia2VjY2FrXzIyNCIsImsiLCJrZWNjYWtfMjU2IiwiY3JlYXRlIiwia2VjY2FrXzM4NCIsImtlY2Nha181MTIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereum-cryptography/keccak.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/curves/_shortw_utils.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/ethereum-cryptography/node_modules/@noble/curves/_shortw_utils.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createCurve = exports.getHash = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const hmac_1 = __webpack_require__(/*! @noble/hashes/hmac */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/hmac.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/utils.js\");\nconst weierstrass_js_1 = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/curves/abstract/weierstrass.js\");\n// connects noble-curves to noble-hashes\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs)=>(0, hmac_1.hmac)(hash, key, (0, utils_1.concatBytes)(...msgs)),\n        randomBytes: utils_1.randomBytes\n    };\n}\nexports.getHash = getHash;\nfunction createCurve(curveDef, defHash) {\n    const create = (hash)=>(0, weierstrass_js_1.weierstrass)({\n            ...curveDef,\n            ...getHash(hash)\n        });\n    return Object.freeze({\n        ...create(defHash),\n        create\n    });\n}\nexports.createCurve = createCurve; //# sourceMappingURL=_shortw_utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL19zaG9ydHdfdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG1CQUFtQixHQUFHQSxlQUFlLEdBQUcsS0FBSztBQUM3QyxvRUFBb0UsR0FDcEUsTUFBTUksU0FBU0MsbUJBQU9BLENBQUMseUdBQW9CO0FBQzNDLE1BQU1DLFVBQVVELG1CQUFPQSxDQUFDLDJHQUFxQjtBQUM3QyxNQUFNRSxtQkFBbUJGLG1CQUFPQSxDQUFDLGdJQUEyQjtBQUM1RCx3Q0FBd0M7QUFDeEMsU0FBU0YsUUFBUUssSUFBSTtJQUNqQixPQUFPO1FBQ0hBO1FBQ0FDLE1BQU0sQ0FBQ0MsS0FBSyxHQUFHQyxPQUFTLENBQUMsR0FBR1AsT0FBT0ssSUFBSSxFQUFFRCxNQUFNRSxLQUFLLENBQUMsR0FBR0osUUFBUU0sV0FBVyxLQUFLRDtRQUNoRkUsYUFBYVAsUUFBUU8sV0FBVztJQUNwQztBQUNKO0FBQ0FiLGVBQWUsR0FBR0c7QUFDbEIsU0FBU0QsWUFBWVksUUFBUSxFQUFFQyxPQUFPO0lBQ2xDLE1BQU1DLFNBQVMsQ0FBQ1IsT0FBUyxDQUFDLEdBQUdELGlCQUFpQlUsV0FBVyxFQUFFO1lBQUUsR0FBR0gsUUFBUTtZQUFFLEdBQUdYLFFBQVFLLEtBQUs7UUFBQztJQUMzRixPQUFPVixPQUFPb0IsTUFBTSxDQUFDO1FBQUUsR0FBR0YsT0FBT0QsUUFBUTtRQUFFQztJQUFPO0FBQ3REO0FBQ0FoQixtQkFBbUIsR0FBR0UsYUFDdEIseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9fc2hvcnR3X3V0aWxzLmpzPzdhYmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUN1cnZlID0gZXhwb3J0cy5nZXRIYXNoID0gdm9pZCAwO1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuY29uc3QgaG1hY18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvaG1hY1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiKTtcbmNvbnN0IHdlaWVyc3RyYXNzX2pzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC93ZWllcnN0cmFzcy5qc1wiKTtcbi8vIGNvbm5lY3RzIG5vYmxlLWN1cnZlcyB0byBub2JsZS1oYXNoZXNcbmZ1bmN0aW9uIGdldEhhc2goaGFzaCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGhhc2gsXG4gICAgICAgIGhtYWM6IChrZXksIC4uLm1zZ3MpID0+ICgwLCBobWFjXzEuaG1hYykoaGFzaCwga2V5LCAoMCwgdXRpbHNfMS5jb25jYXRCeXRlcykoLi4ubXNncykpLFxuICAgICAgICByYW5kb21CeXRlczogdXRpbHNfMS5yYW5kb21CeXRlcyxcbiAgICB9O1xufVxuZXhwb3J0cy5nZXRIYXNoID0gZ2V0SGFzaDtcbmZ1bmN0aW9uIGNyZWF0ZUN1cnZlKGN1cnZlRGVmLCBkZWZIYXNoKSB7XG4gICAgY29uc3QgY3JlYXRlID0gKGhhc2gpID0+ICgwLCB3ZWllcnN0cmFzc19qc18xLndlaWVyc3RyYXNzKSh7IC4uLmN1cnZlRGVmLCAuLi5nZXRIYXNoKGhhc2gpIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4uY3JlYXRlKGRlZkhhc2gpLCBjcmVhdGUgfSk7XG59XG5leHBvcnRzLmNyZWF0ZUN1cnZlID0gY3JlYXRlQ3VydmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fc2hvcnR3X3V0aWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNyZWF0ZUN1cnZlIiwiZ2V0SGFzaCIsImhtYWNfMSIsInJlcXVpcmUiLCJ1dGlsc18xIiwid2VpZXJzdHJhc3NfanNfMSIsImhhc2giLCJobWFjIiwia2V5IiwibXNncyIsImNvbmNhdEJ5dGVzIiwicmFuZG9tQnl0ZXMiLCJjdXJ2ZURlZiIsImRlZkhhc2giLCJjcmVhdGUiLCJ3ZWllcnN0cmFzcyIsImZyZWV6ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/curves/_shortw_utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/curves/abstract/curve.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/ethereum-cryptography/node_modules/@noble/curves/abstract/curve.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.validateBasic = exports.wNAF = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Abelian group utilities\nconst modular_js_1 = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/curves/abstract/modular.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/curves/abstract/utils.js\");\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / ùëä) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item)=>{\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W)=>{\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return {\n            windows,\n            windowSize\n        };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder (elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while(n > _0n){\n                if (n & _1n) p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:\n         * - ùëä is the window size\n         * - ùëõ is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */ precomputeWindow (elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for(let window = 0; window < windows; window++){\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for(let i = 1; i < windowSize; i++){\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */ wNAF (W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for(let window = 0; window < windows; window++){\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                } else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return {\n                p,\n                f\n            };\n        },\n        wNAFCached (P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        }\n    };\n}\nexports.wNAF = wNAF;\nfunction validateBasic(curve) {\n    (0, modular_js_1.validateField)(curve.Fp);\n    (0, utils_js_1.validateObject)(curve, {\n        n: \"bigint\",\n        h: \"bigint\",\n        Gx: \"field\",\n        Gy: \"field\"\n    }, {\n        nBitLength: \"isSafeInteger\",\n        nByteLength: \"isSafeInteger\"\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{\n            p: curve.Fp.ORDER\n        }\n    });\n}\nexports.validateBasic = validateBasic; //# sourceMappingURL=curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2Fic3RyYWN0L2N1cnZlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxxQkFBcUIsR0FBR0EsWUFBWSxHQUFHLEtBQUs7QUFDNUMsb0VBQW9FLEdBQ3BFLDBCQUEwQjtBQUMxQixNQUFNSSxlQUFlQyxtQkFBT0EsQ0FBQywrR0FBYztBQUMzQyxNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQywyR0FBWTtBQUN2QyxNQUFNRSxNQUFNQyxPQUFPO0FBQ25CLE1BQU1DLE1BQU1ELE9BQU87QUFDbkIsNkRBQTZEO0FBQzdELG1HQUFtRztBQUNuRyx5REFBeUQ7QUFDekQsNERBQTREO0FBQzVELCtFQUErRTtBQUMvRSxvR0FBb0c7QUFDcEcsb0dBQW9HO0FBQ3BHLHFDQUFxQztBQUNyQyxrR0FBa0c7QUFDbEcsZ0dBQWdHO0FBQ2hHLDhDQUE4QztBQUM5QyxTQUFTTCxLQUFLTyxDQUFDLEVBQUVDLElBQUk7SUFDakIsTUFBTUMsa0JBQWtCLENBQUNDLFdBQVdDO1FBQ2hDLE1BQU1DLE1BQU1ELEtBQUtFLE1BQU07UUFDdkIsT0FBT0gsWUFBWUUsTUFBTUQ7SUFDN0I7SUFDQSxNQUFNRyxPQUFPLENBQUNDO1FBQ1YsTUFBTUMsVUFBVUMsS0FBS0MsSUFBSSxDQUFDVixPQUFPTyxLQUFLLEdBQUcsY0FBYztRQUN2RCxNQUFNSSxhQUFhLEtBQU1KLENBQUFBLElBQUksSUFBSSwwQkFBMEI7UUFDM0QsT0FBTztZQUFFQztZQUFTRztRQUFXO0lBQ2pDO0lBQ0EsT0FBTztRQUNIVjtRQUNBLHVDQUF1QztRQUN2Q1csY0FBYUMsR0FBRyxFQUFFQyxDQUFDO1lBQ2YsSUFBSUMsSUFBSWhCLEVBQUVpQixJQUFJO1lBQ2QsSUFBSUMsSUFBSUo7WUFDUixNQUFPQyxJQUFJbEIsSUFBSztnQkFD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QUFlSyxHQUFHLENBQUNOLEdBQUdFLFVBQVVFO2dCQUNwQztZQUNKO1lBQ0EsT0FBTyxJQUFJLENBQUNyRCxJQUFJLENBQUNlLEdBQUdzQyxNQUFNL0I7UUFDOUI7SUFDSjtBQUNKO0FBQ0F6QixZQUFZLEdBQUdHO0FBQ2YsU0FBU0QsY0FBY3lELEtBQUs7SUFDdkIsSUFBR3ZELGFBQWF3RCxhQUFhLEVBQUVELE1BQU1FLEVBQUU7SUFDdkMsSUFBR3ZELFdBQVd3RCxjQUFjLEVBQUVILE9BQU87UUFDbENsQyxHQUFHO1FBQ0hzQyxHQUFHO1FBQ0hDLElBQUk7UUFDSkMsSUFBSTtJQUNSLEdBQUc7UUFDQ0MsWUFBWTtRQUNaQyxhQUFhO0lBQ2pCO0lBQ0EsZUFBZTtJQUNmLE9BQU9yRSxPQUFPc0UsTUFBTSxDQUFDO1FBQ2pCLEdBQUcsQ0FBQyxHQUFHaEUsYUFBYWlFLE9BQU8sRUFBRVYsTUFBTWxDLENBQUMsRUFBRWtDLE1BQU1PLFVBQVUsQ0FBQztRQUN2RCxHQUFHUCxLQUFLO1FBQ1IsR0FBRztZQUFFakMsR0FBR2lDLE1BQU1FLEVBQUUsQ0FBQ1MsS0FBSztRQUFDLENBQUM7SUFDNUI7QUFDSjtBQUNBdEUscUJBQXFCLEdBQUdFLGVBQ3hCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bS1jcnlwdG9ncmFwaHkvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvY3VydmUuanM/OTlhOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVCYXNpYyA9IGV4cG9ydHMud05BRiA9IHZvaWQgMDtcbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIEFiZWxpYW4gZ3JvdXAgdXRpbGl0aWVzXG5jb25zdCBtb2R1bGFyX2pzXzEgPSByZXF1aXJlKFwiLi9tb2R1bGFyLmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuLy8gRWxsaXB0aWMgY3VydmUgbXVsdGlwbGljYXRpb24gb2YgUG9pbnQgYnkgc2NhbGFyLiBGcmFnaWxlLlxuLy8gU2NhbGFycyBzaG91bGQgYWx3YXlzIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcjogdGhpcyBzaG91bGQgYmUgY2hlY2tlZCBpbnNpZGUgb2YgYSBjdXJ2ZSBpdHNlbGYuXG4vLyBDcmVhdGVzIHByZWNvbXB1dGF0aW9uIHRhYmxlcyBmb3IgZmFzdCBtdWx0aXBsaWNhdGlvbjpcbi8vIC0gcHJpdmF0ZSBzY2FsYXIgaXMgc3BsaXQgYnkgZml4ZWQgc2l6ZSB3aW5kb3dzIG9mIFcgYml0c1xuLy8gLSBldmVyeSB3aW5kb3cgcG9pbnQgaXMgY29sbGVjdGVkIGZyb20gd2luZG93J3MgdGFibGUgJiBhZGRlZCB0byBhY2N1bXVsYXRvclxuLy8gLSBzaW5jZSB3aW5kb3dzIGFyZSBkaWZmZXJlbnQsIHNhbWUgcG9pbnQgaW5zaWRlIHRhYmxlcyB3b24ndCBiZSBhY2Nlc3NlZCBtb3JlIHRoYW4gb25jZSBwZXIgY2FsY1xuLy8gLSBlYWNoIG11bHRpcGxpY2F0aW9uIGlzICdNYXRoLmNlaWwoQ1VSVkVfT1JERVIgLyDwnZGKKSArIDEnIHBvaW50IGFkZGl0aW9ucyAoZml4ZWQgZm9yIGFueSBzY2FsYXIpXG4vLyAtICsxIHdpbmRvdyBpcyBuZWNjZXNzYXJ5IGZvciB3TkFGXG4vLyAtIHdOQUYgcmVkdWNlcyB0YWJsZSBzaXplOiAyeCBsZXNzIG1lbW9yeSArIDJ4IGZhc3RlciBnZW5lcmF0aW9uLCBidXQgMTAlIHNsb3dlciBtdWx0aXBsaWNhdGlvblxuLy8gVE9ETzogUmVzZWFyY2ggcmV0dXJuaW5nIDJkIEpTIGFycmF5IG9mIHdpbmRvd3MsIGluc3RlYWQgb2YgYSBzaW5nbGUgd2luZG93LiBUaGlzIHdvdWxkIGFsbG93XG4vLyB3aW5kb3dzIHRvIGJlIGluIGRpZmZlcmVudCBtZW1vcnkgbG9jYXRpb25zXG5mdW5jdGlvbiB3TkFGKGMsIGJpdHMpIHtcbiAgICBjb25zdCBjb25zdFRpbWVOZWdhdGUgPSAoY29uZGl0aW9uLCBpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IG5lZyA9IGl0ZW0ubmVnYXRlKCk7XG4gICAgICAgIHJldHVybiBjb25kaXRpb24gPyBuZWcgOiBpdGVtO1xuICAgIH07XG4gICAgY29uc3Qgb3B0cyA9IChXKSA9PiB7XG4gICAgICAgIGNvbnN0IHdpbmRvd3MgPSBNYXRoLmNlaWwoYml0cyAvIFcpICsgMTsgLy8gKzEsIGJlY2F1c2VcbiAgICAgICAgY29uc3Qgd2luZG93U2l6ZSA9IDIgKiogKFcgLSAxKTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgcmV0dXJuIHsgd2luZG93cywgd2luZG93U2l6ZSB9O1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29uc3RUaW1lTmVnYXRlLFxuICAgICAgICAvLyBub24tY29uc3QgdGltZSBtdWx0aXBsaWNhdGlvbiBsYWRkZXJcbiAgICAgICAgdW5zYWZlTGFkZGVyKGVsbSwgbikge1xuICAgICAgICAgICAgbGV0IHAgPSBjLlpFUk87XG4gICAgICAgICAgICBsZXQgZCA9IGVsbTtcbiAgICAgICAgICAgIHdoaWxlIChuID4gXzBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKG4gJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBuID4+PSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSB3TkFGIHByZWNvbXB1dGF0aW9uIHdpbmRvdy4gVXNlZCBmb3IgY2FjaGluZy5cbiAgICAgICAgICogRGVmYXVsdCB3aW5kb3cgc2l6ZSBpcyBzZXQgYnkgYHV0aWxzLnByZWNvbXB1dGUoKWAgYW5kIGlzIGVxdWFsIHRvIDguXG4gICAgICAgICAqIE51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgZGVwZW5kcyBvbiB0aGUgY3VydmUgc2l6ZTpcbiAgICAgICAgICogMl4o8J2RiuKIkjEpICogKE1hdGguY2VpbCjwnZGbIC8g8J2RiikgKyAxKSwgd2hlcmU6XG4gICAgICAgICAqIC0g8J2RiiBpcyB0aGUgd2luZG93IHNpemVcbiAgICAgICAgICogLSDwnZGbIGlzIHRoZSBiaXRsZW5ndGggb2YgdGhlIGN1cnZlIG9yZGVyLlxuICAgICAgICAgKiBGb3IgYSAyNTYtYml0IGN1cnZlIGFuZCB3aW5kb3cgc2l6ZSA4LCB0aGUgbnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBpcyAxMjggKiAzMyA9IDQyMjQuXG4gICAgICAgICAqIEByZXR1cm5zIHByZWNvbXB1dGVkIHBvaW50IHRhYmxlcyBmbGF0dGVuZWQgdG8gYSBzaW5nbGUgYXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIHByZWNvbXB1dGVXaW5kb3coZWxtLCBXKSB7XG4gICAgICAgICAgICBjb25zdCB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfSA9IG9wdHMoVyk7XG4gICAgICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICAgICAgICAgIGxldCBwID0gZWxtO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBwO1xuICAgICAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgICAgICBiYXNlID0gcDtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgICAgICAvLyA9MSwgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHdpbmRvd1NpemU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBiYXNlID0gYmFzZS5hZGQocCk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwID0gYmFzZS5kb3VibGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnRzIGVjIG11bHRpcGxpY2F0aW9uIHVzaW5nIHByZWNvbXB1dGVkIHRhYmxlcyBhbmQgdy1hcnkgbm9uLWFkamFjZW50IGZvcm0uXG4gICAgICAgICAqIEBwYXJhbSBXIHdpbmRvdyBzaXplXG4gICAgICAgICAqIEBwYXJhbSBwcmVjb21wdXRlcyBwcmVjb21wdXRlZCB0YWJsZXNcbiAgICAgICAgICogQHBhcmFtIG4gc2NhbGFyICh3ZSBkb24ndCBjaGVjayBoZXJlLCBidXQgc2hvdWxkIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcilcbiAgICAgICAgICogQHJldHVybnMgcmVhbCBhbmQgZmFrZSAoZm9yIGNvbnN0LXRpbWUpIHBvaW50c1xuICAgICAgICAgKi9cbiAgICAgICAgd05BRihXLCBwcmVjb21wdXRlcywgbikge1xuICAgICAgICAgICAgLy8gVE9ETzogbWF5YmUgY2hlY2sgdGhhdCBzY2FsYXIgaXMgbGVzcyB0aGFuIGdyb3VwIG9yZGVyPyB3TkFGIGJlaGF2aW91cyBpcyB1bmRlZmluZWQgb3RoZXJ3aXNlXG4gICAgICAgICAgICAvLyBCdXQgbmVlZCB0byBjYXJlZnVsbHkgcmVtb3ZlIG90aGVyIGNoZWNrcyBiZWZvcmUgd05BRi4gT1JERVIgPT0gYml0cyBoZXJlXG4gICAgICAgICAgICBjb25zdCB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfSA9IG9wdHMoVyk7XG4gICAgICAgICAgICBsZXQgcCA9IGMuWkVSTztcbiAgICAgICAgICAgIGxldCBmID0gYy5CQVNFO1xuICAgICAgICAgICAgY29uc3QgbWFzayA9IEJpZ0ludCgyICoqIFcgLSAxKTsgLy8gQ3JlYXRlIG1hc2sgd2l0aCBXIG9uZXM6IDBiMTExMSBmb3IgVz00IGV0Yy5cbiAgICAgICAgICAgIGNvbnN0IG1heE51bWJlciA9IDIgKiogVztcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0QnkgPSBCaWdJbnQoVyk7XG4gICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHdpbmRvdyAqIHdpbmRvd1NpemU7XG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBXIGJpdHMuXG4gICAgICAgICAgICAgICAgbGV0IHdiaXRzID0gTnVtYmVyKG4gJiBtYXNrKTtcbiAgICAgICAgICAgICAgICAvLyBTaGlmdCBudW1iZXIgYnkgVyBiaXRzLlxuICAgICAgICAgICAgICAgIG4gPj49IHNoaWZ0Qnk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGJpdHMgYXJlIGJpZ2dlciB0aGFuIG1heCBzaXplLCB3ZSdsbCBzcGxpdCB0aG9zZS5cbiAgICAgICAgICAgICAgICAvLyArMjI0ID0+IDI1NiAtIDMyXG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID4gd2luZG93U2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB3Yml0cyAtPSBtYXhOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIG4gKz0gXzFuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNvZGUgd2FzIGZpcnN0IHdyaXR0ZW4gd2l0aCBhc3N1bXB0aW9uIHRoYXQgJ2YnIGFuZCAncCcgd2lsbCBuZXZlciBiZSBpbmZpbml0eSBwb2ludDpcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSBlYWNoIGFkZGl0aW9uIGlzIG11bHRpcGxpZWQgYnkgMiAqKiBXLCBpdCBjYW5ub3QgY2FuY2VsIGVhY2ggb3RoZXIuIEhvd2V2ZXIsXG4gICAgICAgICAgICAgICAgLy8gdGhlcmUgaXMgbmVnYXRlIG5vdzogaXQgaXMgcG9zc2libGUgdGhhdCBuZWdhdGVkIGVsZW1lbnQgZnJvbSBsb3cgdmFsdWVcbiAgICAgICAgICAgICAgICAvLyB3b3VsZCBiZSB0aGUgc2FtZSBhcyBoaWdoIGVsZW1lbnQsIHdoaWNoIHdpbGwgY3JlYXRlIGNhcnJ5IGludG8gbmV4dCB3aW5kb3cuXG4gICAgICAgICAgICAgICAgLy8gSXQncyBub3Qgb2J2aW91cyBob3cgdGhpcyBjYW4gZmFpbCwgYnV0IHN0aWxsIHdvcnRoIGludmVzdGlnYXRpbmcgbGF0ZXIuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgb250byBaZXJvIHBvaW50LlxuICAgICAgICAgICAgICAgIC8vIEFkZCByYW5kb20gcG9pbnQgaW5zaWRlIGN1cnJlbnQgd2luZG93IHRvIGYuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MSA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQyID0gb2Zmc2V0ICsgTWF0aC5hYnMod2JpdHMpIC0gMTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgICAgICAgICBjb25zdCBjb25kMSA9IHdpbmRvdyAlIDIgIT09IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgY29uZDIgPSB3Yml0cyA8IDA7XG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBtb3N0IGltcG9ydGFudCBwYXJ0IGZvciBjb25zdC10aW1lIGdldFB1YmxpY0tleVxuICAgICAgICAgICAgICAgICAgICBmID0gZi5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQxLCBwcmVjb21wdXRlc1tvZmZzZXQxXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMiwgcHJlY29tcHV0ZXNbb2Zmc2V0Ml0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBKSVQtY29tcGlsZXIgc2hvdWxkIG5vdCBlbGltaW5hdGUgZiBoZXJlLCBzaW5jZSBpdCB3aWxsIGxhdGVyIGJlIHVzZWQgaW4gbm9ybWFsaXplWigpXG4gICAgICAgICAgICAvLyBFdmVuIGlmIHRoZSB2YXJpYWJsZSBpcyBzdGlsbCB1bnVzZWQsIHRoZXJlIGFyZSBzb21lIGNoZWNrcyB3aGljaCB3aWxsXG4gICAgICAgICAgICAvLyB0aHJvdyBhbiBleGNlcHRpb24sIHNvIGNvbXBpbGVyIG5lZWRzIHRvIHByb3ZlIHRoZXkgd29uJ3QgaGFwcGVuLCB3aGljaCBpcyBoYXJkLlxuICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB0aGVyZSBpcyBhIHdheSB0byBGIGJlIGluZmluaXR5LXBvaW50IGV2ZW4gaWYgcCBpcyBub3QsXG4gICAgICAgICAgICAvLyB3aGljaCBtYWtlcyBpdCBsZXNzIGNvbnN0LXRpbWU6IGFyb3VuZCAxIGJpZ2ludCBtdWx0aXBseS5cbiAgICAgICAgICAgIHJldHVybiB7IHAsIGYgfTtcbiAgICAgICAgfSxcbiAgICAgICAgd05BRkNhY2hlZChQLCBwcmVjb21wdXRlc01hcCwgbiwgdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdCBXID0gUC5fV0lORE9XX1NJWkUgfHwgMTtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwcmVjb21wdXRlcyBvbiBhIGZpcnN0IHJ1biwgcmV1c2UgdGhlbSBhZnRlclxuICAgICAgICAgICAgbGV0IGNvbXAgPSBwcmVjb21wdXRlc01hcC5nZXQoUCk7XG4gICAgICAgICAgICBpZiAoIWNvbXApIHtcbiAgICAgICAgICAgICAgICBjb21wID0gdGhpcy5wcmVjb21wdXRlV2luZG93KFAsIFcpO1xuICAgICAgICAgICAgICAgIGlmIChXICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWNvbXB1dGVzTWFwLnNldChQLCB0cmFuc2Zvcm0oY29tcCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLndOQUYoVywgY29tcCwgbik7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydHMud05BRiA9IHdOQUY7XG5mdW5jdGlvbiB2YWxpZGF0ZUJhc2ljKGN1cnZlKSB7XG4gICAgKDAsIG1vZHVsYXJfanNfMS52YWxpZGF0ZUZpZWxkKShjdXJ2ZS5GcCk7XG4gICAgKDAsIHV0aWxzX2pzXzEudmFsaWRhdGVPYmplY3QpKGN1cnZlLCB7XG4gICAgICAgIG46ICdiaWdpbnQnLFxuICAgICAgICBoOiAnYmlnaW50JyxcbiAgICAgICAgR3g6ICdmaWVsZCcsXG4gICAgICAgIEd5OiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgbkJpdExlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBuQnl0ZUxlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgIH0pO1xuICAgIC8vIFNldCBkZWZhdWx0c1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgLi4uKDAsIG1vZHVsYXJfanNfMS5uTGVuZ3RoKShjdXJ2ZS5uLCBjdXJ2ZS5uQml0TGVuZ3RoKSxcbiAgICAgICAgLi4uY3VydmUsXG4gICAgICAgIC4uLnsgcDogY3VydmUuRnAuT1JERVIgfSxcbiAgICB9KTtcbn1cbmV4cG9ydHMudmFsaWRhdGVCYXNpYyA9IHZhbGlkYXRlQmFzaWM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdXJ2ZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ2YWxpZGF0ZUJhc2ljIiwid05BRiIsIm1vZHVsYXJfanNfMSIsInJlcXVpcmUiLCJ1dGlsc19qc18xIiwiXzBuIiwiQmlnSW50IiwiXzFuIiwiYyIsImJpdHMiLCJjb25zdFRpbWVOZWdhdGUiLCJjb25kaXRpb24iLCJpdGVtIiwibmVnIiwibmVnYXRlIiwib3B0cyIsIlciLCJ3aW5kb3dzIiwiTWF0aCIsImNlaWwiLCJ3aW5kb3dTaXplIiwidW5zYWZlTGFkZGVyIiwiZWxtIiwibiIsInAiLCJaRVJPIiwiZCIsImFkZCIsImRvdWJsZSIsInByZWNvbXB1dGVXaW5kb3ciLCJwb2ludHMiLCJiYXNlIiwid2luZG93IiwicHVzaCIsImkiLCJwcmVjb21wdXRlcyIsImYiLCJCQVNFIiwibWFzayIsIm1heE51bWJlciIsInNoaWZ0QnkiLCJvZmZzZXQiLCJ3Yml0cyIsIk51bWJlciIsIm9mZnNldDEiLCJvZmZzZXQyIiwiYWJzIiwiY29uZDEiLCJjb25kMiIsIndOQUZDYWNoZWQiLCJQIiwicHJlY29tcHV0ZXNNYXAiLCJ0cmFuc2Zvcm0iLCJfV0lORE9XX1NJWkUiLCJjb21wIiwiZ2V0Iiwic2V0IiwiY3VydmUiLCJ2YWxpZGF0ZUZpZWxkIiwiRnAiLCJ2YWxpZGF0ZU9iamVjdCIsImgiLCJHeCIsIkd5IiwibkJpdExlbmd0aCIsIm5CeXRlTGVuZ3RoIiwiZnJlZXplIiwibkxlbmd0aCIsIk9SREVSIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/curves/abstract/curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/curves/abstract/hash-to-curve.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/ethereum-cryptography/node_modules/@noble/curves/abstract/hash-to-curve.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createHasher = exports.isogenyMap = exports.hash_to_field = exports.expand_message_xof = exports.expand_message_xmd = void 0;\nconst modular_js_1 = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/curves/abstract/modular.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/curves/abstract/utils.js\");\nfunction validateDST(dst) {\n    if (dst instanceof Uint8Array) return dst;\n    if (typeof dst === \"string\") return (0, utils_js_1.utf8ToBytes)(dst);\n    throw new Error(\"DST must be Uint8Array or string\");\n}\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = utils_js_1.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    if (value < 0 || value >= 1 << 8 * length) {\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n    }\n    const res = Array.from({\n        length\n    }).fill(0);\n    for(let i = length - 1; i >= 0; i--){\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for(let i = 0; i < a.length; i++){\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction isBytes(item) {\n    if (!(item instanceof Uint8Array)) throw new Error(\"Uint8Array expected\");\n}\nfunction isNum(item) {\n    if (!Number.isSafeInteger(item)) throw new Error(\"number expected\");\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-11#section-5.4.1\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-5.3.3\n    if (DST.length > 255) DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)(\"H2C-OVERSIZE-DST-\"), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255) throw new Error(\"Invalid xmd length\");\n    const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for(let i = 1; i <= ell; i++){\n        const args = [\n            strxor(b_0, b[i - 1]),\n            i2osp(i + 1, 1),\n            DST_prime\n        ];\n        b[i] = H((0, utils_js_1.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\nexports.expand_message_xmd = expand_message_xmd;\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil(2 * k / 8);\n        DST = H.create({\n            dkLen\n        }).update((0, utils_js_1.utf8ToBytes)(\"H2C-OVERSIZE-DST-\")).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255) throw new Error(\"expand_message_xof: invalid lenInBytes\");\n    return H.create({\n        dkLen: lenInBytes\n    }).update(msg).update(i2osp(lenInBytes, 2))// 2. DST_prime = DST || I2OSP(len(DST), 1)\n    .update(DST).update(i2osp(DST.length, 1)).digest();\n}\nexports.expand_message_xof = expand_message_xof;\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-11#section-5.3\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */ function hash_to_field(msg, count, options) {\n    (0, utils_js_1.validateObject)(options, {\n        DST: \"string\",\n        p: \"bigint\",\n        m: \"isSafeInteger\",\n        k: \"isSafeInteger\",\n        hash: \"hash\"\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    isBytes(msg);\n    isNum(count);\n    const DST = validateDST(_DST);\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === \"xmd\") {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    } else if (expand === \"xof\") {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    } else if (expand === \"_internal_pass\") {\n        // for internal tests only\n        prb = msg;\n    } else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for(let i = 0; i < count; i++){\n        const e = new Array(m);\n        for(let j = 0; j < m; j++){\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0, modular_js_1.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nexports.hash_to_field = hash_to_field;\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i)=>Array.from(i).reverse());\n    return (x, y)=>{\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val)=>val.reduce((acc, i)=>field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return {\n            x,\n            y\n        };\n    };\n}\nexports.isogenyMap = isogenyMap;\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== \"function\") throw new Error(\"mapToCurve() must be defined\");\n    return {\n        // Encodes byte string to elliptic curve\n        // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3\n        hashToCurve (msg, options) {\n            const u = hash_to_field(msg, 2, {\n                ...def,\n                DST: def.DST,\n                ...options\n            });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3\n        encodeToCurve (msg, options) {\n            const u = hash_to_field(msg, 1, {\n                ...def,\n                DST: def.encodeDST,\n                ...options\n            });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        }\n    };\n}\nexports.createHasher = createHasher; //# sourceMappingURL=hash-to-curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG9CQUFvQixHQUFHQSxrQkFBa0IsR0FBR0EscUJBQXFCLEdBQUdBLDBCQUEwQixHQUFHQSwwQkFBMEIsR0FBRyxLQUFLO0FBQ25JLE1BQU1PLGVBQWVDLG1CQUFPQSxDQUFDLCtHQUFjO0FBQzNDLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLDJHQUFZO0FBQ3ZDLFNBQVNFLFlBQVlDLEdBQUc7SUFDcEIsSUFBSUEsZUFBZUMsWUFDZixPQUFPRDtJQUNYLElBQUksT0FBT0EsUUFBUSxVQUNmLE9BQU8sQ0FBQyxHQUFHRixXQUFXSSxXQUFXLEVBQUVGO0lBQ3ZDLE1BQU0sSUFBSUcsTUFBTTtBQUNwQjtBQUNBLDZGQUE2RjtBQUM3RixNQUFNQyxRQUFRTixXQUFXTyxlQUFlO0FBQ3hDLDRDQUE0QztBQUM1QyxTQUFTQyxNQUFNaEIsS0FBSyxFQUFFaUIsTUFBTTtJQUN4QixJQUFJakIsUUFBUSxLQUFLQSxTQUFTLEtBQU0sSUFBSWlCLFFBQVM7UUFDekMsTUFBTSxJQUFJSixNQUFNLENBQUMsc0JBQXNCLEVBQUViLE1BQU0sUUFBUSxFQUFFaUIsT0FBTyxDQUFDO0lBQ3JFO0lBQ0EsTUFBTUMsTUFBTUMsTUFBTUMsSUFBSSxDQUFDO1FBQUVIO0lBQU8sR0FBR0ksSUFBSSxDQUFDO0lBQ3hDLElBQUssSUFBSUMsSUFBSUwsU0FBUyxHQUFHSyxLQUFLLEdBQUdBLElBQUs7UUFDbENKLEdBQUcsQ0FBQ0ksRUFBRSxHQUFHdEIsUUFBUTtRQUNqQkEsV0FBVztJQUNmO0lBQ0EsT0FBTyxJQUFJVyxXQUFXTztBQUMxQjtBQUNBLFNBQVNLLE9BQU9DLENBQUMsRUFBRUMsQ0FBQztJQUNoQixN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QUNsQjtBQUNKO0FBQ0FsRixrQkFBa0IsR0FBR0c7QUFDckIsU0FBU0QsYUFBYTJGLEtBQUssRUFBRUMsVUFBVSxFQUFFQyxHQUFHO0lBQ3hDLElBQUksT0FBT0QsZUFBZSxZQUN0QixNQUFNLElBQUloRixNQUFNO0lBQ3BCLE9BQU87UUFDSCx3Q0FBd0M7UUFDeEMsbUZBQW1GO1FBQ25Ga0YsYUFBWS9ELEdBQUcsRUFBRXlCLE9BQU87WUFDcEIsTUFBTVksSUFBSWxFLGNBQWM2QixLQUFLLEdBQUc7Z0JBQUUsR0FBRzhELEdBQUc7Z0JBQUU3RCxLQUFLNkQsSUFBSTdELEdBQUc7Z0JBQUUsR0FBR3dCLE9BQU87WUFBQztZQUNuRSxNQUFNdUMsS0FBS0osTUFBTUssVUFBVSxDQUFDSixXQUFXeEIsQ0FBQyxDQUFDLEVBQUU7WUFDM0MsTUFBTTZCLEtBQUtOLE1BQU1LLFVBQVUsQ0FBQ0osV0FBV3hCLENBQUMsQ0FBQyxFQUFFO1lBQzNDLE1BQU04QixJQUFJSCxHQUFHUCxHQUFHLENBQUNTLElBQUlFLGFBQWE7WUFDbENELEVBQUVFLGNBQWM7WUFDaEIsT0FBT0Y7UUFDWDtRQUNBLG1GQUFtRjtRQUNuRkcsZUFBY3RFLEdBQUcsRUFBRXlCLE9BQU87WUFDdEIsTUFBTVksSUFBSWxFLGNBQWM2QixLQUFLLEdBQUc7Z0JBQUUsR0FBRzhELEdBQUc7Z0JBQUU3RCxLQUFLNkQsSUFBSVMsU0FBUztnQkFBRSxHQUFHOUMsT0FBTztZQUFDO1lBQ3pFLE1BQU0wQyxJQUFJUCxNQUFNSyxVQUFVLENBQUNKLFdBQVd4QixDQUFDLENBQUMsRUFBRSxHQUFHK0IsYUFBYTtZQUMxREQsRUFBRUUsY0FBYztZQUNoQixPQUFPRjtRQUNYO0lBQ0o7QUFDSjtBQUNBcEcsb0JBQW9CLEdBQUdFLGNBQ3ZCLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bS1jcnlwdG9ncmFwaHkvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcz9iYWM1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVIYXNoZXIgPSBleHBvcnRzLmlzb2dlbnlNYXAgPSBleHBvcnRzLmhhc2hfdG9fZmllbGQgPSBleHBvcnRzLmV4cGFuZF9tZXNzYWdlX3hvZiA9IGV4cG9ydHMuZXhwYW5kX21lc3NhZ2VfeG1kID0gdm9pZCAwO1xuY29uc3QgbW9kdWxhcl9qc18xID0gcmVxdWlyZShcIi4vbW9kdWxhci5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbmZ1bmN0aW9uIHZhbGlkYXRlRFNUKGRzdCkge1xuICAgIGlmIChkc3QgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICByZXR1cm4gZHN0O1xuICAgIGlmICh0eXBlb2YgZHN0ID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc19qc18xLnV0ZjhUb0J5dGVzKShkc3QpO1xuICAgIHRocm93IG5ldyBFcnJvcignRFNUIG11c3QgYmUgVWludDhBcnJheSBvciBzdHJpbmcnKTtcbn1cbi8vIE9jdGV0IFN0cmVhbSB0byBJbnRlZ2VyLiBcInNwZWNcIiBpbXBsZW1lbnRhdGlvbiBvZiBvczJpcCBpcyAyLjV4IHNsb3dlciB2cyBieXRlc1RvTnVtYmVyQkUuXG5jb25zdCBvczJpcCA9IHV0aWxzX2pzXzEuYnl0ZXNUb051bWJlckJFO1xuLy8gSW50ZWdlciB0byBPY3RldCBTdHJlYW0gKG51bWJlclRvQnl0ZXNCRSlcbmZ1bmN0aW9uIGkyb3NwKHZhbHVlLCBsZW5ndGgpIHtcbiAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID49IDEgPDwgKDggKiBsZW5ndGgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYmFkIEkyT1NQIGNhbGw6IHZhbHVlPSR7dmFsdWV9IGxlbmd0aD0ke2xlbmd0aH1gKTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aCB9KS5maWxsKDApO1xuICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICByZXNbaV0gPSB2YWx1ZSAmIDB4ZmY7XG4gICAgICAgIHZhbHVlID4+Pj0gODtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlcyk7XG59XG5mdW5jdGlvbiBzdHJ4b3IoYSwgYikge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGEubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYVtpXSBeIGJbaV07XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiBpc0J5dGVzKGl0ZW0pIHtcbiAgICBpZiAoIShpdGVtIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xufVxuZnVuY3Rpb24gaXNOdW0oaXRlbSkge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoaXRlbSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbnVtYmVyIGV4cGVjdGVkJyk7XG59XG4vLyBQcm9kdWNlcyBhIHVuaWZvcm1seSByYW5kb20gYnl0ZSBzdHJpbmcgdXNpbmcgYSBjcnlwdG9ncmFwaGljIGhhc2ggZnVuY3Rpb24gSCB0aGF0IG91dHB1dHMgYiBiaXRzXG4vLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlydGYtY2ZyZy1oYXNoLXRvLWN1cnZlLTExI3NlY3Rpb24tNS40LjFcbmZ1bmN0aW9uIGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuSW5CeXRlcywgSCkge1xuICAgIGlzQnl0ZXMobXNnKTtcbiAgICBpc0J5dGVzKERTVCk7XG4gICAgaXNOdW0obGVuSW5CeXRlcyk7XG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pcnRmLWNmcmctaGFzaC10by1jdXJ2ZS0xNiNzZWN0aW9uLTUuMy4zXG4gICAgaWYgKERTVC5sZW5ndGggPiAyNTUpXG4gICAgICAgIERTVCA9IEgoKDAsIHV0aWxzX2pzXzEuY29uY2F0Qnl0ZXMpKCgwLCB1dGlsc19qc18xLnV0ZjhUb0J5dGVzKSgnSDJDLU9WRVJTSVpFLURTVC0nKSwgRFNUKSk7XG4gICAgY29uc3QgeyBvdXRwdXRMZW46IGJfaW5fYnl0ZXMsIGJsb2NrTGVuOiByX2luX2J5dGVzIH0gPSBIO1xuICAgIGNvbnN0IGVsbCA9IE1hdGguY2VpbChsZW5JbkJ5dGVzIC8gYl9pbl9ieXRlcyk7XG4gICAgaWYgKGVsbCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHhtZCBsZW5ndGgnKTtcbiAgICBjb25zdCBEU1RfcHJpbWUgPSAoMCwgdXRpbHNfanNfMS5jb25jYXRCeXRlcykoRFNULCBpMm9zcChEU1QubGVuZ3RoLCAxKSk7XG4gICAgY29uc3QgWl9wYWQgPSBpMm9zcCgwLCByX2luX2J5dGVzKTtcbiAgICBjb25zdCBsX2lfYl9zdHIgPSBpMm9zcChsZW5JbkJ5dGVzLCAyKTsgLy8gbGVuX2luX2J5dGVzX3N0clxuICAgIGNvbnN0IGIgPSBuZXcgQXJyYXkoZWxsKTtcbiAgICBjb25zdCBiXzAgPSBIKCgwLCB1dGlsc19qc18xLmNvbmNhdEJ5dGVzKShaX3BhZCwgbXNnLCBsX2lfYl9zdHIsIGkyb3NwKDAsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBiWzBdID0gSCgoMCwgdXRpbHNfanNfMS5jb25jYXRCeXRlcykoYl8wLCBpMm9zcCgxLCAxKSwgRFNUX3ByaW1lKSk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gZWxsOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXJncyA9IFtzdHJ4b3IoYl8wLCBiW2kgLSAxXSksIGkyb3NwKGkgKyAxLCAxKSwgRFNUX3ByaW1lXTtcbiAgICAgICAgYltpXSA9IEgoKDAsIHV0aWxzX2pzXzEuY29uY2F0Qnl0ZXMpKC4uLmFyZ3MpKTtcbiAgICB9XG4gICAgY29uc3QgcHNldWRvX3JhbmRvbV9ieXRlcyA9ICgwLCB1dGlsc19qc18xLmNvbmNhdEJ5dGVzKSguLi5iKTtcbiAgICByZXR1cm4gcHNldWRvX3JhbmRvbV9ieXRlcy5zbGljZSgwLCBsZW5JbkJ5dGVzKTtcbn1cbmV4cG9ydHMuZXhwYW5kX21lc3NhZ2VfeG1kID0gZXhwYW5kX21lc3NhZ2VfeG1kO1xuZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBrLCBIKSB7XG4gICAgaXNCeXRlcyhtc2cpO1xuICAgIGlzQnl0ZXMoRFNUKTtcbiAgICBpc051bShsZW5JbkJ5dGVzKTtcbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlydGYtY2ZyZy1oYXNoLXRvLWN1cnZlLTE2I3NlY3Rpb24tNS4zLjNcbiAgICAvLyBEU1QgPSBIKCdIMkMtT1ZFUlNJWkUtRFNULScgfHwgYV92ZXJ5X2xvbmdfRFNULCBNYXRoLmNlaWwoKGxlbkluQnl0ZXMgKiBrKSAvIDgpKTtcbiAgICBpZiAoRFNULmxlbmd0aCA+IDI1NSkge1xuICAgICAgICBjb25zdCBka0xlbiA9IE1hdGguY2VpbCgoMiAqIGspIC8gOCk7XG4gICAgICAgIERTVCA9IEguY3JlYXRlKHsgZGtMZW4gfSkudXBkYXRlKCgwLCB1dGlsc19qc18xLnV0ZjhUb0J5dGVzKSgnSDJDLU9WRVJTSVpFLURTVC0nKSkudXBkYXRlKERTVCkuZGlnZXN0KCk7XG4gICAgfVxuICAgIGlmIChsZW5JbkJ5dGVzID4gNjU1MzUgfHwgRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmRfbWVzc2FnZV94b2Y6IGludmFsaWQgbGVuSW5CeXRlcycpO1xuICAgIHJldHVybiAoSC5jcmVhdGUoeyBka0xlbjogbGVuSW5CeXRlcyB9KVxuICAgICAgICAudXBkYXRlKG1zZylcbiAgICAgICAgLnVwZGF0ZShpMm9zcChsZW5JbkJ5dGVzLCAyKSlcbiAgICAgICAgLy8gMi4gRFNUX3ByaW1lID0gRFNUIHx8IEkyT1NQKGxlbihEU1QpLCAxKVxuICAgICAgICAudXBkYXRlKERTVClcbiAgICAgICAgLnVwZGF0ZShpMm9zcChEU1QubGVuZ3RoLCAxKSlcbiAgICAgICAgLmRpZ2VzdCgpKTtcbn1cbmV4cG9ydHMuZXhwYW5kX21lc3NhZ2VfeG9mID0gZXhwYW5kX21lc3NhZ2VfeG9mO1xuLyoqXG4gKiBIYXNoZXMgYXJiaXRyYXJ5LWxlbmd0aCBieXRlIHN0cmluZ3MgdG8gYSBsaXN0IG9mIG9uZSBvciBtb3JlIGVsZW1lbnRzIG9mIGEgZmluaXRlIGZpZWxkIEZcbiAqIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaXJ0Zi1jZnJnLWhhc2gtdG8tY3VydmUtMTEjc2VjdGlvbi01LjNcbiAqIEBwYXJhbSBtc2cgYSBieXRlIHN0cmluZyBjb250YWluaW5nIHRoZSBtZXNzYWdlIHRvIGhhc2hcbiAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIG9mIEYgdG8gb3V0cHV0XG4gKiBAcGFyYW0gb3B0aW9ucyBge0RTVDogc3RyaW5nLCBwOiBiaWdpbnQsIG06IG51bWJlciwgazogbnVtYmVyLCBleHBhbmQ6ICd4bWQnIHwgJ3hvZicsIGhhc2g6IEh9YCwgc2VlIGFib3ZlXG4gKiBAcmV0dXJucyBbdV8wLCAuLi4sIHVfKGNvdW50IC0gMSldLCBhIGxpc3Qgb2YgZmllbGQgZWxlbWVudHMuXG4gKi9cbmZ1bmN0aW9uIGhhc2hfdG9fZmllbGQobXNnLCBjb3VudCwgb3B0aW9ucykge1xuICAgICgwLCB1dGlsc19qc18xLnZhbGlkYXRlT2JqZWN0KShvcHRpb25zLCB7XG4gICAgICAgIERTVDogJ3N0cmluZycsXG4gICAgICAgIHA6ICdiaWdpbnQnLFxuICAgICAgICBtOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIGs6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgaGFzaDogJ2hhc2gnLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgcCwgaywgbSwgaGFzaCwgZXhwYW5kLCBEU1Q6IF9EU1QgfSA9IG9wdGlvbnM7XG4gICAgaXNCeXRlcyhtc2cpO1xuICAgIGlzTnVtKGNvdW50KTtcbiAgICBjb25zdCBEU1QgPSB2YWxpZGF0ZURTVChfRFNUKTtcbiAgICBjb25zdCBsb2cycCA9IHAudG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIGNvbnN0IEwgPSBNYXRoLmNlaWwoKGxvZzJwICsgaykgLyA4KTsgLy8gc2VjdGlvbiA1LjEgb2YgaWV0ZiBkcmFmdCBsaW5rIGFib3ZlXG4gICAgY29uc3QgbGVuX2luX2J5dGVzID0gY291bnQgKiBtICogTDtcbiAgICBsZXQgcHJiOyAvLyBwc2V1ZG9fcmFuZG9tX2J5dGVzXG4gICAgaWYgKGV4cGFuZCA9PT0gJ3htZCcpIHtcbiAgICAgICAgcHJiID0gZXhwYW5kX21lc3NhZ2VfeG1kKG1zZywgRFNULCBsZW5faW5fYnl0ZXMsIGhhc2gpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHBhbmQgPT09ICd4b2YnKSB7XG4gICAgICAgIHByYiA9IGV4cGFuZF9tZXNzYWdlX3hvZihtc2csIERTVCwgbGVuX2luX2J5dGVzLCBrLCBoYXNoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwYW5kID09PSAnX2ludGVybmFsX3Bhc3MnKSB7XG4gICAgICAgIC8vIGZvciBpbnRlcm5hbCB0ZXN0cyBvbmx5XG4gICAgICAgIHByYiA9IG1zZztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kIG11c3QgYmUgXCJ4bWRcIiBvciBcInhvZlwiJyk7XG4gICAgfVxuICAgIGNvbnN0IHUgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBlID0gbmV3IEFycmF5KG0pO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG07IGorKykge1xuICAgICAgICAgICAgY29uc3QgZWxtX29mZnNldCA9IEwgKiAoaiArIGkgKiBtKTtcbiAgICAgICAgICAgIGNvbnN0IHR2ID0gcHJiLnN1YmFycmF5KGVsbV9vZmZzZXQsIGVsbV9vZmZzZXQgKyBMKTtcbiAgICAgICAgICAgIGVbal0gPSAoMCwgbW9kdWxhcl9qc18xLm1vZCkob3MyaXAodHYpLCBwKTtcbiAgICAgICAgfVxuICAgICAgICB1W2ldID0gZTtcbiAgICB9XG4gICAgcmV0dXJuIHU7XG59XG5leHBvcnRzLmhhc2hfdG9fZmllbGQgPSBoYXNoX3RvX2ZpZWxkO1xuZnVuY3Rpb24gaXNvZ2VueU1hcChmaWVsZCwgbWFwKSB7XG4gICAgLy8gTWFrZSBzYW1lIG9yZGVyIGFzIGluIHNwZWNcbiAgICBjb25zdCBDT0VGRiA9IG1hcC5tYXAoKGkpID0+IEFycmF5LmZyb20oaSkucmV2ZXJzZSgpKTtcbiAgICByZXR1cm4gKHgsIHkpID0+IHtcbiAgICAgICAgY29uc3QgW3hOdW0sIHhEZW4sIHlOdW0sIHlEZW5dID0gQ09FRkYubWFwKCh2YWwpID0+IHZhbC5yZWR1Y2UoKGFjYywgaSkgPT4gZmllbGQuYWRkKGZpZWxkLm11bChhY2MsIHgpLCBpKSkpO1xuICAgICAgICB4ID0gZmllbGQuZGl2KHhOdW0sIHhEZW4pOyAvLyB4TnVtIC8geERlblxuICAgICAgICB5ID0gZmllbGQubXVsKHksIGZpZWxkLmRpdih5TnVtLCB5RGVuKSk7IC8vIHkgKiAoeU51bSAvIHlEZXYpXG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9O1xufVxuZXhwb3J0cy5pc29nZW55TWFwID0gaXNvZ2VueU1hcDtcbmZ1bmN0aW9uIGNyZWF0ZUhhc2hlcihQb2ludCwgbWFwVG9DdXJ2ZSwgZGVmKSB7XG4gICAgaWYgKHR5cGVvZiBtYXBUb0N1cnZlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmUoKSBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvLyBFbmNvZGVzIGJ5dGUgc3RyaW5nIHRvIGVsbGlwdGljIGN1cnZlXG4gICAgICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaXJ0Zi1jZnJnLWhhc2gtdG8tY3VydmUtMTYjc2VjdGlvbi0zXG4gICAgICAgIGhhc2hUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAyLCB7IC4uLmRlZiwgRFNUOiBkZWYuRFNULCAuLi5vcHRpb25zIH0pO1xuICAgICAgICAgICAgY29uc3QgdTAgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVswXSkpO1xuICAgICAgICAgICAgY29uc3QgdTEgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVsxXSkpO1xuICAgICAgICAgICAgY29uc3QgUCA9IHUwLmFkZCh1MSkuY2xlYXJDb2ZhY3RvcigpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaXJ0Zi1jZnJnLWhhc2gtdG8tY3VydmUtMTYjc2VjdGlvbi0zXG4gICAgICAgIGVuY29kZVRvQ3VydmUobXNnLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gaGFzaF90b19maWVsZChtc2csIDEsIHsgLi4uZGVmLCBEU1Q6IGRlZi5lbmNvZGVEU1QsIC4uLm9wdGlvbnMgfSk7XG4gICAgICAgICAgICBjb25zdCBQID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHVbMF0pKS5jbGVhckNvZmFjdG9yKCk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0cy5jcmVhdGVIYXNoZXIgPSBjcmVhdGVIYXNoZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoLXRvLWN1cnZlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNyZWF0ZUhhc2hlciIsImlzb2dlbnlNYXAiLCJoYXNoX3RvX2ZpZWxkIiwiZXhwYW5kX21lc3NhZ2VfeG9mIiwiZXhwYW5kX21lc3NhZ2VfeG1kIiwibW9kdWxhcl9qc18xIiwicmVxdWlyZSIsInV0aWxzX2pzXzEiLCJ2YWxpZGF0ZURTVCIsImRzdCIsIlVpbnQ4QXJyYXkiLCJ1dGY4VG9CeXRlcyIsIkVycm9yIiwib3MyaXAiLCJieXRlc1RvTnVtYmVyQkUiLCJpMm9zcCIsImxlbmd0aCIsInJlcyIsIkFycmF5IiwiZnJvbSIsImZpbGwiLCJpIiwic3RyeG9yIiwiYSIsImIiLCJhcnIiLCJpc0J5dGVzIiwiaXRlbSIsImlzTnVtIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsIm1zZyIsIkRTVCIsImxlbkluQnl0ZXMiLCJIIiwiY29uY2F0Qnl0ZXMiLCJvdXRwdXRMZW4iLCJiX2luX2J5dGVzIiwiYmxvY2tMZW4iLCJyX2luX2J5dGVzIiwiZWxsIiwiTWF0aCIsImNlaWwiLCJEU1RfcHJpbWUiLCJaX3BhZCIsImxfaV9iX3N0ciIsImJfMCIsImFyZ3MiLCJwc2V1ZG9fcmFuZG9tX2J5dGVzIiwic2xpY2UiLCJrIiwiZGtMZW4iLCJjcmVhdGUiLCJ1cGRhdGUiLCJkaWdlc3QiLCJjb3VudCIsIm9wdGlvbnMiLCJ2YWxpZGF0ZU9iamVjdCIsInAiLCJtIiwiaGFzaCIsImV4cGFuZCIsIl9EU1QiLCJsb2cycCIsInRvU3RyaW5nIiwiTCIsImxlbl9pbl9ieXRlcyIsInByYiIsInUiLCJlIiwiaiIsImVsbV9vZmZzZXQiLCJ0diIsInN1YmFycmF5IiwibW9kIiwiZmllbGQiLCJtYXAiLCJDT0VGRiIsInJldmVyc2UiLCJ4IiwieSIsInhOdW0iLCJ4RGVuIiwieU51bSIsInlEZW4iLCJ2YWwiLCJyZWR1Y2UiLCJhY2MiLCJhZGQiLCJtdWwiLCJkaXYiLCJQb2ludCIsIm1hcFRvQ3VydmUiLCJkZWYiLCJoYXNoVG9DdXJ2ZSIsInUwIiwiZnJvbUFmZmluZSIsInUxIiwiUCIsImNsZWFyQ29mYWN0b3IiLCJhc3NlcnRWYWxpZGl0eSIsImVuY29kZVRvQ3VydmUiLCJlbmNvZGVEU1QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/curves/abstract/hash-to-curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/curves/abstract/modular.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/ethereum-cryptography/node_modules/@noble/curves/abstract/modular.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.hashToPrivateScalar = exports.FpSqrtEven = exports.FpSqrtOdd = exports.Field = exports.nLength = exports.FpIsSquare = exports.FpDiv = exports.FpInvertBatch = exports.FpPow = exports.validateField = exports.isNegativeLE = exports.FpSqrt = exports.tonelliShanks = exports.invert = exports.pow2 = exports.pow = exports.mod = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Utilities for modular arithmetics and finite fields\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/curves/abstract/utils.js\");\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\nexports.mod = mod;\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */ // TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n) throw new Error(\"Expected power/modulo > 0\");\n    if (modulo === _1n) return _0n;\n    let res = _1n;\n    while(power > _0n){\n        if (power & _1n) res = res * num % modulo;\n        num = num * num % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\nexports.pow = pow;\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while(power-- > _0n){\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\nexports.pow2 = pow2;\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while(a !== _0n){\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n) throw new Error(\"invert: does not exist\");\n    return mod(x, modulo);\n}\nexports.invert = invert;\n// Tonelli-Shanks algorithm\n// Paper 1: https://eprint.iacr.org/2012/685.pdf (page 12)\n// Paper 2: Square Roots from 1; 24, 51, 10 to Dan Shanks\nfunction tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ‚â° 1    if a is a square (mod p)\n    // (a | p) ‚â° -1   if a is not a square (mod p)\n    // (a | p) ‚â° 0    if a ‚â° 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for(Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);\n    // Step 2: Select a non-square z such that (z | p) ‚â° -1 and set c ‚â° zq\n    for(Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++);\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ‚â° -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error(\"Cannot find square root\");\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while(!Fp.eql(b, Fp.ONE)){\n            if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for(let t2 = Fp.sqr(b); m < r; m++){\n                if (Fp.eql(t2, Fp.ONE)) break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nexports.tonelliShanks = tonelliShanks;\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P ‚â° 3 (mod 4)\n    // ‚àön = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // Atkin algorithm for q ‚â° 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // P ‚â° 9 (mod 16)\n    if (P % _16n === _9n) {\n    // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n    // Means we cannot use sqrt for constants at all!\n    //\n    // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    // sqrt = (x) => {\n    //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n    //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n    //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n    //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n    //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n    //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n    //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n    //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n    // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\nexports.FpSqrt = FpSqrt;\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo)=>(mod(num, modulo) & _1n) === _1n;\nexports.isNegativeLE = isNegativeLE;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    \"create\",\n    \"isValid\",\n    \"is0\",\n    \"neg\",\n    \"inv\",\n    \"sqrt\",\n    \"sqr\",\n    \"eql\",\n    \"add\",\n    \"sub\",\n    \"mul\",\n    \"pow\",\n    \"div\",\n    \"addN\",\n    \"subN\",\n    \"mulN\",\n    \"sqrN\"\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: \"bigint\",\n        MASK: \"bigint\",\n        BYTES: \"isSafeInteger\",\n        BITS: \"isSafeInteger\"\n    };\n    const opts = FIELD_FIELDS.reduce((map, val)=>{\n        map[val] = \"function\";\n        return map;\n    }, initial);\n    return (0, utils_js_1.validateObject)(field, opts);\n}\nexports.validateField = validateField;\n// Generic field functions\nfunction FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n) throw new Error(\"Expected power > 0\");\n    if (power === _0n) return f.ONE;\n    if (power === _1n) return num;\n    let p = f.ONE;\n    let d = num;\n    while(power > _0n){\n        if (power & _1n) p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\nexports.FpPow = FpPow;\n// 0 is non-invertible: non-batched version will throw on 0\nfunction FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i)=>{\n        if (f.is0(num)) return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i)=>{\n        if (f.is0(num)) return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nexports.FpInvertBatch = FpInvertBatch;\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === \"bigint\" ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\nexports.FpDiv = FpDiv;\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x)=>{\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\nexports.FpIsSquare = FpIsSquare;\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return {\n        nBitLength: _nBitLength,\n        nByteLength\n    };\n}\nexports.nLength = nLength;\n/**\n * Initializes a galois field over prime. Non-primes are not supported for now.\n * Do not init in loop: slow. Very fragile: always run a benchmark on change.\n * Major performance gains:\n * a) non-normalized operations like mulN instead of mul\n * b) `Object.freeze`\n * c) Same object shape: never add or remove keys\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */ function Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n) throw new Error(`Expected Fp ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048) throw new Error(\"Field lengths over 2048 bytes are not supported\");\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0, utils_js_1.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num)=>mod(num, ORDER),\n        isValid: (num)=>{\n            if (typeof num !== \"bigint\") throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num)=>num === _0n,\n        isOdd: (num)=>(num & _1n) === _1n,\n        neg: (num)=>mod(-num, ORDER),\n        eql: (lhs, rhs)=>lhs === rhs,\n        sqr: (num)=>mod(num * num, ORDER),\n        add: (lhs, rhs)=>mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs)=>mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs)=>mod(lhs * rhs, ORDER),\n        pow: (num, power)=>FpPow(f, num, power),\n        div: (lhs, rhs)=>mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num)=>num * num,\n        addN: (lhs, rhs)=>lhs + rhs,\n        subN: (lhs, rhs)=>lhs - rhs,\n        mulN: (lhs, rhs)=>lhs * rhs,\n        inv: (num)=>invert(num, ORDER),\n        sqrt: redef.sqrt || ((n)=>sqrtP(f, n)),\n        invertBatch: (lst)=>FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c)=>c ? b : a,\n        toBytes: (num)=>isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES),\n        fromBytes: (bytes)=>{\n            if (bytes.length !== BYTES) throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);\n        }\n    });\n    return Object.freeze(f);\n}\nexports.Field = Field;\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nexports.FpSqrtOdd = FpSqrtOdd;\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\nexports.FpSqrtEven = FpSqrtEven;\n/**\n * FIPS 186 B.4.1-compliant \"constant-time\" private key generation utility.\n * Can take (n+8) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 40 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. curveFn.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */ function hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0, utils_js_1.ensureBytes)(\"privateHash\", hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\nexports.hashToPrivateScalar = hashToPrivateScalar; //# sourceMappingURL=modular.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2Fic3RyYWN0L21vZHVsYXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDJCQUEyQixHQUFHQSxrQkFBa0IsR0FBR0EsaUJBQWlCLEdBQUdBLGFBQWEsR0FBR0EsZUFBZSxHQUFHQSxrQkFBa0IsR0FBR0EsYUFBYSxHQUFHQSxxQkFBcUIsR0FBR0EsYUFBYSxHQUFHQSxxQkFBcUIsR0FBR0Esb0JBQW9CLEdBQUdBLGNBQWMsR0FBR0EscUJBQXFCLEdBQUdBLGNBQWMsR0FBR0EsWUFBWSxHQUFHQSxXQUFXLEdBQUdBLFdBQVcsR0FBRyxLQUFLO0FBQy9VLG9FQUFvRSxHQUNwRSxzREFBc0Q7QUFDdEQsTUFBTW1CLGFBQWFDLG1CQUFPQSxDQUFDLDJHQUFZO0FBQ3ZDLGtCQUFrQjtBQUNsQixNQUFNQyxNQUFNQyxPQUFPLElBQUlDLE1BQU1ELE9BQU8sSUFBSUUsTUFBTUYsT0FBTyxJQUFJRyxNQUFNSCxPQUFPO0FBQ3RFLGtCQUFrQjtBQUNsQixNQUFNSSxNQUFNSixPQUFPLElBQUlLLE1BQU1MLE9BQU8sSUFBSU0sTUFBTU4sT0FBTztBQUNyRCxrQkFBa0I7QUFDbEIsTUFBTU8sTUFBTVAsT0FBTyxJQUFJUSxPQUFPUixPQUFPO0FBQ3JDLHdCQUF3QjtBQUN4QixTQUFTSixJQUFJYSxDQUFDLEVBQUVDLENBQUM7SUFDYixNQUFNQyxTQUFTRixJQUFJQztJQUNuQixPQUFPQyxVQUFVWixNQUFNWSxTQUFTRCxJQUFJQztBQUN4QztBQUNBakMsV0FBVyxHQUFHa0I7QUFDZDs7Ozs7Q0FLQyxHQUNELG9DQUFvQztBQUNwQyxTQUFTRCxJQUFJaUIsR0FBRyxFQUFFQyxLQUFLLEVBQUVDLE1BQU07SUFDM0IsSUFBSUEsVUFBVWYsT0FBT2MsUUFBUWQsS0FDekIsTUFBTSxJ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bm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvbW9kdWxhci5qcz81Yjg1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5oYXNoVG9Qcml2YXRlU2NhbGFyID0gZXhwb3J0cy5GcFNxcnRFdmVuID0gZXhwb3J0cy5GcFNxcnRPZGQgPSBleHBvcnRzLkZpZWxkID0gZXhwb3J0cy5uTGVuZ3RoID0gZXhwb3J0cy5GcElzU3F1YXJlID0gZXhwb3J0cy5GcERpdiA9IGV4cG9ydHMuRnBJbnZlcnRCYXRjaCA9IGV4cG9ydHMuRnBQb3cgPSBleHBvcnRzLnZhbGlkYXRlRmllbGQgPSBleHBvcnRzLmlzTmVnYXRpdmVMRSA9IGV4cG9ydHMuRnBTcXJ0ID0gZXhwb3J0cy50b25lbGxpU2hhbmtzID0gZXhwb3J0cy5pbnZlcnQgPSBleHBvcnRzLnBvdzIgPSBleHBvcnRzLnBvdyA9IGV4cG9ydHMubW9kID0gdm9pZCAwO1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gVXRpbGl0aWVzIGZvciBtb2R1bGFyIGFyaXRobWV0aWNzIGFuZCBmaW5pdGUgZmllbGRzXG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzRuID0gQmlnSW50KDQpLCBfNW4gPSBCaWdJbnQoNSksIF84biA9IEJpZ0ludCg4KTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzluID0gQmlnSW50KDkpLCBfMTZuID0gQmlnSW50KDE2KTtcbi8vIENhbGN1bGF0ZXMgYSBtb2R1bG8gYlxuZnVuY3Rpb24gbW9kKGEsIGIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhICUgYjtcbiAgICByZXR1cm4gcmVzdWx0ID49IF8wbiA/IHJlc3VsdCA6IGIgKyByZXN1bHQ7XG59XG5leHBvcnRzLm1vZCA9IG1vZDtcbi8qKlxuICogRWZmaWNpZW50bHkgcmFpc2UgbnVtIHRvIHBvd2VyIGFuZCBkbyBtb2R1bGFyIGRpdmlzaW9uLlxuICogVW5zYWZlIGluIHNvbWUgY29udGV4dHM6IHVzZXMgbGFkZGVyLCBzbyBjYW4gZXhwb3NlIGJpZ2ludCBiaXRzLlxuICogQGV4YW1wbGVcbiAqIHBvdygybiwgNm4sIDExbikgLy8gNjRuICUgMTFuID09IDluXG4gKi9cbi8vIFRPRE86IHVzZSBmaWVsZCB2ZXJzaW9uICYmIHJlbW92ZVxuZnVuY3Rpb24gcG93KG51bSwgcG93ZXIsIG1vZHVsbykge1xuICAgIGlmIChtb2R1bG8gPD0gXzBuIHx8IHBvd2VyIDwgXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBvd2VyL21vZHVsbyA+IDAnKTtcbiAgICBpZiAobW9kdWxvID09PSBfMW4pXG4gICAgICAgIHJldHVybiBfMG47XG4gICAgbGV0IHJlcyA9IF8xbjtcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxuICAgICAgICAgICAgcmVzID0gKHJlcyAqIG51bSkgJSBtb2R1bG87XG4gICAgICAgIG51bSA9IChudW0gKiBudW0pICUgbW9kdWxvO1xuICAgICAgICBwb3dlciA+Pj0gXzFuO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy5wb3cgPSBwb3c7XG4vLyBEb2VzIHggXiAoMiBeIHBvd2VyKSBtb2QgcC4gcG93MigzMCwgNCkgPT0gMzAgXiAoMiBeIDQpXG5mdW5jdGlvbiBwb3cyKHgsIHBvd2VyLCBtb2R1bG8pIHtcbiAgICBsZXQgcmVzID0geDtcbiAgICB3aGlsZSAocG93ZXItLSA+IF8wbikge1xuICAgICAgICByZXMgKj0gcmVzO1xuICAgICAgICByZXMgJT0gbW9kdWxvO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy5wb3cyID0gcG93Mjtcbi8vIEludmVyc2VzIG51bWJlciBvdmVyIG1vZHVsb1xuZnVuY3Rpb24gaW52ZXJ0KG51bWJlciwgbW9kdWxvKSB7XG4gICAgaWYgKG51bWJlciA9PT0gXzBuIHx8IG1vZHVsbyA8PSBfMG4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZlcnQ6IGV4cGVjdGVkIHBvc2l0aXZlIGludGVnZXJzLCBnb3Qgbj0ke251bWJlcn0gbW9kPSR7bW9kdWxvfWApO1xuICAgIH1cbiAgICAvLyBFdWNsaWRlYW4gR0NEIGh0dHBzOi8vYnJpbGxpYW50Lm9yZy93aWtpL2V4dGVuZGVkLWV1Y2xpZGVhbi1hbGdvcml0aG0vXG4gICAgLy8gRmVybWF0J3MgbGl0dGxlIHRoZW9yZW0gXCJDVC1saWtlXCIgdmVyc2lvbiBpbnYobikgPSBuXihtLTIpIG1vZCBtIGlzIDMweCBzbG93ZXIuXG4gICAgbGV0IGEgPSBtb2QobnVtYmVyLCBtb2R1bG8pO1xuICAgIGxldCBiID0gbW9kdWxvO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCB4ID0gXzBuLCB5ID0gXzFuLCB1ID0gXzFuLCB2ID0gXzBuO1xuICAgIHdoaWxlIChhICE9PSBfMG4pIHtcbiAgICAgICAgLy8gSklUIGFwcGxpZXMgb3B0aW1pemF0aW9uIGlmIHRob3NlIHR3byBsaW5lcyBmb2xsb3cgZWFjaCBvdGhlclxuICAgICAgICBjb25zdCBxID0gYiAvIGE7XG4gICAgICAgIGNvbnN0IHIgPSBiICUgYTtcbiAgICAgICAgY29uc3QgbSA9IHggLSB1ICogcTtcbiAgICAgICAgY29uc3QgbiA9IHkgLSB2ICogcTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGIgPSBhLCBhID0gciwgeCA9IHUsIHkgPSB2LCB1ID0gbSwgdiA9IG47XG4gICAgfVxuICAgIGNvbnN0IGdjZCA9IGI7XG4gICAgaWYgKGdjZCAhPT0gXzFuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZG9lcyBub3QgZXhpc3QnKTtcbiAgICByZXR1cm4gbW9kKHgsIG1vZHVsbyk7XG59XG5leHBvcnRzLmludmVydCA9IGludmVydDtcbi8vIFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobVxuLy8gUGFwZXIgMTogaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmIChwYWdlIDEyKVxuLy8gUGFwZXIgMjogU3F1YXJlIFJvb3RzIGZyb20gMTsgMjQsIDUxLCAxMCB0byBEYW4gU2hhbmtzXG5mdW5jdGlvbiB0b25lbGxpU2hhbmtzKFApIHtcbiAgICAvLyBMZWdlbmRyZSBjb25zdGFudDogdXNlZCB0byBjYWxjdWxhdGUgTGVnZW5kcmUgc3ltYm9sIChhIHwgcCksXG4gICAgLy8gd2hpY2ggZGVub3RlcyB0aGUgdmFsdWUgb2YgYV4oKHAtMSkvMikgKG1vZCBwKS5cbiAgICAvLyAoYSB8IHApIOKJoSAxICAgIGlmIGEgaXMgYSBzcXVhcmUgKG1vZCBwKVxuICAgIC8vIChhIHwgcCkg4omhIC0xICAgaWYgYSBpcyBub3QgYSBzcXVhcmUgKG1vZCBwKVxuICAgIC8vIChhIHwgcCkg4omhIDAgICAgaWYgYSDiiaEgMCAobW9kIHApXG4gICAgY29uc3QgbGVnZW5kcmVDID0gKFAgLSBfMW4pIC8gXzJuO1xuICAgIGxldCBRLCBTLCBaO1xuICAgIC8vIFN0ZXAgMTogQnkgZmFjdG9yaW5nIG91dCBwb3dlcnMgb2YgMiBmcm9tIHAgLSAxLFxuICAgIC8vIGZpbmQgcSBhbmQgcyBzdWNoIHRoYXQgcCAtIDEgPSBxKigyXnMpIHdpdGggcSBvZGRcbiAgICBmb3IgKFEgPSBQIC0gXzFuLCBTID0gMDsgUSAlIF8ybiA9PT0gXzBuOyBRIC89IF8ybiwgUysrKVxuICAgICAgICA7XG4gICAgLy8gU3RlcCAyOiBTZWxlY3QgYSBub24tc3F1YXJlIHogc3VjaCB0aGF0ICh6IHwgcCkg4omhIC0xIGFuZCBzZXQgYyDiiaEgenFcbiAgICBmb3IgKFogPSBfMm47IFogPCBQICYmIHBvdyhaLCBsZWdlbmRyZUMsIFApICE9PSBQIC0gXzFuOyBaKyspXG4gICAgICAgIDtcbiAgICAvLyBGYXN0LXBhdGhcbiAgICBpZiAoUyA9PT0gMSkge1xuICAgICAgICBjb25zdCBwMWRpdjQgPSAoUCArIF8xbikgLyBfNG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiB0b25lbGxpRmFzdChGcCwgbikge1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLnBvdyhuLCBwMWRpdjQpO1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gU2xvdy1wYXRoXG4gICAgY29uc3QgUTFkaXYyID0gKFEgKyBfMW4pIC8gXzJuO1xuICAgIHJldHVybiBmdW5jdGlvbiB0b25lbGxpU2xvdyhGcCwgbikge1xuICAgICAgICAvLyBTdGVwIDA6IENoZWNrIHRoYXQgbiBpcyBpbmRlZWQgYSBzcXVhcmU6IChuIHwgcCkgc2hvdWxkIG5vdCBiZSDiiaEgLTFcbiAgICAgICAgaWYgKEZwLnBvdyhuLCBsZWdlbmRyZUMpID09PSBGcC5uZWcoRnAuT05FKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgbGV0IHIgPSBTO1xuICAgICAgICAvLyBUT0RPOiB3aWxsIGZhaWwgYXQgRnAyL2V0Y1xuICAgICAgICBsZXQgZyA9IEZwLnBvdyhGcC5tdWwoRnAuT05FLCBaKSwgUSk7IC8vIHdpbGwgdXBkYXRlIGJvdGggeCBhbmQgYlxuICAgICAgICBsZXQgeCA9IEZwLnBvdyhuLCBRMWRpdjIpOyAvLyBmaXJzdCBndWVzcyBhdCB0aGUgc3F1YXJlIHJvb3RcbiAgICAgICAgbGV0IGIgPSBGcC5wb3cobiwgUSk7IC8vIGZpcnN0IGd1ZXNzIGF0IHRoZSBmdWRnZSBmYWN0b3JcbiAgICAgICAgd2hpbGUgKCFGcC5lcWwoYiwgRnAuT05FKSkge1xuICAgICAgICAgICAgaWYgKEZwLmVxbChiLCBGcC5aRVJPKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gRnAuWkVSTzsgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVG9uZWxsaSVFMiU4MCU5M1NoYW5rc19hbGdvcml0aG0gKDQuIElmIHQgPSAwLCByZXR1cm4gciA9IDApXG4gICAgICAgICAgICAvLyBGaW5kIG0gc3VjaCBiXigyXm0pPT0xXG4gICAgICAgICAgICBsZXQgbSA9IDE7XG4gICAgICAgICAgICBmb3IgKGxldCB0MiA9IEZwLnNxcihiKTsgbSA8IHI7IG0rKykge1xuICAgICAgICAgICAgICAgIGlmIChGcC5lcWwodDIsIEZwLk9ORSkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHQyID0gRnAuc3FyKHQyKTsgLy8gdDIgKj0gdDJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5PVEU6IHItbS0xIGNhbiBiZSBiaWdnZXIgdGhhbiAzMiwgbmVlZCB0byBjb252ZXJ0IHRvIGJpZ2ludCBiZWZvcmUgc2hpZnQsIG90aGVyd2lzZSB0aGVyZSB3aWxsIGJlIG92ZXJmbG93XG4gICAgICAgICAgICBjb25zdCBnZSA9IEZwLnBvdyhnLCBfMW4gPDwgQmlnSW50KHIgLSBtIC0gMSkpOyAvLyBnZSA9IDJeKHItbS0xKVxuICAgICAgICAgICAgZyA9IEZwLnNxcihnZSk7IC8vIGcgPSBnZSAqIGdlXG4gICAgICAgICAgICB4ID0gRnAubXVsKHgsIGdlKTsgLy8geCAqPSBnZVxuICAgICAgICAgICAgYiA9IEZwLm11bChiLCBnKTsgLy8gYiAqPSBnXG4gICAgICAgICAgICByID0gbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICB9O1xufVxuZXhwb3J0cy50b25lbGxpU2hhbmtzID0gdG9uZWxsaVNoYW5rcztcbmZ1bmN0aW9uIEZwU3FydChQKSB7XG4gICAgLy8gTk9URTogZGlmZmVyZW50IGFsZ29yaXRobXMgY2FuIGdpdmUgZGlmZmVyZW50IHJvb3RzLCBpdCBpcyB1cCB0byB1c2VyIHRvIGRlY2lkZSB3aGljaCBvbmUgdGhleSB3YW50LlxuICAgIC8vIEZvciBleGFtcGxlIHRoZXJlIGlzIEZwU3FydE9kZC9GcFNxcnRFdmVuIHRvIGNob2ljZSByb290IGJhc2VkIG9uIG9kZG5lc3MgKHVzZWQgZm9yIGhhc2gtdG8tY3VydmUpLlxuICAgIC8vIFAg4omhIDMgKG1vZCA0KVxuICAgIC8vIOKImm4gPSBuXigoUCsxKS80KVxuICAgIGlmIChQICUgXzRuID09PSBfM24pIHtcbiAgICAgICAgLy8gTm90IGFsbCByb290cyBwb3NzaWJsZSFcbiAgICAgICAgLy8gY29uc3QgT1JERVIgPVxuICAgICAgICAvLyAgIDB4MWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYWFibjtcbiAgICAgICAgLy8gY29uc3QgTlVNID0gNzIwNTc1OTQwMzc5Mjc4MTZuO1xuICAgICAgICBjb25zdCBwMWRpdjQgPSAoUCArIF8xbikgLyBfNG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzcXJ0M21vZDQoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5wb3cobiwgcDFkaXY0KTtcbiAgICAgICAgICAgIC8vIFRocm93IGlmIHJvb3QqKjIgIT0gblxuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQXRraW4gYWxnb3JpdGhtIGZvciBxIOKJoSA1IChtb2QgOCksIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMClcbiAgICBpZiAoUCAlIF84biA9PT0gXzVuKSB7XG4gICAgICAgIGNvbnN0IGMxID0gKFAgLSBfNW4pIC8gXzhuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3FydDVtb2Q4KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCBuMiA9IEZwLm11bChuLCBfMm4pO1xuICAgICAgICAgICAgY29uc3QgdiA9IEZwLnBvdyhuMiwgYzEpO1xuICAgICAgICAgICAgY29uc3QgbnYgPSBGcC5tdWwobiwgdik7XG4gICAgICAgICAgICBjb25zdCBpID0gRnAubXVsKEZwLm11bChudiwgXzJuKSwgdik7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAubXVsKG52LCBGcC5zdWIoaSwgRnAuT05FKSk7XG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBQIOKJoSA5IChtb2QgMTYpXG4gICAgaWYgKFAgJSBfMTZuID09PSBfOW4pIHtcbiAgICAgICAgLy8gTk9URTogdG9uZWxsaSBpcyB0b28gc2xvdyBmb3IgYmxzLUZwMiBjYWxjdWxhdGlvbnMgZXZlbiBvbiBzdGFydFxuICAgICAgICAvLyBNZWFucyB3ZSBjYW5ub3QgdXNlIHNxcnQgZm9yIGNvbnN0YW50cyBhdCBhbGwhXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGNvbnN0IGMxID0gRnAuc3FydChGcC5uZWdhdGUoRnAuT05FKSk7IC8vICAxLiBjMSA9IHNxcnQoLTEpIGluIEYsIGkuZS4sIChjMV4yKSA9PSAtMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGMyID0gRnAuc3FydChjMSk7ICAgICAgICAgICAgICAgIC8vICAyLiBjMiA9IHNxcnQoYzEpIGluIEYsIGkuZS4sIChjMl4yKSA9PSBjMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGMzID0gRnAuc3FydChGcC5uZWdhdGUoYzEpKTsgICAgIC8vICAzLiBjMyA9IHNxcnQoLWMxKSBpbiBGLCBpLmUuLCAoYzNeMikgPT0gLWMxIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzQgPSAoUCArIF83bikgLyBfMTZuOyAgICAgICAgICAgLy8gIDQuIGM0ID0gKHEgKyA3KSAvIDE2ICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICAvLyBzcXJ0ID0gKHgpID0+IHtcbiAgICAgICAgLy8gICBsZXQgdHYxID0gRnAucG93KHgsIGM0KTsgICAgICAgICAgICAgLy8gIDEuIHR2MSA9IHheYzRcbiAgICAgICAgLy8gICBsZXQgdHYyID0gRnAubXVsKGMxLCB0djEpOyAgICAgICAgICAgLy8gIDIuIHR2MiA9IGMxICogdHYxXG4gICAgICAgIC8vICAgY29uc3QgdHYzID0gRnAubXVsKGMyLCB0djEpOyAgICAgICAgIC8vICAzLiB0djMgPSBjMiAqIHR2MVxuICAgICAgICAvLyAgIGxldCB0djQgPSBGcC5tdWwoYzMsIHR2MSk7ICAgICAgICAgICAvLyAgNC4gdHY0ID0gYzMgKiB0djFcbiAgICAgICAgLy8gICBjb25zdCBlMSA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYyKSwgeCk7IC8vICA1LiAgZTEgPSAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICBjb25zdCBlMiA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYzKSwgeCk7IC8vICA2LiAgZTIgPSAodHYzXjIpID09IHhcbiAgICAgICAgLy8gICB0djEgPSBGcC5jbW92KHR2MSwgdHYyLCBlMSk7IC8vICA3LiB0djEgPSBDTU9WKHR2MSwgdHYyLCBlMSkgICMgU2VsZWN0IHR2MiBpZiAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICB0djIgPSBGcC5jbW92KHR2NCwgdHYzLCBlMik7IC8vICA4LiB0djIgPSBDTU9WKHR2NCwgdHYzLCBlMikgICMgU2VsZWN0IHR2MyBpZiAodHYzXjIpID09IHhcbiAgICAgICAgLy8gICBjb25zdCBlMyA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYyKSwgeCk7IC8vICA5LiAgZTMgPSAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICByZXR1cm4gRnAuY21vdih0djEsIHR2MiwgZTMpOyAvLyAgMTAuICB6ID0gQ01PVih0djEsIHR2MiwgZTMpICAjIFNlbGVjdCB0aGUgc3FydCBmcm9tIHR2MSBhbmQgdHYyXG4gICAgICAgIC8vIH1cbiAgICB9XG4gICAgLy8gT3RoZXIgY2FzZXM6IFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobVxuICAgIHJldHVybiB0b25lbGxpU2hhbmtzKFApO1xufVxuZXhwb3J0cy5GcFNxcnQgPSBGcFNxcnQ7XG4vLyBMaXR0bGUtZW5kaWFuIGNoZWNrIGZvciBmaXJzdCBMRSBiaXQgKGxhc3QgQkUgYml0KTtcbmNvbnN0IGlzTmVnYXRpdmVMRSA9IChudW0sIG1vZHVsbykgPT4gKG1vZChudW0sIG1vZHVsbykgJiBfMW4pID09PSBfMW47XG5leHBvcnRzLmlzTmVnYXRpdmVMRSA9IGlzTmVnYXRpdmVMRTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgRklFTERfRklFTERTID0gW1xuICAgICdjcmVhdGUnLCAnaXNWYWxpZCcsICdpczAnLCAnbmVnJywgJ2ludicsICdzcXJ0JywgJ3NxcicsXG4gICAgJ2VxbCcsICdhZGQnLCAnc3ViJywgJ211bCcsICdwb3cnLCAnZGl2JyxcbiAgICAnYWRkTicsICdzdWJOJywgJ211bE4nLCAnc3FyTidcbl07XG5mdW5jdGlvbiB2YWxpZGF0ZUZpZWxkKGZpZWxkKSB7XG4gICAgY29uc3QgaW5pdGlhbCA9IHtcbiAgICAgICAgT1JERVI6ICdiaWdpbnQnLFxuICAgICAgICBNQVNLOiAnYmlnaW50JyxcbiAgICAgICAgQllURVM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgQklUUzogJ2lzU2FmZUludGVnZXInLFxuICAgIH07XG4gICAgY29uc3Qgb3B0cyA9IEZJRUxEX0ZJRUxEUy5yZWR1Y2UoKG1hcCwgdmFsKSA9PiB7XG4gICAgICAgIG1hcFt2YWxdID0gJ2Z1bmN0aW9uJztcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LCBpbml0aWFsKTtcbiAgICByZXR1cm4gKDAsIHV0aWxzX2pzXzEudmFsaWRhdGVPYmplY3QpKGZpZWxkLCBvcHRzKTtcbn1cbmV4cG9ydHMudmFsaWRhdGVGaWVsZCA9IHZhbGlkYXRlRmllbGQ7XG4vLyBHZW5lcmljIGZpZWxkIGZ1bmN0aW9uc1xuZnVuY3Rpb24gRnBQb3coZiwgbnVtLCBwb3dlcikge1xuICAgIC8vIFNob3VsZCBoYXZlIHNhbWUgc3BlZWQgYXMgcG93IGZvciBiaWdpbnRzXG4gICAgLy8gVE9ETzogYmVuY2htYXJrIVxuICAgIGlmIChwb3dlciA8IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwb3dlciA+IDAnKTtcbiAgICBpZiAocG93ZXIgPT09IF8wbilcbiAgICAgICAgcmV0dXJuIGYuT05FO1xuICAgIGlmIChwb3dlciA9PT0gXzFuKVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIGxldCBwID0gZi5PTkU7XG4gICAgbGV0IGQgPSBudW07XG4gICAgd2hpbGUgKHBvd2VyID4gXzBuKSB7XG4gICAgICAgIGlmIChwb3dlciAmIF8xbilcbiAgICAgICAgICAgIHAgPSBmLm11bChwLCBkKTtcbiAgICAgICAgZCA9IGYuc3FyKGQpO1xuICAgICAgICBwb3dlciA+Pj0gXzFuO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbn1cbmV4cG9ydHMuRnBQb3cgPSBGcFBvdztcbi8vIDAgaXMgbm9uLWludmVydGlibGU6IG5vbi1iYXRjaGVkIHZlcnNpb24gd2lsbCB0aHJvdyBvbiAwXG5mdW5jdGlvbiBGcEludmVydEJhdGNoKGYsIG51bXMpIHtcbiAgICBjb25zdCB0bXAgPSBuZXcgQXJyYXkobnVtcy5sZW5ndGgpO1xuICAgIC8vIFdhbGsgZnJvbSBmaXJzdCB0byBsYXN0LCBtdWx0aXBseSB0aGVtIGJ5IGVhY2ggb3RoZXIgTU9EIHBcbiAgICBjb25zdCBsYXN0TXVsdGlwbGllZCA9IG51bXMucmVkdWNlKChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAoZi5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHRtcFtpXSA9IGFjYztcbiAgICAgICAgcmV0dXJuIGYubXVsKGFjYywgbnVtKTtcbiAgICB9LCBmLk9ORSk7XG4gICAgLy8gSW52ZXJ0IGxhc3QgZWxlbWVudFxuICAgIGNvbnN0IGludmVydGVkID0gZi5pbnYobGFzdE11bHRpcGxpZWQpO1xuICAgIC8vIFdhbGsgZnJvbSBsYXN0IHRvIGZpcnN0LCBtdWx0aXBseSB0aGVtIGJ5IGludmVydGVkIGVhY2ggb3RoZXIgTU9EIHBcbiAgICBudW1zLnJlZHVjZVJpZ2h0KChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAoZi5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHRtcFtpXSA9IGYubXVsKGFjYywgdG1wW2ldKTtcbiAgICAgICAgcmV0dXJuIGYubXVsKGFjYywgbnVtKTtcbiAgICB9LCBpbnZlcnRlZCk7XG4gICAgcmV0dXJuIHRtcDtcbn1cbmV4cG9ydHMuRnBJbnZlcnRCYXRjaCA9IEZwSW52ZXJ0QmF0Y2g7XG5mdW5jdGlvbiBGcERpdihmLCBsaHMsIHJocykge1xuICAgIHJldHVybiBmLm11bChsaHMsIHR5cGVvZiByaHMgPT09ICdiaWdpbnQnID8gaW52ZXJ0KHJocywgZi5PUkRFUikgOiBmLmludihyaHMpKTtcbn1cbmV4cG9ydHMuRnBEaXYgPSBGcERpdjtcbi8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBUcnVlIHdoZW5ldmVyIHRoZSB2YWx1ZSB4IGlzIGEgc3F1YXJlIGluIHRoZSBmaWVsZCBGLlxuZnVuY3Rpb24gRnBJc1NxdWFyZShmKSB7XG4gICAgY29uc3QgbGVnZW5kcmVDb25zdCA9IChmLk9SREVSIC0gXzFuKSAvIF8ybjsgLy8gSW50ZWdlciBhcml0aG1ldGljXG4gICAgcmV0dXJuICh4KSA9PiB7XG4gICAgICAgIGNvbnN0IHAgPSBmLnBvdyh4LCBsZWdlbmRyZUNvbnN0KTtcbiAgICAgICAgcmV0dXJuIGYuZXFsKHAsIGYuWkVSTykgfHwgZi5lcWwocCwgZi5PTkUpO1xuICAgIH07XG59XG5leHBvcnRzLkZwSXNTcXVhcmUgPSBGcElzU3F1YXJlO1xuLy8gQ1VSVkUubiBsZW5ndGhzXG5mdW5jdGlvbiBuTGVuZ3RoKG4sIG5CaXRMZW5ndGgpIHtcbiAgICAvLyBCaXQgc2l6ZSwgYnl0ZSBzaXplIG9mIENVUlZFLm5cbiAgICBjb25zdCBfbkJpdExlbmd0aCA9IG5CaXRMZW5ndGggIT09IHVuZGVmaW5lZCA/IG5CaXRMZW5ndGggOiBuLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBuQnl0ZUxlbmd0aCA9IE1hdGguY2VpbChfbkJpdExlbmd0aCAvIDgpO1xuICAgIHJldHVybiB7IG5CaXRMZW5ndGg6IF9uQml0TGVuZ3RoLCBuQnl0ZUxlbmd0aCB9O1xufVxuZXhwb3J0cy5uTGVuZ3RoID0gbkxlbmd0aDtcbi8qKlxuICogSW5pdGlhbGl6ZXMgYSBnYWxvaXMgZmllbGQgb3ZlciBwcmltZS4gTm9uLXByaW1lcyBhcmUgbm90IHN1cHBvcnRlZCBmb3Igbm93LlxuICogRG8gbm90IGluaXQgaW4gbG9vcDogc2xvdy4gVmVyeSBmcmFnaWxlOiBhbHdheXMgcnVuIGEgYmVuY2htYXJrIG9uIGNoYW5nZS5cbiAqIE1ham9yIHBlcmZvcm1hbmNlIGdhaW5zOlxuICogYSkgbm9uLW5vcm1hbGl6ZWQgb3BlcmF0aW9ucyBsaWtlIG11bE4gaW5zdGVhZCBvZiBtdWxcbiAqIGIpIGBPYmplY3QuZnJlZXplYFxuICogYykgU2FtZSBvYmplY3Qgc2hhcGU6IG5ldmVyIGFkZCBvciByZW1vdmUga2V5c1xuICogQHBhcmFtIE9SREVSIHByaW1lIHBvc2l0aXZlIGJpZ2ludFxuICogQHBhcmFtIGJpdExlbiBob3cgbWFueSBiaXRzIHRoZSBmaWVsZCBjb25zdW1lc1xuICogQHBhcmFtIGlzTEUgKGRlZjogZmFsc2UpIGlmIGVuY29kaW5nIC8gZGVjb2Rpbmcgc2hvdWxkIGJlIGluIGxpdHRsZS1lbmRpYW5cbiAqIEBwYXJhbSByZWRlZiBvcHRpb25hbCBmYXN0ZXIgcmVkZWZpbml0aW9ucyBvZiBzcXJ0IGFuZCBvdGhlciBtZXRob2RzXG4gKi9cbmZ1bmN0aW9uIEZpZWxkKE9SREVSLCBiaXRMZW4sIGlzTEUgPSBmYWxzZSwgcmVkZWYgPSB7fSkge1xuICAgIGlmIChPUkRFUiA8PSBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgRnAgT1JERVIgPiAwLCBnb3QgJHtPUkRFUn1gKTtcbiAgICBjb25zdCB7IG5CaXRMZW5ndGg6IEJJVFMsIG5CeXRlTGVuZ3RoOiBCWVRFUyB9ID0gbkxlbmd0aChPUkRFUiwgYml0TGVuKTtcbiAgICBpZiAoQllURVMgPiAyMDQ4KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpZWxkIGxlbmd0aHMgb3ZlciAyMDQ4IGJ5dGVzIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgY29uc3Qgc3FydFAgPSBGcFNxcnQoT1JERVIpO1xuICAgIGNvbnN0IGYgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgT1JERVIsXG4gICAgICAgIEJJVFMsXG4gICAgICAgIEJZVEVTLFxuICAgICAgICBNQVNLOiAoMCwgdXRpbHNfanNfMS5iaXRNYXNrKShCSVRTKSxcbiAgICAgICAgWkVSTzogXzBuLFxuICAgICAgICBPTkU6IF8xbixcbiAgICAgICAgY3JlYXRlOiAobnVtKSA9PiBtb2QobnVtLCBPUkRFUiksXG4gICAgICAgIGlzVmFsaWQ6IChudW0pID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZmllbGQgZWxlbWVudDogZXhwZWN0ZWQgYmlnaW50LCBnb3QgJHt0eXBlb2YgbnVtfWApO1xuICAgICAgICAgICAgcmV0dXJuIF8wbiA8PSBudW0gJiYgbnVtIDwgT1JERVI7IC8vIDAgaXMgdmFsaWQgZWxlbWVudCwgYnV0IGl0J3Mgbm90IGludmVydGlibGVcbiAgICAgICAgfSxcbiAgICAgICAgaXMwOiAobnVtKSA9PiBudW0gPT09IF8wbixcbiAgICAgICAgaXNPZGQ6IChudW0pID0+IChudW0gJiBfMW4pID09PSBfMW4sXG4gICAgICAgIG5lZzogKG51bSkgPT4gbW9kKC1udW0sIE9SREVSKSxcbiAgICAgICAgZXFsOiAobGhzLCByaHMpID0+IGxocyA9PT0gcmhzLFxuICAgICAgICBzcXI6IChudW0pID0+IG1vZChudW0gKiBudW0sIE9SREVSKSxcbiAgICAgICAgYWRkOiAobGhzLCByaHMpID0+IG1vZChsaHMgKyByaHMsIE9SREVSKSxcbiAgICAgICAgc3ViOiAobGhzLCByaHMpID0+IG1vZChsaHMgLSByaHMsIE9SREVSKSxcbiAgICAgICAgbXVsOiAobGhzLCByaHMpID0+IG1vZChsaHMgKiByaHMsIE9SREVSKSxcbiAgICAgICAgcG93OiAobnVtLCBwb3dlcikgPT4gRnBQb3coZiwgbnVtLCBwb3dlciksXG4gICAgICAgIGRpdjogKGxocywgcmhzKSA9PiBtb2QobGhzICogaW52ZXJ0KHJocywgT1JERVIpLCBPUkRFUiksXG4gICAgICAgIC8vIFNhbWUgYXMgYWJvdmUsIGJ1dCBkb2Vzbid0IG5vcm1hbGl6ZVxuICAgICAgICBzcXJOOiAobnVtKSA9PiBudW0gKiBudW0sXG4gICAgICAgIGFkZE46IChsaHMsIHJocykgPT4gbGhzICsgcmhzLFxuICAgICAgICBzdWJOOiAobGhzLCByaHMpID0+IGxocyAtIHJocyxcbiAgICAgICAgbXVsTjogKGxocywgcmhzKSA9PiBsaHMgKiByaHMsXG4gICAgICAgIGludjogKG51bSkgPT4gaW52ZXJ0KG51bSwgT1JERVIpLFxuICAgICAgICBzcXJ0OiByZWRlZi5zcXJ0IHx8ICgobikgPT4gc3FydFAoZiwgbikpLFxuICAgICAgICBpbnZlcnRCYXRjaDogKGxzdCkgPT4gRnBJbnZlcnRCYXRjaChmLCBsc3QpLFxuICAgICAgICAvLyBUT0RPOiBkbyB3ZSByZWFsbHkgbmVlZCBjb25zdGFudCBjbW92P1xuICAgICAgICAvLyBXZSBkb24ndCBoYXZlIGNvbnN0LXRpbWUgYmlnaW50cyBhbnl3YXksIHNvIHByb2JhYmx5IHdpbGwgYmUgbm90IHZlcnkgdXNlZnVsXG4gICAgICAgIGNtb3Y6IChhLCBiLCBjKSA9PiAoYyA/IGIgOiBhKSxcbiAgICAgICAgdG9CeXRlczogKG51bSkgPT4gKGlzTEUgPyAoMCwgdXRpbHNfanNfMS5udW1iZXJUb0J5dGVzTEUpKG51bSwgQllURVMpIDogKDAsIHV0aWxzX2pzXzEubnVtYmVyVG9CeXRlc0JFKShudW0sIEJZVEVTKSksXG4gICAgICAgIGZyb21CeXRlczogKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSBCWVRFUylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZwLmZyb21CeXRlczogZXhwZWN0ZWQgJHtCWVRFU30sIGdvdCAke2J5dGVzLmxlbmd0aH1gKTtcbiAgICAgICAgICAgIHJldHVybiBpc0xFID8gKDAsIHV0aWxzX2pzXzEuYnl0ZXNUb051bWJlckxFKShieXRlcykgOiAoMCwgdXRpbHNfanNfMS5ieXRlc1RvTnVtYmVyQkUpKGJ5dGVzKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShmKTtcbn1cbmV4cG9ydHMuRmllbGQgPSBGaWVsZDtcbmZ1bmN0aW9uIEZwU3FydE9kZChGcCwgZWxtKSB7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGaWVsZCBkb2Vzbid0IGhhdmUgaXNPZGRgKTtcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IHJvb3QgOiBGcC5uZWcocm9vdCk7XG59XG5leHBvcnRzLkZwU3FydE9kZCA9IEZwU3FydE9kZDtcbmZ1bmN0aW9uIEZwU3FydEV2ZW4oRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkYCk7XG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyBGcC5uZWcocm9vdCkgOiByb290O1xufVxuZXhwb3J0cy5GcFNxcnRFdmVuID0gRnBTcXJ0RXZlbjtcbi8qKlxuICogRklQUyAxODYgQi40LjEtY29tcGxpYW50IFwiY29uc3RhbnQtdGltZVwiIHByaXZhdGUga2V5IGdlbmVyYXRpb24gdXRpbGl0eS5cbiAqIENhbiB0YWtlIChuKzgpIG9yIG1vcmUgYnl0ZXMgb2YgdW5pZm9ybSBpbnB1dCBlLmcuIGZyb20gQ1NQUk5HIG9yIEtERlxuICogYW5kIGNvbnZlcnQgdGhlbSBpbnRvIHByaXZhdGUgc2NhbGFyLCB3aXRoIHRoZSBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICogTmVlZHMgYXQgbGVhc3QgNDAgYnl0ZXMgb2YgaW5wdXQgZm9yIDMyLWJ5dGUgcHJpdmF0ZSBrZXkuXG4gKiBodHRwczovL3Jlc2VhcmNoLmt1ZGVsc2tpc2VjdXJpdHkuY29tLzIwMjAvMDcvMjgvdGhlLWRlZmluaXRpdmUtZ3VpZGUtdG8tbW9kdWxvLWJpYXMtYW5kLWhvdy10by1hdm9pZC1pdC9cbiAqIEBwYXJhbSBoYXNoIGhhc2ggb3V0cHV0IGZyb20gU0hBMyBvciBhIHNpbWlsYXIgZnVuY3Rpb25cbiAqIEBwYXJhbSBncm91cE9yZGVyIHNpemUgb2Ygc3ViZ3JvdXAgLSAoZS5nLiBjdXJ2ZUZuLkNVUlZFLm4pXG4gKiBAcGFyYW0gaXNMRSBpbnRlcnByZXQgaGFzaCBieXRlcyBhcyBMRSBudW1cbiAqIEByZXR1cm5zIHZhbGlkIHByaXZhdGUgc2NhbGFyXG4gKi9cbmZ1bmN0aW9uIGhhc2hUb1ByaXZhdGVTY2FsYXIoaGFzaCwgZ3JvdXBPcmRlciwgaXNMRSA9IGZhbHNlKSB7XG4gICAgaGFzaCA9ICgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgncHJpdmF0ZUhhc2gnLCBoYXNoKTtcbiAgICBjb25zdCBoYXNoTGVuID0gaGFzaC5sZW5ndGg7XG4gICAgY29uc3QgbWluTGVuID0gbkxlbmd0aChncm91cE9yZGVyKS5uQnl0ZUxlbmd0aCArIDg7XG4gICAgaWYgKG1pbkxlbiA8IDI0IHx8IGhhc2hMZW4gPCBtaW5MZW4gfHwgaGFzaExlbiA+IDEwMjQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaGFzaFRvUHJpdmF0ZVNjYWxhcjogZXhwZWN0ZWQgJHttaW5MZW59LTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAke2hhc2hMZW59YCk7XG4gICAgY29uc3QgbnVtID0gaXNMRSA/ICgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJMRSkoaGFzaCkgOiAoMCwgdXRpbHNfanNfMS5ieXRlc1RvTnVtYmVyQkUpKGhhc2gpO1xuICAgIHJldHVybiBtb2QobnVtLCBncm91cE9yZGVyIC0gXzFuKSArIF8xbjtcbn1cbmV4cG9ydHMuaGFzaFRvUHJpdmF0ZVNjYWxhciA9IGhhc2hUb1ByaXZhdGVTY2FsYXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGFyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImhhc2hUb1ByaXZhdGVTY2FsYXIiLCJGcFNxcnRFdmVuIiwiRnBTcXJ0T2RkIiwiRmllbGQiLCJuTGVuZ3RoIiwiRnBJc1NxdWFyZSIsIkZwRGl2IiwiRnBJbnZlcnRCYXRjaCIsIkZwUG93IiwidmFsaWRhdGVGaWVsZCIsImlzTmVnYXRpdmVMRSIsIkZwU3FydCIsInRvbmVsbGlTaGFua3MiLCJpbnZlcnQiLCJwb3cyIiwicG93IiwibW9kIiwidXRpbHNfanNfMSIsInJlcXVpcmUiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJfM24iLCJfNG4iLCJfNW4iLCJfOG4iLCJfOW4iLCJfMTZuIiwiYSIsImIiLCJyZXN1bHQiLCJudW0iLCJwb3dlciIsIm1vZHVsbyIsIkVycm9yIiwicmVzIiwieCIsIm51bWJlciIsInkiLCJ1IiwidiIsInEiLCJyIiwibSIsIm4iLCJnY2QiLCJQIiwibGVnZW5kcmVDIiwiUSIsIlMiLCJaIiwicDFkaXY0IiwidG9uZWxsaUZhc3QiLCJGcCIsInJvb3QiLCJlcWwiLCJzcXIiLCJRMWRpdjIiLCJ0b25lbGxpU2xvdyIsIm5lZyIsIk9ORSIsImciLCJtdWwiLCJaRVJPIiwidDIiLCJnZSIsInNxcnQzbW9kNCIsImMxIiwic3FydDVtb2Q4IiwibjIiLCJudiIsImkiLCJzdWIiLCJGSUVMRF9GSUVMRFMiLCJmaWVsZCIsImluaXRpYWwiLCJPUkRFUiIsIk1BU0siLCJCWVRFUyIsIkJJVFMiLCJvcHRzIiwicmVkdWNlIiwibWFwIiwidmFsIiwidmFsaWRhdGVPYmplY3QiLCJmIiwicCIsImQiLCJudW1zIiwidG1wIiwiQXJyYXkiLCJsZW5ndGgiLCJsYXN0TXVsdGlwbGllZCIsImFjYyIsImlzMCIsImludmVydGVkIiwiaW52IiwicmVkdWNlUmlnaHQiLCJsaHMiLCJyaHMiLCJsZWdlbmRyZUNvbnN0IiwibkJpdExlbmd0aCIsIl9uQml0TGVuZ3RoIiwidW5kZWZpbmVkIiwidG9TdHJpbmciLCJuQnl0ZUxlbmd0aCIsIk1hdGgiLCJjZWlsIiwiYml0TGVuIiwiaXNMRSIsInJlZGVmIiwic3FydFAiLCJmcmVlemUiLCJiaXRNYXNrIiwiY3JlYXRlIiwiaXNWYWxpZCIsImlzT2RkIiwiYWRkIiwiZGl2Iiwic3FyTiIsImFkZE4iLCJzdWJOIiwibXVsTiIsInNxcnQiLCJpbnZlcnRCYXRjaCIsImxzdCIsImNtb3YiLCJjIiwidG9CeXRlcyIsIm51bWJlclRvQnl0ZXNMRSIsIm51bWJlclRvQnl0ZXNCRSIsImZyb21CeXRlcyIsImJ5dGVzIiwiYnl0ZXNUb051bWJlckxFIiwiYnl0ZXNUb051bWJlckJFIiwiZWxtIiwiaGFzaCIsImdyb3VwT3JkZXIiLCJlbnN1cmVCeXRlcyIsImhhc2hMZW4iLCJtaW5MZW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/curves/abstract/modular.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/curves/abstract/utils.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/ethereum-cryptography/node_modules/@noble/curves/abstract/utils.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.validateObject = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.utf8ToBytes = exports.equalBytes = exports.concatBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToBytes = exports.hexToNumber = exports.numberToHexUnpadded = exports.bytesToHex = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst u8a = (a)=>a instanceof Uint8Array;\nconst hexes = Array.from({\n    length: 256\n}, (v, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    if (!u8a(bytes)) throw new Error(\"Uint8Array expected\");\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nexports.bytesToHex = bytesToHex;\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nexports.numberToHexUnpadded = numberToHexUnpadded;\nfunction hexToNumber(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    // Big Endian\n    return BigInt(hex === \"\" ? \"0\" : `0x${hex}`);\n}\nexports.hexToNumber = hexToNumber;\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    const len = hex.length;\n    if (len % 2) throw new Error(\"padded hex string expected, got unpadded hex of length \" + len);\n    const array = new Uint8Array(len / 2);\n    for(let i = 0; i < array.length; i++){\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0) throw new Error(\"Invalid byte sequence\");\n        array[i] = byte;\n    }\n    return array;\n}\nexports.hexToBytes = hexToBytes;\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nexports.bytesToNumberBE = bytesToNumberBE;\nfunction bytesToNumberLE(bytes) {\n    if (!u8a(bytes)) throw new Error(\"Uint8Array expected\");\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nexports.bytesToNumberLE = bytesToNumberLE;\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, \"0\"));\n}\nexports.numberToBytesBE = numberToBytesBE;\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\nexports.numberToBytesLE = numberToBytesLE;\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\nexports.numberToVarBytesBE = numberToVarBytesBE;\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */ function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === \"string\") {\n        try {\n            res = hexToBytes(hex);\n        } catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    } else if (u8a(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    } else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === \"number\" && len !== expectedLength) throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\nexports.ensureBytes = ensureBytes;\n/**\n * Copies several Uint8Arrays into one.\n */ function concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a)=>sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a)=>{\n        if (!u8a(a)) throw new Error(\"Uint8Array expected\");\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nexports.concatBytes = concatBytes;\nfunction equalBytes(b1, b2) {\n    // We don't care about timing attacks here\n    if (b1.length !== b2.length) return false;\n    for(let i = 0; i < b1.length; i++)if (b1[i] !== b2[i]) return false;\n    return true;\n}\nexports.equalBytes = equalBytes;\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\nexports.utf8ToBytes = utf8ToBytes;\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */ function bitLen(n) {\n    let len;\n    for(len = 0; n > _0n; n >>= _1n, len += 1);\n    return len;\n}\nexports.bitLen = bitLen;\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */ function bitGet(n, pos) {\n    return n >> BigInt(pos) & _1n;\n}\nexports.bitGet = bitGet;\n/**\n * Sets single bit at position.\n */ const bitSet = (n, pos, value)=>{\n    return n | (value ? _1n : _0n) << BigInt(pos);\n};\nexports.bitSet = bitSet;\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */ const bitMask = (n)=>(_2n << BigInt(n - 1)) - _1n;\nexports.bitMask = bitMask;\n// DRBG\nconst u8n = (data)=>new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr)=>Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */ function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== \"number\" || hashLen < 2) throw new Error(\"hashLen must be a number\");\n    if (typeof qByteLen !== \"number\" || qByteLen < 2) throw new Error(\"qByteLen must be a number\");\n    if (typeof hmacFn !== \"function\") throw new Error(\"hmacFn must be a function\");\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = ()=>{\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b)=>hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n())=>{\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([\n            0x00\n        ]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0) return;\n        k = h(u8fr([\n            0x01\n        ]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = ()=>{\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000) throw new Error(\"drbg: tried 1000 values\");\n        let len = 0;\n        const out = [];\n        while(len < qByteLen){\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred)=>{\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while(!(res = pred(gen())))reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\nexports.createHmacDrbg = createHmacDrbg;\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val)=>typeof val === \"bigint\",\n    function: (val)=>typeof val === \"function\",\n    boolean: (val)=>typeof val === \"boolean\",\n    string: (val)=>typeof val === \"string\",\n    isSafeInteger: (val)=>Number.isSafeInteger(val),\n    array: (val)=>Array.isArray(val),\n    field: (val, object)=>object.Fp.isValid(val),\n    hash: (val)=>typeof val === \"function\" && Number.isSafeInteger(val.outputLen)\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional)=>{\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== \"function\") throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined) return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))checkField(fieldName, type, true);\n    return object;\n}\nexports.validateObject = validateObject; // validate type tests\n // const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n // const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n // // Should fail type-check\n // const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n // const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n // const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n // const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2Fic3RyYWN0L3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxzQkFBc0IsR0FBR0Esc0JBQXNCLEdBQUdBLGVBQWUsR0FBR0EsY0FBYyxHQUFHQSxjQUFjLEdBQUdBLGNBQWMsR0FBR0EsbUJBQW1CLEdBQUdBLGtCQUFrQixHQUFHQSxtQkFBbUIsR0FBR0EsbUJBQW1CLEdBQUdBLDBCQUEwQixHQUFHQSx1QkFBdUIsR0FBR0EsdUJBQXVCLEdBQUdBLHVCQUF1QixHQUFHQSx1QkFBdUIsR0FBR0Esa0JBQWtCLEdBQUdBLG1CQUFtQixHQUFHQSwyQkFBMkIsR0FBR0Esa0JBQWtCLEdBQUcsS0FBSztBQUN0YixvRUFBb0UsR0FDcEUsMEVBQTBFO0FBQzFFLDhEQUE4RDtBQUM5RCwrRUFBK0U7QUFDL0UsdUNBQXVDO0FBQ3ZDLE1BQU1xQixNQUFNQyxPQUFPO0FBQ25CLE1BQU1DLE1BQU1ELE9BQU87QUFDbkIsTUFBTUUsTUFBTUYsT0FBTztBQUNuQixNQUFNRyxNQUFNLENBQUNDLElBQU1BLGFBQWFDO0FBQ2hDLE1BQU1DLFFBQVFDLE1BQU1DLElBQUksQ0FBQztJQUFFQyxRQUFRO0FBQUksR0FBRyxDQUFDQyxHQUFHQyxJQUFNQSxFQUFFQyxRQUFRLENBQUMsSUFBSUMsUUFBUSxDQUFDLEdBQUc7QUFDL0U7O0NBRUMsR0FDRCxTQUFTZixXQUFXZ0IsS0FBSztJQUNyQixJQUFJLENBQUNYLElBQUlXLFFBQ0wsTUFBTSxJQUFJQyxNQUFNO0lBQ3BCLG9DQUFvQztJQUNwQyxJQUFJQyxNQUFNO0lBQ1YsSUFBSyxJQUFJTCxJQUFJLEdBQUdBLElBQUlHLE1BQU1MLE1BQU0sRUFBRUUsSUFBSztRQUNuQ0ssT0FBT1YsS0FBSyxDQUFDUSxLQUFLLENBQUNILEVBQUUsQ0FBQztJQUMxQjtJQUNBLE9BQU9LO0FBQ1g7QUFDQXRDLGtCQUFrQixHQUFHb0I7QUFDckIsU0FBU0Qsb0JBQW9Cb0IsR0FBRztJQUM1QixNQUFNRCxNQUFNQyxJQUFJTCxRQUFRLENBQUM7SUFDekIsT0FBT0ksSUFBSVAsTUFBTSxHQUFHLElBQUksQ0FBQyxDQUFDLEVBQUVPLElBQUksQ0FBQyxHQUFHQTtBQUN4QztBQUNBdEMsMkJBQTJCLEdBQUdtQjtBQUM5QixTQUFTRCxZQUFZb0IsR0FBRztJQUNwQixJQUFJLE9BQU9BLFFBQVEsVUFDZixNQUFNLElBQUlELE1BQU0sOEJBQThCLE9BQU9DO0lBQ3pELGFBQWE7SUFDYixPQUFPaEIsT0FBT2dCLFFBQVEsS0FBSyxNQUFNLENBQUMsRUFBRSxFQUFFQSxJQUFJLENBQUM7QUFDL0M7QUFDQXRDLG1CQUFtQixHQUFHa0I7QUFDdEI7O0NBRUMsR0FDRCxTQUFTRCxXQUFXcUIsR0FBRztJQUNuQixJQUFJLE9BQU9BLFFBQVEsVUFDZixNQUFNLElBQUlELE1BQU0sOEJBQThCLE9BQU9DO0lBQ3pELE1BQU1FLE1BQU1GLElBQUlQLE1BQU07SUFDdEIsSUFBSVMsTUFBTSxHQUNOLE1BQU0sSUFBSUgsTUFBTSw0REFBNERHO0lBQ2hGLE1BQU1DLFFBQVEsSUFBSWQsV0FBV2EsTUFBTTtJQUNuQyxJQUFLLElBQUlQLElBQUksR0FBR0EsSUFBSVEsTUFBTVYsTUFBTSxFQUFFRSxJQUFLO1FBQ25DLE1BQU1TLElBQUlULElBQUk7UUFDZCxNQUFNVSxVQUFVTCxJQUFJTSxLQUFLLENBQUNGLEdBQUdBLElBQUk7UUFDakMsTUFBTUcsT0FBT0MsT0FBT0MsUUFBUSxDQUFDSixTQUFTO1FBQ3RDLElBQUlHLE9BQU9FLEtBQUssQ0FBQ0gsU0FBU0EsT0FBTyxHQUM3QixNQUFNLElBQUlSLE1BQU07UUFDcEJJLEtBQUssQ0FBQ1IsRUFBRSxHQUFHWTtJQUNmO0lBQ0EsT0FBT0o7QUFDWDtBQUNBekMsa0JBQWtCLEdBQUdpQjtBQUNyQixvQ0FBb0M7QUFDcEMsU0FBU0QsZ0JBQWdCb0IsS0FBSztJQUMxQixPQUFPbEIsWUFBWUUsV0FBV2dCO0FBQ2xDO0FBQ0FwQyx1QkFBdUIsR0FBR2dCO0FBQzFCLFNBQVNELGdCQUFnQnFCLEtBQUs7SUFDMUIsSUFBSSxDQUFDWCxJQUFJVyxRQUNMLE1BQU0sSUFBSUMsTUFBTTtJQUNwQixPQUFPbkIsWUFBWUUsV0FBV08sV0FBV0csSUFBSSxDQUFDTSxPQUFPYSxPQUFPO0FBQ2hFO0FBQ0FqRCx1QkFBdUIsR0FBR2U7QUFDMUIsU0FBU0QsZ0JBQWdCb0MsQ0FBQyxFQUFFVixHQUFHO0lBQzNCLE9BQU92QixXQUFXaUMsRUFBRWhCLFFBQVEsQ0FBQyxJQUFJQyxRQUFRLENBQUNLLE1BQU0sR0FBRztBQUN2RDtBQUNBeEMsdUJBQXVCLEdBQUdjO0FBQzFCLFNBQVNELGdCQUFnQnFDLENBQUMsRUFBRVYsR0FBRztJQUMzQixPQUFPMUIsZ0JBQWdCb0MsR0FBR1YsS0FBS1MsT0FBTztBQUMxQztBQUNBakQsdUJBQXVCLEdBQUdhO0FBQzFCLHdCQUF3QjtBQUN4QixTQUFTRCxtQkFBbUJzQyxDQUFDO0lBQ3pCLE9BQU9qQyxXQUFXRSxvQkFBb0IrQjtBQUMxQztBQUNBbEQsMEJBQTBCLEdBQUdZO0FBQzdCOzs7Ozs7OztDQVFDLEdBQ0QsU0FBU0QsWUFBWXdDLEtBQUssRUFBRWIsR0FBRyxFQUFFYyxjQUFjO0lBQzNDLElBQUlDO0lBQ0osSUFBSSxPQUFPZixRQUFRLFVBQVU7UUFDekIsSUFBSTtZQUNBZSxNQUFNcEMsV0FBV3FCO1FBQ3JCLEVBQ0EsT0FBT2dCLEdBQUc7WUFDTixNQUFNLElBQUlqQixNQUFNLENBQUMsRUFBRWMsTUFBTSxnQ0FBZ0MsRUFBRWIsSUFBSSxVQUFVLEVBQUVnQixFQUFFLENBQUM7UUFDbEY7SUFDSixPQUNLLElBQUk3QixJQUFJYSxNQUFNO1FBQ2YsbUVBQW1FO1FBQ25FLHNFQUFzRTtRQUN0RWUsTUFBTTFCLFdBQVdHLElBQUksQ0FBQ1E7SUFDMUIsT0FDSztRQUNELE1BQU0sSUFBSUQsTUFBTSxDQUFDLEVBQUVjLE1BQU0saUNBQWlDLENBQUM7SUFDL0Q7SUFDQSxNQUFNWCxNQUFNYSxJQUFJdEIsTUFBTTtJQUN0QixJQUFJLE9BQU9xQixtQkFBbUIsWUFBWVosUUFBUVksZ0JBQzlDLE1BQU0sSUFBSWYsTUFBTSxDQUFDLEVBQUVjLE1BQU0sVUFBVSxFQUFFQyxlQUFlLFlBQVksRUFBRVosSUFBSSxDQUFDO0lBQzNFLE9BQU9hO0FBQ1g7QUFDQXJELG1CQUFtQixHQUFHVztBQUN0Qjs7Q0FFQyxHQUNELFNBQVNELFlBQVksR0FBRzZDLE1BQU07SUFDMUIsTUFBTUMsSUFBSSxJQUFJN0IsV0FBVzRCLE9BQU9FLE1BQU0sQ0FBQyxDQUFDQyxLQUFLaEMsSUFBTWdDLE1BQU1oQyxFQUFFSyxNQUFNLEVBQUU7SUFDbkUsSUFBSTRCLE1BQU0sR0FBRyx1REFBdUQ7SUFDcEVKLE9BQU9LLE9BQU8sQ0FBQyxDQUFDbEM7UUFDWixJQUFJLENBQUNELElBQUlDLElBQ0wsTUFBTSxJQUFJVyxNQUFNO1FBQ3BCbUIsRUFBRUssR0FBRyxDQUFDbkMsR0FBR2lDO1FBQ1RBLE9BQU9qQyxFQUFFSyxNQUFNO0lBQ25CO0lBQ0EsT0FBT3lCO0FBQ1g7QUFDQXhELG1CQUFtQixHQUFHVTtBQUN0QixTQUFTRCxXQUFXcUQsRUFBRSxFQUFFQyxFQUFFO0lBQ3RCLDBDQUEwQztJQUMxQyxJQUFJRCxHQUFHL0IsTUFBTSxLQUFLZ0MsR0FBR2hDLE1BQU0sRUFDdkIsT0FBTztJQUNYLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJNkIsR0FBRy9CLE1BQU0sRUFBRUUsSUFDM0IsSUFBSTZCLEVBQUUsQ0FBQzdCLEVBQUUsS0FBSzhCLEVBQUUsQ0FBQzlCLEVBQUUsRUFDZixPQUFPO0lBQ2YsT0FBTztBQUNYO0FBQ0FqQyxrQkFBa0IsR0FBR1M7QUFDckI7O0NBRUMsR0FDRCxTQUFTRCxZQUFZd0QsR0FBRztJQUNwQixJQUFJLE9BQU9BLFFBQVEsVUFDZixNQUFNLElBQUkzQixNQUFNLENBQUMsaUNBQWlDLEVBQUUsT0FBTzJCLElBQUksQ0FBQztJQUNwRSxPQUFPLElBQUlyQyxXQUFXLElBQUlzQyxjQUFjQyxNQUFNLENBQUNGLE9BQU8sNEJBQTRCO0FBQ3RGO0FBQ0FoRSxtQkFBbUIsR0FBR1E7QUFDdEIsaUJBQWlCO0FBQ2pCOzs7Q0FHQyxHQUNELFNBQVNELE9BQU8yQyxDQUFDO0lBQ2IsSUFBSVY7SUFDSixJQUFLQSxNQUFNLEdBQUdVLElBQUk3QixLQUFLNkIsTUFBTTNCLEtBQUtpQixPQUFPO0lBRXpDLE9BQU9BO0FBQ1g7QUFDQXhDLGNBQWMsR0FBR087QUFDakI7Ozs7Q0FJQyxHQUNELFNBQVNELE9BQU80QyxDQUFDLEVBQUVpQixHQUFHO0lBQ2xCLE9BQU8sS0FBTTdDLE9BQU82QyxPQUFRNUM7QUFDaEM7QUFDQXZCLGNBQWMsR0FBR007QUFDakI7O0NBRUMsR0FDRCxNQUFNRCxTQUFTLENBQUM2QyxHQUFHaUIsS0FBS2xFO0lBQ3BCLE9BQU9pRCxJQUFLLENBQUNqRCxRQUFRc0IsTUFBTUYsR0FBRSxLQUFNQyxPQUFPNkM7QUFDOUM7QUFDQW5FLGNBQWMsR0FBR0s7QUFDakI7OztDQUdDLEdBQ0QsTUFBTUQsVUFBVSxDQUFDOEMsSUFBTSxDQUFDMUIsT0FBT0YsT0FBTzRCLElBQUksRUFBQyxJQUFLM0I7QUFDaER2QixlQUFlLEdBQUdJO0FBQ2xCLE9BQU87QUFDUCxNQUFNZ0UsTUFBTSxDQUFDQyxPQUFTLElBQUkxQyxXQUFXMEMsT0FBTyxxQkFBcUI7QUFDakUsTUFBTUMsT0FBTyxDQUFDQyxNQUFRNUMsV0FBV0csSUFBSSxDQUFDeUMsTUFBTSxtQkFBbUI7QUFDL0Q7Ozs7OztDQU1DLEdBQ0QsU0FBU3BFLGVBQWVxRSxPQUFPLEVBQUVDLFFBQVEsRUFBRUMsTUFBTTtJQUM3QyxJQUFJLE9BQU9GLFlBQVksWUFBWUEsVUFBVSxHQUN6QyxNQUFNLElBQUluQyxNQUFNO0lBQ3BCLElBQUksT0FBT29DLGFBQWEsWUFBWUEsV0FBVyxHQUMzQyxNQUFNLElBQUlwQyxNQUFNO0lBQ3BCLElBQUksT0FBT3FDLFdBQVcsWUFDbEIsTUFBTSxJQUFJckMsTUFBTTtJQUNwQixnREFBZ0Q7SUFDaEQsSUFBSUwsSUFBSW9DLElBQUlJLFVBQVUscUVBQXFFO0lBQzNGLElBQUlHLElBQUlQLElBQUlJLFVBQVUscUVBQXFFO0lBQzNGLElBQUl2QyxJQUFJLEdBQUcsZ0RBQWdEO0lBQzNELE1BQU0yQyxRQUFRO1FBQ1Y1QyxFQUFFNkMsSUFBSSxDQUFDO1FBQ1BGLEVBQUVFLElBQUksQ0FBQztRQUNQNUMsSUFBSTtJQUNSO0lBQ0EsTUFBTTZDLElBQUksQ0FBQyxHQUFHQyxJQUFNTCxPQUFPQyxHQUFHM0MsTUFBTStDLElBQUksd0JBQXdCO0lBQ2hFLE1BQU1DLFNBQVMsQ0FBQ0MsT0FBT2IsS0FBSztRQUN4Qix5Q0FBeUM7UUFDekNPLElBQUlHLEVBQUVSLEtBQUs7WUFBQztTQUFLLEdBQUdXLE9BQU8sbUNBQW1DO1FBQzlEakQsSUFBSThDLEtBQUssbUJBQW1CO1FBQzVCLElBQUlHLEtBQUtsRCxNQUFNLEtBQUssR0FDaEI7UUFDSjRDLElBQUlHLEVBQUVSLEtBQUs7WUFBQztTQUFLLEdBQUdXLE9BQU8sbUNBQW1DO1FBQzlEakQsSUFBSThDLEtBQUssbUJBQW1CO0lBQ2hDO0lBQ0EsTUFBTUksTUFBTTtRQUNSLGdDQUFnQztRQUNoQyxJQUFJakQsT0FBTyxNQUNQLE1BQU0sSUFBSUksTUFBTTtRQUNwQixJQUFJRyxNQUFNO1FBQ1YsTUFBTTJDLE1BQU0sRUFBRTtRQUNkLE1BQU8zQyxNQUFNaUMsU0FBVTtZQUNuQnpDLElBQUk4QztZQUNKLE1BQU1NLEtBQUtwRCxFQUFFWSxLQUFLO1lBQ2xCdUMsSUFBSUUsSUFBSSxDQUFDRDtZQUNUNUMsT0FBT1IsRUFBRUQsTUFBTTtRQUNuQjtRQUNBLE9BQU9yQixlQUFleUU7SUFDMUI7SUFDQSxNQUFNRyxXQUFXLENBQUNMLE1BQU1NO1FBQ3BCWDtRQUNBSSxPQUFPQyxPQUFPLFlBQVk7UUFDMUIsSUFBSTVCLE1BQU1tQyxXQUFXLHVDQUF1QztRQUM1RCxNQUFPLENBQUVuQyxDQUFBQSxNQUFNa0MsS0FBS0wsTUFBSyxFQUNyQkY7UUFDSko7UUFDQSxPQUFPdkI7SUFDWDtJQUNBLE9BQU9pQztBQUNYO0FBQ0F0RixzQkFBc0IsR0FBR0c7QUFDekIsK0JBQStCO0FBQy9CLE1BQU1zRixlQUFlO0lBQ2pCQyxRQUFRLENBQUNDLE1BQVEsT0FBT0EsUUFBUTtJQUNoQ0MsVUFBVSxDQUFDRCxNQUFRLE9BQU9BLFFBQVE7SUFDbENFLFNBQVMsQ0FBQ0YsTUFBUSxPQUFPQSxRQUFRO0lBQ2pDRyxRQUFRLENBQUNILE1BQVEsT0FBT0EsUUFBUTtJQUNoQ0ksZUFBZSxDQUFDSixNQUFRN0MsT0FBT2lELGFBQWEsQ0FBQ0o7SUFDN0NsRCxPQUFPLENBQUNrRCxNQUFROUQsTUFBTW1FLE9BQU8sQ0FBQ0w7SUFDOUJNLE9BQU8sQ0FBQ04sS0FBS08sU0FBV0EsT0FBT0MsRUFBRSxDQUFDQyxPQUFPLENBQUNUO0lBQzFDVSxNQUFNLENBQUNWLE1BQVEsT0FBT0EsUUFBUSxjQUFjN0MsT0FBT2lELGFBQWEsQ0FBQ0osSUFBSVcsU0FBUztBQUNsRjtBQUNBLHdFQUF3RTtBQUN4RSxTQUFTcEcsZUFBZWdHLE1BQU0sRUFBRUssVUFBVSxFQUFFQyxnQkFBZ0IsQ0FBQyxDQUFDO0lBQzFELE1BQU1DLGFBQWEsQ0FBQ0MsV0FBV0MsTUFBTUM7UUFDakMsTUFBTUMsV0FBV3BCLFlBQVksQ0FBQ2tCLEtBQUs7UUFDbkMsSUFBSSxPQUFPRSxhQUFhLFlBQ3BCLE1BQU0sSUFBSXhFLE1BQU0sQ0FBQyxtQkFBbUIsRUFBRXNFLEtBQUssb0JBQW9CLENBQUM7UUFDcEUsTUFBTWhCLE1BQU1PLE1BQU0sQ0FBQ1EsVUFBVTtRQUM3QixJQUFJRSxjQUFjakIsUUFBUUgsV0FDdEI7UUFDSixJQUFJLENBQUNxQixTQUFTbEIsS0FBS08sU0FBUztZQUN4QixNQUFNLElBQUk3RCxNQUFNLENBQUMsY0FBYyxFQUFFeUUsT0FBT0osV0FBVyxDQUFDLEVBQUVmLElBQUksRUFBRSxFQUFFLE9BQU9BLElBQUksWUFBWSxFQUFFZ0IsS0FBSyxDQUFDO1FBQ2pHO0lBQ0o7SUFDQSxLQUFLLE1BQU0sQ0FBQ0QsV0FBV0MsS0FBSyxJQUFJN0csT0FBT2lILE9BQU8sQ0FBQ1IsWUFDM0NFLFdBQVdDLFdBQVdDLE1BQU07SUFDaEMsS0FBSyxNQUFNLENBQUNELFdBQVdDLEtBQUssSUFBSTdHLE9BQU9pSCxPQUFPLENBQUNQLGVBQzNDQyxXQUFXQyxXQUFXQyxNQUFNO0lBQ2hDLE9BQU9UO0FBQ1g7QUFDQWxHLHNCQUFzQixHQUFHRSxnQkFDekIsc0JBQXNCO0NBQ3RCLHVFQUF1RTtDQUN2RSxnRkFBZ0Y7Q0FDaEYsNEJBQTRCO0NBQzVCLDJEQUEyRDtDQUMzRCxxRUFBcUU7Q0FDckUsK0RBQStEO0NBQy9ELDREQUE0RDtDQUM1RCxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2Fic3RyYWN0L3V0aWxzLmpzP2UwZWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlT2JqZWN0ID0gZXhwb3J0cy5jcmVhdGVIbWFjRHJiZyA9IGV4cG9ydHMuYml0TWFzayA9IGV4cG9ydHMuYml0U2V0ID0gZXhwb3J0cy5iaXRHZXQgPSBleHBvcnRzLmJpdExlbiA9IGV4cG9ydHMudXRmOFRvQnl0ZXMgPSBleHBvcnRzLmVxdWFsQnl0ZXMgPSBleHBvcnRzLmNvbmNhdEJ5dGVzID0gZXhwb3J0cy5lbnN1cmVCeXRlcyA9IGV4cG9ydHMubnVtYmVyVG9WYXJCeXRlc0JFID0gZXhwb3J0cy5udW1iZXJUb0J5dGVzTEUgPSBleHBvcnRzLm51bWJlclRvQnl0ZXNCRSA9IGV4cG9ydHMuYnl0ZXNUb051bWJlckxFID0gZXhwb3J0cy5ieXRlc1RvTnVtYmVyQkUgPSBleHBvcnRzLmhleFRvQnl0ZXMgPSBleHBvcnRzLmhleFRvTnVtYmVyID0gZXhwb3J0cy5udW1iZXJUb0hleFVucGFkZGVkID0gZXhwb3J0cy5ieXRlc1RvSGV4ID0gdm9pZCAwO1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gMTAwIGxpbmVzIG9mIGNvZGUgaW4gdGhlIGZpbGUgYXJlIGR1cGxpY2F0ZWQgZnJvbSBub2JsZS1oYXNoZXMgKHV0aWxzKS5cbi8vIFRoaXMgaXMgT0s6IGBhYnN0cmFjdGAgZGlyZWN0b3J5IGRvZXMgbm90IHVzZSBub2JsZS1oYXNoZXMuXG4vLyBVc2VyIG1heSBvcHQtaW4gaW50byB1c2luZyBkaWZmZXJlbnQgaGFzaGluZyBsaWJyYXJ5LiBUaGlzIHdheSwgbm9ibGUtaGFzaGVzXG4vLyB3b24ndCBiZSBpbmNsdWRlZCBpbnRvIHRoZWlyIGJ1bmRsZS5cbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IHU4YSA9IChhKSA9PiBhIGluc3RhbmNlb2YgVWludDhBcnJheTtcbmNvbnN0IGhleGVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sICh2LCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5mdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgaWYgKCF1OGEoYnl0ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuZXhwb3J0cy5ieXRlc1RvSGV4ID0gYnl0ZXNUb0hleDtcbmZ1bmN0aW9uIG51bWJlclRvSGV4VW5wYWRkZWQobnVtKSB7XG4gICAgY29uc3QgaGV4ID0gbnVtLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4Lmxlbmd0aCAmIDEgPyBgMCR7aGV4fWAgOiBoZXg7XG59XG5leHBvcnRzLm51bWJlclRvSGV4VW5wYWRkZWQgPSBudW1iZXJUb0hleFVucGFkZGVkO1xuZnVuY3Rpb24gaGV4VG9OdW1iZXIoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgLy8gQmlnIEVuZGlhblxuICAgIHJldHVybiBCaWdJbnQoaGV4ID09PSAnJyA/ICcwJyA6IGAweCR7aGV4fWApO1xufVxuZXhwb3J0cy5oZXhUb051bWJlciA9IGhleFRvTnVtYmVyO1xuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgbGVuID0gaGV4Lmxlbmd0aDtcbiAgICBpZiAobGVuICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGxlbik7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShsZW4gLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGogPSBpICogMjtcbiAgICAgICAgY29uc3QgaGV4Qnl0ZSA9IGhleC5zbGljZShqLCBqICsgMik7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIucGFyc2VJbnQoaGV4Qnl0ZSwgMTYpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGJ5dGUpIHx8IGJ5dGUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgc2VxdWVuY2UnKTtcbiAgICAgICAgYXJyYXlbaV0gPSBieXRlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5leHBvcnRzLmhleFRvQnl0ZXMgPSBoZXhUb0J5dGVzO1xuLy8gQkU6IEJpZyBFbmRpYW4sIExFOiBMaXR0bGUgRW5kaWFuXG5mdW5jdGlvbiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpIHtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChieXRlcykpO1xufVxuZXhwb3J0cy5ieXRlc1RvTnVtYmVyQkUgPSBieXRlc1RvTnVtYmVyQkU7XG5mdW5jdGlvbiBieXRlc1RvTnVtYmVyTEUoYnl0ZXMpIHtcbiAgICBpZiAoIXU4YShieXRlcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShieXRlcykucmV2ZXJzZSgpKSk7XG59XG5leHBvcnRzLmJ5dGVzVG9OdW1iZXJMRSA9IGJ5dGVzVG9OdW1iZXJMRTtcbmZ1bmN0aW9uIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pIHtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhuLnRvU3RyaW5nKDE2KS5wYWRTdGFydChsZW4gKiAyLCAnMCcpKTtcbn1cbmV4cG9ydHMubnVtYmVyVG9CeXRlc0JFID0gbnVtYmVyVG9CeXRlc0JFO1xuZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0xFKG4sIGxlbikge1xuICAgIHJldHVybiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKS5yZXZlcnNlKCk7XG59XG5leHBvcnRzLm51bWJlclRvQnl0ZXNMRSA9IG51bWJlclRvQnl0ZXNMRTtcbi8vIFVucGFkZGVkLCByYXJlbHkgdXNlZFxuZnVuY3Rpb24gbnVtYmVyVG9WYXJCeXRlc0JFKG4pIHtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhudW1iZXJUb0hleFVucGFkZGVkKG4pKTtcbn1cbmV4cG9ydHMubnVtYmVyVG9WYXJCeXRlc0JFID0gbnVtYmVyVG9WYXJCeXRlc0JFO1xuLyoqXG4gKiBUYWtlcyBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXksIGNvbnZlcnRzIHRvIFVpbnQ4QXJyYXkuXG4gKiBWYWxpZGF0ZXMgb3V0cHV0IGxlbmd0aC5cbiAqIFdpbGwgdGhyb3cgZXJyb3IgZm9yIG90aGVyIHR5cGVzLlxuICogQHBhcmFtIHRpdGxlIGRlc2NyaXB0aXZlIHRpdGxlIGZvciBhbiBlcnJvciBlLmcuICdwcml2YXRlIGtleSdcbiAqIEBwYXJhbSBoZXggaGV4IHN0cmluZyBvciBVaW50OEFycmF5XG4gKiBAcGFyYW0gZXhwZWN0ZWRMZW5ndGggb3B0aW9uYWwsIHdpbGwgY29tcGFyZSB0byByZXN1bHQgYXJyYXkncyBsZW5ndGhcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGVuc3VyZUJ5dGVzKHRpdGxlLCBoZXgsIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgbGV0IHJlcztcbiAgICBpZiAodHlwZW9mIGhleCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlcyA9IGhleFRvQnl0ZXMoaGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBtdXN0IGJlIHZhbGlkIGhleCBzdHJpbmcsIGdvdCBcIiR7aGV4fVwiLiBDYXVzZTogJHtlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHU4YShoZXgpKSB7XG4gICAgICAgIC8vIFVpbnQ4QXJyYXkuZnJvbSgpIGluc3RlYWQgb2YgaGFzaC5zbGljZSgpIGJlY2F1c2Ugbm9kZS5qcyBCdWZmZXJcbiAgICAgICAgLy8gaXMgaW5zdGFuY2Ugb2YgVWludDhBcnJheSwgYW5kIGl0cyBzbGljZSgpIGNyZWF0ZXMgKiptdXRhYmxlKiogY29weVxuICAgICAgICByZXMgPSBVaW50OEFycmF5LmZyb20oaGV4KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gbXVzdCBiZSBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXlgKTtcbiAgICB9XG4gICAgY29uc3QgbGVuID0gcmVzLmxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGV4cGVjdGVkTGVuZ3RoID09PSAnbnVtYmVyJyAmJiBsZW4gIT09IGV4cGVjdGVkTGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IGV4cGVjdGVkICR7ZXhwZWN0ZWRMZW5ndGh9IGJ5dGVzLCBnb3QgJHtsZW59YCk7XG4gICAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMuZW5zdXJlQnl0ZXMgPSBlbnN1cmVCeXRlcztcbi8qKlxuICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGNvbnN0IHIgPSBuZXcgVWludDhBcnJheShhcnJheXMucmVkdWNlKChzdW0sIGEpID0+IHN1bSArIGEubGVuZ3RoLCAwKSk7XG4gICAgbGV0IHBhZCA9IDA7IC8vIHdhbGsgdGhyb3VnaCBlYWNoIGl0ZW0sIGVuc3VyZSB0aGV5IGhhdmUgcHJvcGVyIHR5cGVcbiAgICBhcnJheXMuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgICBpZiAoIXU4YShhKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgICAgICByLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHI7XG59XG5leHBvcnRzLmNvbmNhdEJ5dGVzID0gY29uY2F0Qnl0ZXM7XG5mdW5jdGlvbiBlcXVhbEJ5dGVzKGIxLCBiMikge1xuICAgIC8vIFdlIGRvbid0IGNhcmUgYWJvdXQgdGltaW5nIGF0dGFja3MgaGVyZVxuICAgIGlmIChiMS5sZW5ndGggIT09IGIyLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYjEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmIChiMVtpXSAhPT0gYjJbaV0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmVxdWFsQnl0ZXMgPSBlcXVhbEJ5dGVzO1xuLyoqXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbmV4cG9ydHMudXRmOFRvQnl0ZXMgPSB1dGY4VG9CeXRlcztcbi8vIEJpdCBvcGVyYXRpb25zXG4vKipcbiAqIENhbGN1bGF0ZXMgYW1vdW50IG9mIGJpdHMgaW4gYSBiaWdpbnQuXG4gKiBTYW1lIGFzIGBuLnRvU3RyaW5nKDIpLmxlbmd0aGBcbiAqL1xuZnVuY3Rpb24gYml0TGVuKG4pIHtcbiAgICBsZXQgbGVuO1xuICAgIGZvciAobGVuID0gMDsgbiA+IF8wbjsgbiA+Pj0gXzFuLCBsZW4gKz0gMSlcbiAgICAgICAgO1xuICAgIHJldHVybiBsZW47XG59XG5leHBvcnRzLmJpdExlbiA9IGJpdExlbjtcbi8qKlxuICogR2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLlxuICogTk9URTogZmlyc3QgYml0IHBvc2l0aW9uIGlzIDAgKHNhbWUgYXMgYXJyYXlzKVxuICogU2FtZSBhcyBgISErQXJyYXkuZnJvbShuLnRvU3RyaW5nKDIpKS5yZXZlcnNlKClbcG9zXWBcbiAqL1xuZnVuY3Rpb24gYml0R2V0KG4sIHBvcykge1xuICAgIHJldHVybiAobiA+PiBCaWdJbnQocG9zKSkgJiBfMW47XG59XG5leHBvcnRzLmJpdEdldCA9IGJpdEdldDtcbi8qKlxuICogU2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLlxuICovXG5jb25zdCBiaXRTZXQgPSAobiwgcG9zLCB2YWx1ZSkgPT4ge1xuICAgIHJldHVybiBuIHwgKCh2YWx1ZSA/IF8xbiA6IF8wbikgPDwgQmlnSW50KHBvcykpO1xufTtcbmV4cG9ydHMuYml0U2V0ID0gYml0U2V0O1xuLyoqXG4gKiBDYWxjdWxhdGUgbWFzayBmb3IgTiBiaXRzLiBOb3QgdXNpbmcgKiogb3BlcmF0b3Igd2l0aCBiaWdpbnRzIGJlY2F1c2Ugb2Ygb2xkIGVuZ2luZXMuXG4gKiBTYW1lIGFzIEJpZ0ludChgMGIke0FycmF5KGkpLmZpbGwoJzEnKS5qb2luKCcnKX1gKVxuICovXG5jb25zdCBiaXRNYXNrID0gKG4pID0+IChfMm4gPDwgQmlnSW50KG4gLSAxKSkgLSBfMW47XG5leHBvcnRzLmJpdE1hc2sgPSBiaXRNYXNrO1xuLy8gRFJCR1xuY29uc3QgdThuID0gKGRhdGEpID0+IG5ldyBVaW50OEFycmF5KGRhdGEpOyAvLyBjcmVhdGVzIFVpbnQ4QXJyYXlcbmNvbnN0IHU4ZnIgPSAoYXJyKSA9PiBVaW50OEFycmF5LmZyb20oYXJyKTsgLy8gYW5vdGhlciBzaG9ydGN1dFxuLyoqXG4gKiBNaW5pbWFsIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHdpbGwgY2FsbCBEUkJHIHVudGlsIDJuZCBhcmcgcmV0dXJucyBzb21ldGhpbmcgbWVhbmluZ2Z1bFxuICogQGV4YW1wbGVcbiAqICAgY29uc3QgZHJiZyA9IGNyZWF0ZUhtYWNEUkJHPEtleT4oMzIsIDMyLCBobWFjKTtcbiAqICAgZHJiZyhzZWVkLCBieXRlc1RvS2V5KTsgLy8gYnl0ZXNUb0tleSBtdXN0IHJldHVybiBLZXkgb3IgdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUhtYWNEcmJnKGhhc2hMZW4sIHFCeXRlTGVuLCBobWFjRm4pIHtcbiAgICBpZiAodHlwZW9mIGhhc2hMZW4gIT09ICdudW1iZXInIHx8IGhhc2hMZW4gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hhc2hMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgcUJ5dGVMZW4gIT09ICdudW1iZXInIHx8IHFCeXRlTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdxQnl0ZUxlbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgaWYgKHR5cGVvZiBobWFjRm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaG1hY0ZuIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIC8vIFN0ZXAgQiwgU3RlcCBDOiBzZXQgaGFzaExlbiB0byA4KmNlaWwoaGxlbi84KVxuICAgIGxldCB2ID0gdThuKGhhc2hMZW4pOyAvLyBNaW5pbWFsIG5vbi1mdWxsLXNwZWMgSE1BQy1EUkJHIGZyb20gTklTVCA4MDAtOTAgZm9yIFJGQzY5Nzkgc2lncy5cbiAgICBsZXQgayA9IHU4bihoYXNoTGVuKTsgLy8gU3RlcHMgQiBhbmQgQyBvZiBSRkM2OTc5IDMuMjogc2V0IGhhc2hMZW4sIGluIG91ciBjYXNlIGFsd2F5cyBzYW1lXG4gICAgbGV0IGkgPSAwOyAvLyBJdGVyYXRpb25zIGNvdW50ZXIsIHdpbGwgdGhyb3cgd2hlbiBvdmVyIDEwMDBcbiAgICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICAgICAgdi5maWxsKDEpO1xuICAgICAgICBrLmZpbGwoMCk7XG4gICAgICAgIGkgPSAwO1xuICAgIH07XG4gICAgY29uc3QgaCA9ICguLi5iKSA9PiBobWFjRm4oaywgdiwgLi4uYik7IC8vIGhtYWMoaykodiwgLi4udmFsdWVzKVxuICAgIGNvbnN0IHJlc2VlZCA9IChzZWVkID0gdThuKCkpID0+IHtcbiAgICAgICAgLy8gSE1BQy1EUkJHIHJlc2VlZCgpIGZ1bmN0aW9uLiBTdGVwcyBELUdcbiAgICAgICAgayA9IGgodThmcihbMHgwMF0pLCBzZWVkKTsgLy8gayA9IGhtYWMoayB8fCB2IHx8IDB4MDAgfHwgc2VlZClcbiAgICAgICAgdiA9IGgoKTsgLy8gdiA9IGhtYWMoayB8fCB2KVxuICAgICAgICBpZiAoc2VlZC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDFdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAxIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICB9O1xuICAgIGNvbnN0IGdlbiA9ICgpID0+IHtcbiAgICAgICAgLy8gSE1BQy1EUkJHIGdlbmVyYXRlKCkgZnVuY3Rpb25cbiAgICAgICAgaWYgKGkrKyA+PSAxMDAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkcmJnOiB0cmllZCAxMDAwIHZhbHVlcycpO1xuICAgICAgICBsZXQgbGVuID0gMDtcbiAgICAgICAgY29uc3Qgb3V0ID0gW107XG4gICAgICAgIHdoaWxlIChsZW4gPCBxQnl0ZUxlbikge1xuICAgICAgICAgICAgdiA9IGgoKTtcbiAgICAgICAgICAgIGNvbnN0IHNsID0gdi5zbGljZSgpO1xuICAgICAgICAgICAgb3V0LnB1c2goc2wpO1xuICAgICAgICAgICAgbGVuICs9IHYubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25jYXRCeXRlcyguLi5vdXQpO1xuICAgIH07XG4gICAgY29uc3QgZ2VuVW50aWwgPSAoc2VlZCwgcHJlZCkgPT4ge1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXNlZWQoc2VlZCk7IC8vIFN0ZXBzIEQtR1xuICAgICAgICBsZXQgcmVzID0gdW5kZWZpbmVkOyAvLyBTdGVwIEg6IGdyaW5kIHVudGlsIGsgaXMgaW4gWzEuLm4tMV1cbiAgICAgICAgd2hpbGUgKCEocmVzID0gcHJlZChnZW4oKSkpKVxuICAgICAgICAgICAgcmVzZWVkKCk7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICByZXR1cm4gZ2VuVW50aWw7XG59XG5leHBvcnRzLmNyZWF0ZUhtYWNEcmJnID0gY3JlYXRlSG1hY0RyYmc7XG4vLyBWYWxpZGF0aW5nIGN1cnZlcyBhbmQgZmllbGRzXG5jb25zdCB2YWxpZGF0b3JGbnMgPSB7XG4gICAgYmlnaW50OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnYmlnaW50JyxcbiAgICBmdW5jdGlvbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyxcbiAgICBib29sZWFuOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnYm9vbGVhbicsXG4gICAgc3RyaW5nOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyxcbiAgICBpc1NhZmVJbnRlZ2VyOiAodmFsKSA9PiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwpLFxuICAgIGFycmF5OiAodmFsKSA9PiBBcnJheS5pc0FycmF5KHZhbCksXG4gICAgZmllbGQ6ICh2YWwsIG9iamVjdCkgPT4gb2JqZWN0LkZwLmlzVmFsaWQodmFsKSxcbiAgICBoYXNoOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nICYmIE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbC5vdXRwdXRMZW4pLFxufTtcbi8vIHR5cGUgUmVjb3JkPEsgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2wsIFQ+ID0geyBbUCBpbiBLXTogVDsgfVxuZnVuY3Rpb24gdmFsaWRhdGVPYmplY3Qob2JqZWN0LCB2YWxpZGF0b3JzLCBvcHRWYWxpZGF0b3JzID0ge30pIHtcbiAgICBjb25zdCBjaGVja0ZpZWxkID0gKGZpZWxkTmFtZSwgdHlwZSwgaXNPcHRpb25hbCkgPT4ge1xuICAgICAgICBjb25zdCBjaGVja1ZhbCA9IHZhbGlkYXRvckZuc1t0eXBlXTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGVja1ZhbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWxpZGF0b3IgXCIke3R5cGV9XCIsIGV4cGVjdGVkIGZ1bmN0aW9uYCk7XG4gICAgICAgIGNvbnN0IHZhbCA9IG9iamVjdFtmaWVsZE5hbWVdO1xuICAgICAgICBpZiAoaXNPcHRpb25hbCAmJiB2YWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFjaGVja1ZhbCh2YWwsIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwYXJhbSAke1N0cmluZyhmaWVsZE5hbWUpfT0ke3ZhbH0gKCR7dHlwZW9mIHZhbH0pLCBleHBlY3RlZCAke3R5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXModmFsaWRhdG9ycykpXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCBmYWxzZSk7XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyhvcHRWYWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIHRydWUpO1xuICAgIHJldHVybiBvYmplY3Q7XG59XG5leHBvcnRzLnZhbGlkYXRlT2JqZWN0ID0gdmFsaWRhdGVPYmplY3Q7XG4vLyB2YWxpZGF0ZSB0eXBlIHRlc3RzXG4vLyBjb25zdCBvOiB7IGE6IG51bWJlcjsgYjogbnVtYmVyOyBjOiBudW1iZXIgfSA9IHsgYTogMSwgYjogNSwgYzogNiB9O1xuLy8gY29uc3QgejAgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICdiaWdpbnQnIH0pOyAvLyBPayFcbi8vIC8vIFNob3VsZCBmYWlsIHR5cGUtY2hlY2tcbi8vIGNvbnN0IHoxID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAndG1wJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MiA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHozID0gdmFsaWRhdGVPYmplY3QobywgeyB0ZXN0OiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuLy8gY29uc3QgejQgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ2YWxpZGF0ZU9iamVjdCIsImNyZWF0ZUhtYWNEcmJnIiwiYml0TWFzayIsImJpdFNldCIsImJpdEdldCIsImJpdExlbiIsInV0ZjhUb0J5dGVzIiwiZXF1YWxCeXRlcyIsImNvbmNhdEJ5dGVzIiwiZW5zdXJlQnl0ZXMiLCJudW1iZXJUb1ZhckJ5dGVzQkUiLCJudW1iZXJUb0J5dGVzTEUiLCJudW1iZXJUb0J5dGVzQkUiLCJieXRlc1RvTnVtYmVyTEUiLCJieXRlc1RvTnVtYmVyQkUiLCJoZXhUb0J5dGVzIiwiaGV4VG9OdW1iZXIiLCJudW1iZXJUb0hleFVucGFkZGVkIiwiYnl0ZXNUb0hleCIsIl8wbiIsIkJpZ0ludCIsIl8xbiIsIl8ybiIsInU4YSIsImEiLCJVaW50OEFycmF5IiwiaGV4ZXMiLCJBcnJheSIsImZyb20iLCJsZW5ndGgiLCJ2IiwiaSIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJieXRlcyIsIkVycm9yIiwiaGV4IiwibnVtIiwibGVuIiwiYXJyYXkiLCJqIiwiaGV4Qnl0ZSIsInNsaWNlIiwiYnl0ZSIsIk51bWJlciIsInBhcnNlSW50IiwiaXNOYU4iLCJyZXZlcnNlIiwibiIsInRpdGxlIiwiZXhwZWN0ZWRMZW5ndGgiLCJyZXMiLCJlIiwiYXJyYXlzIiwiciIsInJlZHVjZSIsInN1bSIsInBhZCIsImZvckVhY2giLCJzZXQiLCJiMSIsImIyIiwic3RyIiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJwb3MiLCJ1OG4iLCJkYXRhIiwidThmciIsImFyciIsImhhc2hMZW4iLCJxQnl0ZUxlbiIsImhtYWNGbiIsImsiLCJyZXNldCIsImZpbGwiLCJoIiwiYiIsInJlc2VlZCIsInNlZWQiLCJnZW4iLCJvdXQiLCJzbCIsInB1c2giLCJnZW5VbnRpbCIsInByZWQiLCJ1bmRlZmluZWQiLCJ2YWxpZGF0b3JGbnMiLCJiaWdpbnQiLCJ2YWwiLCJmdW5jdGlvbiIsImJvb2xlYW4iLCJzdHJpbmciLCJpc1NhZmVJbnRlZ2VyIiwiaXNBcnJheSIsImZpZWxkIiwib2JqZWN0IiwiRnAiLCJpc1ZhbGlkIiwiaGFzaCIsIm91dHB1dExlbiIsInZhbGlkYXRvcnMiLCJvcHRWYWxpZGF0b3JzIiwiY2hlY2tGaWVsZCIsImZpZWxkTmFtZSIsInR5cGUiLCJpc09wdGlvbmFsIiwiY2hlY2tWYWwiLCJTdHJpbmciLCJlbnRyaWVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/curves/abstract/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/curves/abstract/weierstrass.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/ethereum-cryptography/node_modules/@noble/curves/abstract/weierstrass.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.mapToCurveSimpleSWU = exports.SWUFpSqrtRatio = exports.weierstrass = exports.weierstrassPoints = exports.DER = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Short Weierstrass curve. The formula is: y¬≤ = x¬≥ + ax + b\nconst mod = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/curves/abstract/modular.js\");\nconst ut = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/curves/abstract/utils.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/curves/abstract/utils.js\");\nconst curve_js_1 = __webpack_require__(/*! ./curve.js */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/curves/abstract/curve.js\");\nfunction validatePointOpts(curve) {\n    const opts = (0, curve_js_1.validateBasic)(curve);\n    ut.validateObject(opts, {\n        a: \"field\",\n        b: \"field\"\n    }, {\n        allowedPrivateKeyLengths: \"array\",\n        wrapPrivateKey: \"boolean\",\n        isTorsionFree: \"function\",\n        clearCofactor: \"function\",\n        allowInfinityPoint: \"boolean\",\n        fromBytes: \"function\",\n        toBytes: \"function\"\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error(\"Endomorphism can only be defined for Koblitz curves that have a=0\");\n        }\n        if (typeof endo !== \"object\" || typeof endo.beta !== \"bigint\" || typeof endo.splitScalar !== \"function\") {\n            throw new Error(\"Expected endomorphism with beta: bigint and splitScalar: function\");\n        }\n    }\n    return Object.freeze({\n        ...opts\n    });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;\nexports.DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = \"\"){\n            super(m);\n        }\n    },\n    _parseInt (data) {\n        const { Err: E } = exports.DER;\n        if (data.length < 2 || data[0] !== 0x02) throw new E(\"Invalid signature integer tag\");\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len) throw new E(\"Invalid signature integer: wrong length\");\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 128) throw new E(\"Invalid signature integer: negative\");\n        if (res[0] === 0x00 && !(res[1] & 128)) throw new E(\"Invalid signature integer: unnecessary leading zero\");\n        return {\n            d: b2n(res),\n            l: data.subarray(len + 2)\n        }; // d is data, l is left\n    },\n    toSig (hex) {\n        // parse DER signature\n        const { Err: E } = exports.DER;\n        const data = typeof hex === \"string\" ? h2b(hex) : hex;\n        if (!(data instanceof Uint8Array)) throw new Error(\"ui8a expected\");\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30) throw new E(\"Invalid signature tag\");\n        if (data[1] !== l - 2) throw new E(\"Invalid signature: incorrect length\");\n        const { d: r, l: sBytes } = exports.DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = exports.DER._parseInt(sBytes);\n        if (rBytesLeft.length) throw new E(\"Invalid signature: left bytes after parsing\");\n        return {\n            r,\n            s\n        };\n    },\n    hexFromSig (sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s)=>Number.parseInt(s[0], 16) & 8 ? \"00\" + s : s;\n        const h = (num)=>{\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    }\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes || ((c, point, isCompressed)=>{\n        const a = point.toAffine();\n        return ut.concatBytes(Uint8Array.from([\n            0x04\n        ]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n    });\n    const fromBytes = CURVE.fromBytes || ((bytes)=>{\n        // const head = bytes[0];\n        const tail = bytes.subarray(1);\n        // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n        return {\n            x,\n            y\n        };\n    });\n    /**\n     * y¬≤ = x¬≥ + ax + b: Short weierstrass curve formula\n     * @returns y¬≤\n     */ function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx))) throw new Error(\"bad generator point: equation left != right\");\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === \"bigint\" && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num)) throw new Error(\"Expected valid bigint: 0 < bigint < curve.n\");\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== \"bigint\") {\n            if (key instanceof Uint8Array) key = ut.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== \"string\" || !lengths.includes(key.length)) throw new Error(\"Invalid key\");\n            key = key.padStart(nByteLength * 2, \"0\");\n        }\n        let num;\n        try {\n            num = typeof key === \"bigint\" ? key : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)(\"private key\", key, nByteLength));\n        } catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey) num = mod.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point)) throw new Error(\"ProjectivePoint expected\");\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ‚àã (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */ class Point {\n        constructor(px, py, pz){\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px)) throw new Error(\"x required\");\n            if (py == null || !Fp.isValid(py)) throw new Error(\"y required\");\n            if (pz == null || !Fp.isValid(pz)) throw new Error(\"z required\");\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"invalid affine point\");\n            if (p instanceof Point) throw new Error(\"projective point not allowed\");\n            const is0 = (i)=>Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y)) return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */ static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p)=>p.pz));\n            return points.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */ static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)(\"pointHex\", hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            // Zero is valid point too!\n            if (this.is0()) {\n                if (CURVE.allowInfinityPoint) return;\n                throw new Error(\"bad point: ZERO\");\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"bad point: x or y not FE\");\n            const left = Fp.sqr(y); // y¬≤\n            const right = weierstrassEquation(x); // x¬≥ + ax + b\n            if (!Fp.eql(left, right)) throw new Error(\"bad point: equation left != right\");\n            if (!this.isTorsionFree()) throw new Error(\"bad point: not in prime-order subgroup\");\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd) return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */ equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */ negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp)=>{\n                const toInv = Fp.invertBatch(comp.map((p)=>p.pz));\n                return comp.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */ multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n) return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n) return this;\n            const { endo } = CURVE;\n            if (!endo) return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while(k1 > _0n || k2 > _0n){\n                if (k1 & _1n) k1p = k1p.add(d);\n                if (k2 & _1n) k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg) k1p = k1p.negate();\n            if (k2neg) k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */ multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            } else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([\n                point,\n                fake\n            ])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */ multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            )=>a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a);\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ‚àã (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0) return {\n                x: Fp.ZERO,\n                y: Fp.ZERO\n            };\n            if (!Fp.eql(zz, Fp.ONE)) throw new Error(\"invZ was invalid\");\n            return {\n                x: ax,\n                y: ay\n            };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n) return true; // No subgroups, always torsion-free\n            if (isTorsionFree) return isTorsionFree(Point, this);\n            throw new Error(\"isTorsionFree() has not been declared for the elliptic curve\");\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n) return this; // Fast-path\n            if (clearCofactor) return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return ut.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder\n    };\n}\nexports.weierstrassPoints = weierstrassPoints;\nfunction validateOpts(curve) {\n    const opts = (0, curve_js_1.validateBasic)(curve);\n    ut.validateObject(opts, {\n        hash: \"hash\",\n        hmac: \"function\",\n        randomBytes: \"function\"\n    }, {\n        bits2int: \"function\",\n        bits2int_modN: \"function\",\n        lowS: \"boolean\"\n    });\n    return Object.freeze({\n        lowS: true,\n        ...opts\n    });\n}\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return mod.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return mod.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({\n        ...CURVE,\n        toBytes (c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = ut.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([\n                    point.hasEvenY() ? 0x02 : 0x03\n                ]), x);\n            } else {\n                return cat(Uint8Array.from([\n                    0x04\n                ]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes (bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = ut.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x)) throw new Error(\"Point is not on curve\");\n                const y2 = weierstrassEquation(x); // y¬≤ = x¬≥ + ax + b\n                let y = Fp.sqrt(y2); // y = y¬≤ ^ (p+1)/4\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n                return {\n                    x,\n                    y\n                };\n            } else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return {\n                    x,\n                    y\n                };\n            } else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        }\n    });\n    const numToNByteStr = (num)=>ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to)=>ut.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */ class Signature {\n        constructor(r, s, recovery){\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0, utils_js_1.ensureBytes)(\"compactSignature\", hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = exports.DER.toSig((0, utils_js_1.ensureBytes)(\"DER\", hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r)) throw new Error(\"r must be 0 < r < CURVE.n\");\n            if (!isWithinCurveOrder(this.s)) throw new Error(\"s must be 0 < s < CURVE.n\");\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0, utils_js_1.ensureBytes)(\"msgHash\", msgHash)); // Truncate hash\n            if (rec == null || ![\n                0,\n                1,\n                2,\n                3\n            ].includes(rec)) throw new Error(\"recovery id invalid\");\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER) throw new Error(\"recovery id 2 or 3 invalid\");\n            const prefix = (rec & 1) === 0 ? \"02\" : \"03\";\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q) throw new Error(\"point at infinify\"); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return ut.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return exports.DER.hexFromSig({\n                r: this.r,\n                s: this.s\n            });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return ut.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey (privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            } catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size (nBitLength+64)\n         * as per FIPS 186 B.4.1 with modulo bias being neglible.\n         */ randomPrivateKey: ()=>{\n            const rand = CURVE.randomBytes(Fp.BYTES + 8);\n            const num = mod.hashToPrivateScalar(rand, CURVE_ORDER);\n            return ut.numberToBytesBE(num, CURVE.nByteLength);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */ precompute (windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        }\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */ function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */ function isProbPub(item) {\n        const arr = item instanceof Uint8Array;\n        const str = typeof item === \"string\";\n        const len = (arr || str) && item.length;\n        if (arr) return len === compressedLen || len === uncompressedLen;\n        if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point) return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */ function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA)) throw new Error(\"first arg must be private key\");\n        if (!isProbPub(publicB)) throw new Error(\"second arg must be public key\");\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int || function(bytes) {\n        // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n        // for some cases, since bytes.length * 8 is not actual bitLength.\n        const num = ut.bytesToNumberBE(bytes); // check for == u8 done here\n        const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n        return delta > 0 ? num >> BigInt(delta) : num;\n    };\n    const bits2int_modN = CURVE.bits2int_modN || function(bytes) {\n        return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = ut.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */ function int2octets(num) {\n        if (typeof num !== \"bigint\") throw new Error(\"bigint expected\");\n        if (!(_0n <= num && num < ORDER_MASK)) throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return ut.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if ([\n            \"recovered\",\n            \"canonical\"\n        ].some((k)=>k in opts)) throw new Error(\"sign() legacy options not supported\");\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0, utils_js_1.ensureBytes)(\"msgHash\", msgHash);\n        if (prehash) msgHash = (0, utils_js_1.ensureBytes)(\"prehashed msgHash\", hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [\n            int2octets(d),\n            int2octets(h1int)\n        ];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0, utils_js_1.ensureBytes)(\"extraEntropy\", e, Fp.BYTES)); // check for being of size BYTES\n        }\n        const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n) return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ‚àà [1,q‚àí1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n) return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return {\n            seed,\n            k2sig\n        };\n    }\n    const defaultSigOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    const defaultVerOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G √ó k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */ function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1‚ãÖG - U2‚ãÖP\n     *   mod(R.x, n) == r\n     * ```\n     */ function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0, utils_js_1.ensureBytes)(\"msgHash\", msgHash);\n        publicKey = (0, utils_js_1.ensureBytes)(\"publicKey\", publicKey);\n        if (\"strict\" in opts) throw new Error(\"options.strict was renamed to lowS\");\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === \"string\" || sg instanceof Uint8Array) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                } catch (derError) {\n                    if (!(derError instanceof exports.DER.Err)) throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            } else if (typeof sg === \"object\" && typeof sg.r === \"bigint\" && typeof sg.s === \"bigint\") {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            } else {\n                throw new Error(\"PARSE\");\n            }\n            P = Point.fromHex(publicKey);\n        } catch (error) {\n            if (error.message === \"PARSE\") throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS()) return false;\n        if (prehash) msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1‚ãÖG + u2‚ãÖP\n        if (!R) return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils\n    };\n}\nexports.weierstrass = weierstrass;\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */ function SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for(let o = q - _1n; o % _2n === _0n; o /= _2n)l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v)=>{\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for(let i = c1; i > _1n; i--){\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << tv5 - _1n; // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return {\n            isValid: isQR,\n            value: tv3\n        };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v)=>{\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return {\n                isValid: isQR,\n                value: y\n            }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\nexports.SWUFpSqrtRatio = SWUFpSqrtRatio;\n/**\n * From draft-irtf-cfrg-hash-to-curve-16\n */ function mapToCurveSimpleSWU(Fp, opts) {\n    mod.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z)) throw new Error(\"mapToCurveSimpleSWU: invalid opts\");\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd) throw new Error(\"Fp.isOdd is not implemented!\");\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u)=>{\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return {\n            x,\n            y\n        };\n    };\n}\nexports.mapToCurveSimpleSWU = mapToCurveSimpleSWU; //# sourceMappingURL=weierstrass.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwyQkFBMkIsR0FBR0Esc0JBQXNCLEdBQUdBLG1CQUFtQixHQUFHQSx5QkFBeUIsR0FBR0EsV0FBVyxHQUFHLEtBQUs7QUFDNUgsb0VBQW9FLEdBQ3BFLDREQUE0RDtBQUM1RCxNQUFNTyxNQUFNQyxtQkFBT0EsQ0FBQywrR0FBYztBQUNsQyxNQUFNQyxLQUFLRCxtQkFBT0EsQ0FBQywyR0FBWTtBQUMvQixNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQywyR0FBWTtBQUN2QyxNQUFNRyxhQUFhSCxtQkFBT0EsQ0FBQywyR0FBWTtBQUN2QyxTQUFTSSxrQkFBa0JDLEtBQUs7SUFDNUIsTUFBTUMsT0FBTyxDQUFDLEdBQUdILFdBQVdJLGFBQWEsRUFBRUY7SUFDM0NKLEdBQUdPLGNBQWMsQ0FBQ0YsTUFBTTtRQUNwQkcsR0FBRztRQUNIQyxHQUFHO0lBQ1AsR0FBRztRQUNDQywwQkFBMEI7UUFDMUJDLGdCQUFnQjtRQUNoQkMsZUFBZTtRQUNmQyxlQUFlO1FBQ2ZDLG9CQUFvQjtRQUNwQkMsV0FBVztRQUNYQyxTQUFTO0lBQ2I7SUFDQSxNQUFNLEVBQUVDLElBQUksRUFBRUMsRUFBRSxFQUFFVixDQUFDLEVBQUUsR0FBR0g7SUFDeEIsSUFBSVksTUFBTTtRQUNOLElBQUksQ0FBQ0MsR0FBR0MsR0FBRyxDQUFDWCxHQUFHVSxHQUFHRSxJQUFJLEdBQUc7WUFDckIsTUFBTSxJQUFJQyxNQUFNO1FBQ3BCO1FBQ0EsSUFBSSxPQUFPSixTQUFTLFlBQ2hCLE9BQU9BLEtBQUtLLElBQUksS0FBSyxZQUNyQixPQUFPTCxLQUFLTSxXQUFXLEtBQUssWUFBWTtZQUN4QyxNQUFNLElBQUlGLE1BQU07UUFD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TCxPQUFPbFMsR0FBR2tILEtBQUssQ0FBQ3pELElBQUksK0JBQStCO1FBQ3ZFQSxJQUFJekQsR0FBR3lTLElBQUksQ0FBQ3pTLEdBQUc2SCxHQUFHLENBQUNwRSxJQUFJQSxHQUFHa1AsS0FBSyw0QkFBNEI7UUFDM0RuUCxJQUFJeEQsR0FBR2lULEdBQUcsQ0FBQ3pQLEdBQUcrTyxNQUFNLG9CQUFvQjtRQUN4QyxPQUFPO1lBQUUvTztZQUFHQztRQUFFO0lBQ2xCO0FBQ0o7QUFDQXBGLDJCQUEyQixHQUFHRSxxQkFDOUIsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcz82ODNiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5tYXBUb0N1cnZlU2ltcGxlU1dVID0gZXhwb3J0cy5TV1VGcFNxcnRSYXRpbyA9IGV4cG9ydHMud2VpZXJzdHJhc3MgPSBleHBvcnRzLndlaWVyc3RyYXNzUG9pbnRzID0gZXhwb3J0cy5ERVIgPSB2b2lkIDA7XG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBTaG9ydCBXZWllcnN0cmFzcyBjdXJ2ZS4gVGhlIGZvcm11bGEgaXM6IHnCsiA9IHjCsyArIGF4ICsgYlxuY29uc3QgbW9kID0gcmVxdWlyZShcIi4vbW9kdWxhci5qc1wiKTtcbmNvbnN0IHV0ID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG5jb25zdCBjdXJ2ZV9qc18xID0gcmVxdWlyZShcIi4vY3VydmUuanNcIik7XG5mdW5jdGlvbiB2YWxpZGF0ZVBvaW50T3B0cyhjdXJ2ZSkge1xuICAgIGNvbnN0IG9wdHMgPSAoMCwgY3VydmVfanNfMS52YWxpZGF0ZUJhc2ljKShjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBhOiAnZmllbGQnLFxuICAgICAgICBiOiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiAnYXJyYXknLFxuICAgICAgICB3cmFwUHJpdmF0ZUtleTogJ2Jvb2xlYW4nLFxuICAgICAgICBpc1RvcnNpb25GcmVlOiAnZnVuY3Rpb24nLFxuICAgICAgICBjbGVhckNvZmFjdG9yOiAnZnVuY3Rpb24nLFxuICAgICAgICBhbGxvd0luZmluaXR5UG9pbnQ6ICdib29sZWFuJyxcbiAgICAgICAgZnJvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICB0b0J5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgZW5kbywgRnAsIGEgfSA9IG9wdHM7XG4gICAgaWYgKGVuZG8pIHtcbiAgICAgICAgaWYgKCFGcC5lcWwoYSwgRnAuWkVSTykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5kb21vcnBoaXNtIGNhbiBvbmx5IGJlIGRlZmluZWQgZm9yIEtvYmxpdHogY3VydmVzIHRoYXQgaGF2ZSBhPTAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVuZG8gIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZW5kby5iZXRhICE9PSAnYmlnaW50JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uc3BsaXRTY2FsYXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgZW5kb21vcnBoaXNtIHdpdGggYmV0YTogYmlnaW50IGFuZCBzcGxpdFNjYWxhcjogZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLm9wdHMgfSk7XG59XG4vLyBBU04uMSBERVIgZW5jb2RpbmcgdXRpbGl0aWVzXG5jb25zdCB7IGJ5dGVzVG9OdW1iZXJCRTogYjJuLCBoZXhUb0J5dGVzOiBoMmIgfSA9IHV0O1xuZXhwb3J0cy5ERVIgPSB7XG4gICAgLy8gYXNuLjEgREVSIGVuY29kaW5nIHV0aWxzXG4gICAgRXJyOiBjbGFzcyBERVJFcnIgZXh0ZW5kcyBFcnJvciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG0gPSAnJykge1xuICAgICAgICAgICAgc3VwZXIobSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIF9wYXJzZUludChkYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBleHBvcnRzLkRFUjtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgMiB8fCBkYXRhWzBdICE9PSAweDAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXIgdGFnJyk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGFbMV07XG4gICAgICAgIGNvbnN0IHJlcyA9IGRhdGEuc3ViYXJyYXkoMiwgbGVuICsgMik7XG4gICAgICAgIGlmICghbGVuIHx8IHJlcy5sZW5ndGggIT09IGxlbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB3cm9uZyBsZW5ndGgnKTtcbiAgICAgICAgLy8gaHR0cHM6Ly9jcnlwdG8uc3RhY2tleGNoYW5nZS5jb20vYS81NzczNCBMZWZ0bW9zdCBiaXQgb2YgZmlyc3QgYnl0ZSBpcyAnbmVnYXRpdmUnIGZsYWcsXG4gICAgICAgIC8vIHNpbmNlIHdlIGFsd2F5cyB1c2UgcG9zaXRpdmUgaW50ZWdlcnMgaGVyZS4gSXQgbXVzdCBhbHdheXMgYmUgZW1wdHk6XG4gICAgICAgIC8vIC0gYWRkIHplcm8gYnl0ZSBpZiBleGlzdHNcbiAgICAgICAgLy8gLSBpZiBuZXh0IGJ5dGUgZG9lc24ndCBoYXZlIGEgZmxhZywgbGVhZGluZyB6ZXJvIGlzIG5vdCBhbGxvd2VkIChtaW5pbWFsIGVuY29kaW5nKVxuICAgICAgICBpZiAocmVzWzBdICYgMGIxMDAwMDAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiBuZWdhdGl2ZScpO1xuICAgICAgICBpZiAocmVzWzBdID09PSAweDAwICYmICEocmVzWzFdICYgMGIxMDAwMDAwMCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogdW5uZWNlc3NhcnkgbGVhZGluZyB6ZXJvJyk7XG4gICAgICAgIHJldHVybiB7IGQ6IGIybihyZXMpLCBsOiBkYXRhLnN1YmFycmF5KGxlbiArIDIpIH07IC8vIGQgaXMgZGF0YSwgbCBpcyBsZWZ0XG4gICAgfSxcbiAgICB0b1NpZyhoZXgpIHtcbiAgICAgICAgLy8gcGFyc2UgREVSIHNpZ25hdHVyZVxuICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gZXhwb3J0cy5ERVI7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0eXBlb2YgaGV4ID09PSAnc3RyaW5nJyA/IGgyYihoZXgpIDogaGV4O1xuICAgICAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VpOGEgZXhwZWN0ZWQnKTtcbiAgICAgICAgbGV0IGwgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgaWYgKGwgPCAyIHx8IGRhdGFbMF0gIT0gMHgzMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSB0YWcnKTtcbiAgICAgICAgaWYgKGRhdGFbMV0gIT09IGwgLSAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlOiBpbmNvcnJlY3QgbGVuZ3RoJyk7XG4gICAgICAgIGNvbnN0IHsgZDogciwgbDogc0J5dGVzIH0gPSBleHBvcnRzLkRFUi5fcGFyc2VJbnQoZGF0YS5zdWJhcnJheSgyKSk7XG4gICAgICAgIGNvbnN0IHsgZDogcywgbDogckJ5dGVzTGVmdCB9ID0gZXhwb3J0cy5ERVIuX3BhcnNlSW50KHNCeXRlcyk7XG4gICAgICAgIGlmIChyQnl0ZXNMZWZ0Lmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG4gICAgICAgIHJldHVybiB7IHIsIHMgfTtcbiAgICB9LFxuICAgIGhleEZyb21TaWcoc2lnKSB7XG4gICAgICAgIC8vIEFkZCBsZWFkaW5nIHplcm8gaWYgZmlyc3QgYnl0ZSBoYXMgbmVnYXRpdmUgYml0IGVuYWJsZWQuIE1vcmUgZGV0YWlscyBpbiAnX3BhcnNlSW50J1xuICAgICAgICBjb25zdCBzbGljZSA9IChzKSA9PiAoTnVtYmVyLnBhcnNlSW50KHNbMF0sIDE2KSAmIDBiMTAwMCA/ICcwMCcgKyBzIDogcyk7XG4gICAgICAgIGNvbnN0IGggPSAobnVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzID0gc2xpY2UoaChzaWcucykpO1xuICAgICAgICBjb25zdCByID0gc2xpY2UoaChzaWcucikpO1xuICAgICAgICBjb25zdCBzaGwgPSBzLmxlbmd0aCAvIDI7XG4gICAgICAgIGNvbnN0IHJobCA9IHIubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3Qgc2wgPSBoKHNobCk7XG4gICAgICAgIGNvbnN0IHJsID0gaChyaGwpO1xuICAgICAgICByZXR1cm4gYDMwJHtoKHJobCArIHNobCArIDQpfTAyJHtybH0ke3J9MDIke3NsfSR7c31gO1xuICAgIH0sXG59O1xuLy8gQmUgZnJpZW5kbHkgdG8gYmFkIEVDTUFTY3JpcHQgcGFyc2VycyBieSBub3QgdXNpbmcgYmlnaW50IGxpdGVyYWxzXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKSwgXzRuID0gQmlnSW50KDQpO1xuZnVuY3Rpb24gd2VpZXJzdHJhc3NQb2ludHMob3B0cykge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVQb2ludE9wdHMob3B0cyk7XG4gICAgY29uc3QgeyBGcCB9ID0gQ1VSVkU7IC8vIEFsbCBjdXJ2ZXMgaGFzIHNhbWUgZmllbGQgLyBncm91cCBsZW5ndGggYXMgZm9yIG5vdywgYnV0IHRoZXkgY2FuIGRpZmZlclxuICAgIGNvbnN0IHRvQnl0ZXMgPSBDVVJWRS50b0J5dGVzIHx8XG4gICAgICAgICgoYywgcG9pbnQsIGlzQ29tcHJlc3NlZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICAgICAgICByZXR1cm4gdXQuY29uY2F0Qnl0ZXMoVWludDhBcnJheS5mcm9tKFsweDA0XSksIEZwLnRvQnl0ZXMoYS54KSwgRnAudG9CeXRlcyhhLnkpKTtcbiAgICAgICAgfSk7XG4gICAgY29uc3QgZnJvbUJ5dGVzID0gQ1VSVkUuZnJvbUJ5dGVzIHx8XG4gICAgICAgICgoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIC8vIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgIC8vIGlmIChoZWFkICE9PSAweDA0KSB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgbm9uLWNvbXByZXNzZWQgZW5jb2RpbmcgaXMgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICBjb25zdCB4ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoMCwgRnAuQllURVMpKTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheShGcC5CWVRFUywgMiAqIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgIH0pO1xuICAgIC8qKlxuICAgICAqIHnCsiA9IHjCsyArIGF4ICsgYjogU2hvcnQgd2VpZXJzdHJhc3MgY3VydmUgZm9ybXVsYVxuICAgICAqIEByZXR1cm5zIHnCslxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdlaWVyc3RyYXNzRXF1YXRpb24oeCkge1xuICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICBjb25zdCB4MiA9IEZwLnNxcih4KTsgLy8geCAqIHhcbiAgICAgICAgY29uc3QgeDMgPSBGcC5tdWwoeDIsIHgpOyAvLyB4MiAqIHhcbiAgICAgICAgcmV0dXJuIEZwLmFkZChGcC5hZGQoeDMsIEZwLm11bCh4LCBhKSksIGIpOyAvLyB4MyArIGEgKiB4ICsgYlxuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSB3aGV0aGVyIHRoZSBwYXNzZWQgY3VydmUgcGFyYW1zIGFyZSB2YWxpZC5cbiAgICAvLyBXZSBjaGVjayBpZiBjdXJ2ZSBlcXVhdGlvbiB3b3JrcyBmb3IgZ2VuZXJhdG9yIHBvaW50LlxuICAgIC8vIGBhc3NlcnRWYWxpZGl0eSgpYCB3b24ndCB3b3JrOiBgaXNUb3JzaW9uRnJlZSgpYCBpcyBub3QgYXZhaWxhYmxlIGF0IHRoaXMgcG9pbnQgaW4gYmxzMTItMzgxLlxuICAgIC8vIFByb2plY3RpdmVQb2ludCBjbGFzcyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0LlxuICAgIGlmICghRnAuZXFsKEZwLnNxcihDVVJWRS5HeSksIHdlaWVyc3RyYXNzRXF1YXRpb24oQ1VSVkUuR3gpKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgZ2VuZXJhdG9yIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgLy8gVmFsaWQgZ3JvdXAgZWxlbWVudHMgcmVzaWRlIGluIHJhbmdlIDEuLm4tMVxuICAgIGZ1bmN0aW9uIGlzV2l0aGluQ3VydmVPcmRlcihudW0pIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBudW0gPT09ICdiaWdpbnQnICYmIF8wbiA8IG51bSAmJiBudW0gPCBDVVJWRS5uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc3NlcnRHRShudW0pIHtcbiAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIobnVtKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdmFsaWQgYmlnaW50OiAwIDwgYmlnaW50IDwgY3VydmUubicpO1xuICAgIH1cbiAgICAvLyBWYWxpZGF0ZXMgaWYgcHJpdiBrZXkgaXMgdmFsaWQgYW5kIGNvbnZlcnRzIGl0IHRvIGJpZ2ludC5cbiAgICAvLyBTdXBwb3J0cyBvcHRpb25zIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RocyBhbmQgd3JhcFByaXZhdGVLZXkuXG4gICAgZnVuY3Rpb24gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihrZXkpIHtcbiAgICAgICAgY29uc3QgeyBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6IGxlbmd0aHMsIG5CeXRlTGVuZ3RoLCB3cmFwUHJpdmF0ZUtleSwgbiB9ID0gQ1VSVkU7XG4gICAgICAgIGlmIChsZW5ndGhzICYmIHR5cGVvZiBrZXkgIT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICBpZiAoa2V5IGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgICAgICAgICBrZXkgPSB1dC5ieXRlc1RvSGV4KGtleSk7XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgdG8gaGV4IHN0cmluZywgcGFkLiBFLmcuIFA1MjEgd291bGQgbm9ybSAxMzAtMTMyIGNoYXIgaGV4IHRvIDEzMi1jaGFyIGJ5dGVzXG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycgfHwgIWxlbmd0aHMuaW5jbHVkZXMoa2V5Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleScpO1xuICAgICAgICAgICAga2V5ID0ga2V5LnBhZFN0YXJ0KG5CeXRlTGVuZ3RoICogMiwgJzAnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbnVtO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbnVtID1cbiAgICAgICAgICAgICAgICB0eXBlb2Yga2V5ID09PSAnYmlnaW50J1xuICAgICAgICAgICAgICAgICAgICA/IGtleVxuICAgICAgICAgICAgICAgICAgICA6IHV0LmJ5dGVzVG9OdW1iZXJCRSgoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ3ByaXZhdGUga2V5Jywga2V5LCBuQnl0ZUxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcml2YXRlIGtleSBtdXN0IGJlICR7bkJ5dGVMZW5ndGh9IGJ5dGVzLCBoZXggb3IgYmlnaW50LCBub3QgJHt0eXBlb2Yga2V5fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3cmFwUHJpdmF0ZUtleSlcbiAgICAgICAgICAgIG51bSA9IG1vZC5tb2QobnVtLCBuKTsgLy8gZGlzYWJsZWQgYnkgZGVmYXVsdCwgZW5hYmxlZCBmb3IgQkxTXG4gICAgICAgIGFzc2VydEdFKG51bSk7IC8vIG51bSBpbiByYW5nZSBbMS4uTi0xXVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIH1cbiAgICBjb25zdCBwb2ludFByZWNvbXB1dGVzID0gbmV3IE1hcCgpO1xuICAgIGZ1bmN0aW9uIGFzc2VydFByalBvaW50KG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUG9pbnQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9qZWN0aXZlUG9pbnQgZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvamVjdGl2ZSBQb2ludCB3b3JrcyBpbiAzZCAvIHByb2plY3RpdmUgKGhvbW9nZW5lb3VzKSBjb29yZGluYXRlczogKHgsIHksIHopIOKIiyAoeD14L3osIHk9eS96KVxuICAgICAqIERlZmF1bHQgUG9pbnQgd29ya3MgaW4gMmQgLyBhZmZpbmUgY29vcmRpbmF0ZXM6ICh4LCB5KVxuICAgICAqIFdlJ3JlIGRvaW5nIGNhbGN1bGF0aW9ucyBpbiBwcm9qZWN0aXZlLCBiZWNhdXNlIGl0cyBvcGVyYXRpb25zIGRvbid0IHJlcXVpcmUgY29zdGx5IGludmVyc2lvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBQb2ludCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHB4LCBweSwgcHopIHtcbiAgICAgICAgICAgIHRoaXMucHggPSBweDtcbiAgICAgICAgICAgIHRoaXMucHkgPSBweTtcbiAgICAgICAgICAgIHRoaXMucHogPSBwejtcbiAgICAgICAgICAgIGlmIChweCA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB4KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ggcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmIChweSA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3kgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmIChweiA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB6KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ogcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEb2VzIG5vdCB2YWxpZGF0ZSBpZiB0aGUgcG9pbnQgaXMgb24tY3VydmUuXG4gICAgICAgIC8vIFVzZSBmcm9tSGV4IGluc3RlYWQsIG9yIGNhbGwgYXNzZXJ0VmFsaWRpdHkoKSBsYXRlci5cbiAgICAgICAgc3RhdGljIGZyb21BZmZpbmUocCkge1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBwIHx8IHt9O1xuICAgICAgICAgICAgaWYgKCFwIHx8ICFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhZmZpbmUgcG9pbnQnKTtcbiAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm9qZWN0aXZlIHBvaW50IG5vdCBhbGxvd2VkJyk7XG4gICAgICAgICAgICBjb25zdCBpczAgPSAoaSkgPT4gRnAuZXFsKGksIEZwLlpFUk8pO1xuICAgICAgICAgICAgLy8gZnJvbUFmZmluZSh4OjAsIHk6MCkgd291bGQgcHJvZHVjZSAoeDowLCB5OjAsIHo6MSksIGJ1dCB3ZSBuZWVkICh4OjAsIHk6MSwgejowKVxuICAgICAgICAgICAgaWYgKGlzMCh4KSAmJiBpczAoeSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBvaW50LlpFUk87XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHgsIHksIEZwLk9ORSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLng7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLnk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRha2VzIGEgYnVuY2ggb2YgUHJvamVjdGl2ZSBQb2ludHMgYnV0IGV4ZWN1dGVzIG9ubHkgb25lXG4gICAgICAgICAqIGludmVyc2lvbiBvbiBhbGwgb2YgdGhlbS4gSW52ZXJzaW9uIGlzIHZlcnkgc2xvdyBvcGVyYXRpb24sXG4gICAgICAgICAqIHNvIHRoaXMgaW1wcm92ZXMgcGVyZm9ybWFuY2UgbWFzc2l2ZWx5LlxuICAgICAgICAgKiBPcHRpbWl6YXRpb246IGNvbnZlcnRzIGEgbGlzdCBvZiBwcm9qZWN0aXZlIHBvaW50cyB0byBhIGxpc3Qgb2YgaWRlbnRpY2FsIHBvaW50cyB3aXRoIFo9MS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBub3JtYWxpemVaKHBvaW50cykge1xuICAgICAgICAgICAgY29uc3QgdG9JbnYgPSBGcC5pbnZlcnRCYXRjaChwb2ludHMubWFwKChwKSA9PiBwLnB6KSk7XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzLm1hcCgocCwgaSkgPT4gcC50b0FmZmluZSh0b0ludltpXSkpLm1hcChQb2ludC5mcm9tQWZmaW5lKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgaGFzaCBzdHJpbmcgb3IgVWludDhBcnJheSB0byBQb2ludC5cbiAgICAgICAgICogQHBhcmFtIGhleCBzaG9ydC9sb25nIEVDRFNBIGhleFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCBQID0gUG9pbnQuZnJvbUFmZmluZShmcm9tQnl0ZXMoKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdwb2ludEhleCcsIGhleCkpKTtcbiAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQO1xuICAgICAgICB9XG4gICAgICAgIC8vIE11bHRpcGxpZXMgZ2VuZXJhdG9yIHBvaW50IGJ5IHByaXZhdGVLZXkuXG4gICAgICAgIHN0YXRpYyBmcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gUG9pbnQuQkFTRS5tdWx0aXBseShub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBcIlByaXZhdGUgbWV0aG9kXCIsIGRvbid0IHVzZSBpdCBkaXJlY3RseVxuICAgICAgICBfc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9XSU5ET1dfU0laRSA9IHdpbmRvd1NpemU7XG4gICAgICAgICAgICBwb2ludFByZWNvbXB1dGVzLmRlbGV0ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBIHBvaW50IG9uIGN1cnZlIGlzIHZhbGlkIGlmIGl0IGNvbmZvcm1zIHRvIGVxdWF0aW9uLlxuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgICAgIC8vIFplcm8gaXMgdmFsaWQgcG9pbnQgdG9vIVxuICAgICAgICAgICAgaWYgKHRoaXMuaXMwKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoQ1VSVkUuYWxsb3dJbmZpbml0eVBvaW50KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IFpFUk8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNvbWUgM3JkLXBhcnR5IHRlc3QgdmVjdG9ycyByZXF1aXJlIGRpZmZlcmVudCB3b3JkaW5nIGJldHdlZW4gaGVyZSAmIGBmcm9tQ29tcHJlc3NlZEhleGBcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgeCwgeSBhcmUgdmFsaWQgZmllbGQgZWxlbWVudHNcbiAgICAgICAgICAgIGlmICghRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogeCBvciB5IG5vdCBGRScpO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IEZwLnNxcih5KTsgLy8gecKyXG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHdlaWVyc3RyYXNzRXF1YXRpb24oeCk7IC8vIHjCsyArIGF4ICsgYlxuICAgICAgICAgICAgaWYgKCFGcC5lcWwobGVmdCwgcmlnaHQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNUb3JzaW9uRnJlZSgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBub3QgaW4gcHJpbWUtb3JkZXIgc3ViZ3JvdXAnKTtcbiAgICAgICAgfVxuICAgICAgICBoYXNFdmVuWSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgaWYgKEZwLmlzT2RkKVxuICAgICAgICAgICAgICAgIHJldHVybiAhRnAuaXNPZGQoeSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IHN1cHBvcnQgaXNPZGRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBhcmUgb25lIHBvaW50IHRvIGFub3RoZXIuXG4gICAgICAgICAqL1xuICAgICAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBjb25zdCBVMSA9IEZwLmVxbChGcC5tdWwoWDEsIFoyKSwgRnAubXVsKFgyLCBaMSkpO1xuICAgICAgICAgICAgY29uc3QgVTIgPSBGcC5lcWwoRnAubXVsKFkxLCBaMiksIEZwLm11bChZMiwgWjEpKTtcbiAgICAgICAgICAgIHJldHVybiBVMSAmJiBVMjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmxpcHMgcG9pbnQgdG8gb25lIGNvcnJlc3BvbmRpbmcgdG8gKHgsIC15KSBpbiBBZmZpbmUgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBuZWdhdGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMucHgsIEZwLm5lZyh0aGlzLnB5KSwgdGhpcy5weik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGRvdWJsaW5nIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gM1xuICAgICAgICAvLyBDb3N0OiA4TSArIDNTICsgMyphICsgMipiMyArIDE1YWRkLlxuICAgICAgICBkb3VibGUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoYiwgXzNuKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDEpOyAvLyBzdGVwIDFcbiAgICAgICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMSk7XG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5tdWwoWDEsIFkxKTtcbiAgICAgICAgICAgIHQzID0gRnAuYWRkKHQzLCB0Myk7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgWjMgPSBGcC5tdWwoWDEsIFoxKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChhLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChiMywgdDIpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWDMsIFkzKTsgLy8gc3RlcCAxMFxuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFkzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWTMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKGIzLCBaMyk7IC8vIHN0ZXAgMTVcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQwLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLm11bChhLCB0Myk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgdDAgPSBGcC5hZGQoWjMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MCwgdDMpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKFkxLCBaMSk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQyID0gRnAuYWRkKHQyLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MiwgdDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQyLCB0MSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpOyAvLyBzdGVwIDMwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgYWRkaXRpb24gZm9ybXVsYS5cbiAgICAgICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAxXG4gICAgICAgIC8vIENvc3Q6IDEyTSArIDBTICsgMyphICsgMypiMyArIDIzYWRkLlxuICAgICAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBhID0gQ1VSVkUuYTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKENVUlZFLmIsIF8zbik7XG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgyKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkyKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjIpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAuYWRkKFgxLCBZMSk7XG4gICAgICAgICAgICBsZXQgdDQgPSBGcC5hZGQoWDIsIFkyKTsgLy8gc3RlcCA1XG4gICAgICAgICAgICB0MyA9IEZwLm11bCh0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDAsIHQxKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQzLCB0NCk7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZChYMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQ1ID0gRnAuYWRkKFgyLCBaMik7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5zdWIodDQsIHQ1KTtcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKFkxLCBaMSk7XG4gICAgICAgICAgICBYMyA9IEZwLmFkZChZMiwgWjIpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0NSA9IEZwLm11bCh0NSwgWDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQ1ID0gRnAuc3ViKHQ1LCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChhLCB0NCk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChiMywgdDIpOyAvLyBzdGVwIDIwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChYMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQxLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWjMpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyNVxuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKGIzLCB0NCk7XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MSwgdDIpO1xuICAgICAgICAgICAgdDIgPSBGcC5zdWIodDAsIHQyKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDQsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQxLCB0NCk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDUsIHQ0KTsgLy8gc3RlcCAzNVxuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MywgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwodDUsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCB0MCk7IC8vIHN0ZXAgNDBcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaXMwKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKFBvaW50LlpFUk8pO1xuICAgICAgICB9XG4gICAgICAgIHdOQUYobikge1xuICAgICAgICAgICAgcmV0dXJuIHduYWYud05BRkNhY2hlZCh0aGlzLCBwb2ludFByZWNvbXB1dGVzLCBuLCAoY29tcCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvSW52ID0gRnAuaW52ZXJ0QmF0Y2goY29tcC5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcC5tYXAoKHAsIGkpID0+IHAudG9BZmZpbmUodG9JbnZbaV0pKS5tYXAoUG9pbnQuZnJvbUFmZmluZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTm9uLWNvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uIFVzZXMgZG91YmxlLWFuZC1hZGQgYWxnb3JpdGhtLlxuICAgICAgICAgKiBJdCdzIGZhc3RlciwgYnV0IHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiB5b3UgZG9uJ3QgY2FyZSBhYm91dFxuICAgICAgICAgKiBhbiBleHBvc2VkIHByaXZhdGUga2V5IGUuZy4gc2lnIHZlcmlmaWNhdGlvbiwgd2hpY2ggd29ya3Mgb3ZlciAqcHVibGljKiBrZXlzLlxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlVbnNhZmUobikge1xuICAgICAgICAgICAgY29uc3QgSSA9IFBvaW50LlpFUk87XG4gICAgICAgICAgICBpZiAobiA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybiBJO1xuICAgICAgICAgICAgYXNzZXJ0R0Uobik7IC8vIFdpbGwgdGhyb3cgb24gMFxuICAgICAgICAgICAgaWYgKG4gPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbyB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoIWVuZG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHduYWYudW5zYWZlTGFkZGVyKHRoaXMsIG4pO1xuICAgICAgICAgICAgLy8gQXBwbHkgZW5kb21vcnBoaXNtXG4gICAgICAgICAgICBsZXQgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihuKTtcbiAgICAgICAgICAgIGxldCBrMXAgPSBJO1xuICAgICAgICAgICAgbGV0IGsycCA9IEk7XG4gICAgICAgICAgICBsZXQgZCA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAoazEgPiBfMG4gfHwgazIgPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoazEgJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgaWYgKGsyICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMnAgPSBrMnAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIGsxID4+PSBfMW47XG4gICAgICAgICAgICAgICAgazIgPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrMW5lZylcbiAgICAgICAgICAgICAgICBrMXAgPSBrMXAubmVnYXRlKCk7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazJwID0gazJwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgIHJldHVybiBrMXAuYWRkKGsycCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0YW50IHRpbWUgbXVsdGlwbGljYXRpb24uXG4gICAgICAgICAqIFVzZXMgd05BRiBtZXRob2QuIFdpbmRvd2VkIG1ldGhvZCBtYXkgYmUgMTAlIGZhc3RlcixcbiAgICAgICAgICogYnV0IHRha2VzIDJ4IGxvbmdlciB0byBnZW5lcmF0ZSBhbmQgY29uc3VtZXMgMnggbWVtb3J5LlxuICAgICAgICAgKiBVc2VzIHByZWNvbXB1dGVzIHdoZW4gYXZhaWxhYmxlLlxuICAgICAgICAgKiBVc2VzIGVuZG9tb3JwaGlzbSBmb3IgS29ibGl0eiBjdXJ2ZXMuXG4gICAgICAgICAqIEBwYXJhbSBzY2FsYXIgYnkgd2hpY2ggdGhlIHBvaW50IHdvdWxkIGJlIG11bHRpcGxpZWRcbiAgICAgICAgICogQHJldHVybnMgTmV3IHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgICAgIGFzc2VydEdFKHNjYWxhcik7XG4gICAgICAgICAgICBsZXQgbiA9IHNjYWxhcjtcbiAgICAgICAgICAgIGxldCBwb2ludCwgZmFrZTsgLy8gRmFrZSBwb2ludCBpcyB1c2VkIHRvIGNvbnN0LXRpbWUgbXVsdFxuICAgICAgICAgICAgY29uc3QgeyBlbmRvIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChlbmRvKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihuKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMXAsIGY6IGYxcCB9ID0gdGhpcy53TkFGKGsxKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMnAsIGY6IGYycCB9ID0gdGhpcy53TkFGKGsyKTtcbiAgICAgICAgICAgICAgICBrMXAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMW5lZywgazFwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMm5lZywgazJwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5weCwgZW5kby5iZXRhKSwgazJwLnB5LCBrMnAucHopO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gazFwLmFkZChrMnApO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmMXAuYWRkKGYycCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHAsIGYgfSA9IHRoaXMud05BRihuKTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IHA7XG4gICAgICAgICAgICAgICAgZmFrZSA9IGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgYHpgIGZvciBib3RoIHBvaW50cywgYnV0IHJldHVybiBvbmx5IHJlYWwgb25lXG4gICAgICAgICAgICByZXR1cm4gUG9pbnQubm9ybWFsaXplWihbcG9pbnQsIGZha2VdKVswXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRWZmaWNpZW50bHkgY2FsY3VsYXRlIGBhUCArIGJRYC4gVW5zYWZlLCBjYW4gZXhwb3NlIHByaXZhdGUga2V5LCBpZiB1c2VkIGluY29ycmVjdGx5LlxuICAgICAgICAgKiBOb3QgdXNpbmcgU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHByZWNvbXB1dGF0aW9uIHRhYmxlcyBhcmUgZmFzdGVyLlxuICAgICAgICAgKiBUaGUgdHJpY2sgY291bGQgYmUgdXNlZnVsIGlmIGJvdGggUCBhbmQgUSBhcmUgbm90IEcgKG5vdCBpbiBvdXIgY2FzZSkuXG4gICAgICAgICAqIEByZXR1cm5zIG5vbi16ZXJvIGFmZmluZSBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYikge1xuICAgICAgICAgICAgY29uc3QgRyA9IFBvaW50LkJBU0U7IC8vIE5vIFN0cmF1c3MtU2hhbWlyIHRyaWNrOiB3ZSBoYXZlIDEwJSBmYXN0ZXIgRyBwcmVjb21wdXRlc1xuICAgICAgICAgICAgY29uc3QgbXVsID0gKFAsIGEgLy8gU2VsZWN0IGZhc3RlciBtdWx0aXBseSgpIG1ldGhvZFxuICAgICAgICAgICAgKSA9PiAoYSA9PT0gXzBuIHx8IGEgPT09IF8xbiB8fCAhUC5lcXVhbHMoRykgPyBQLm11bHRpcGx5VW5zYWZlKGEpIDogUC5tdWx0aXBseShhKSk7XG4gICAgICAgICAgICBjb25zdCBzdW0gPSBtdWwodGhpcywgYSkuYWRkKG11bChRLCBiKSk7XG4gICAgICAgICAgICByZXR1cm4gc3VtLmlzMCgpID8gdW5kZWZpbmVkIDogc3VtO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnRzIFByb2plY3RpdmUgcG9pbnQgdG8gYWZmaW5lICh4LCB5KSBjb29yZGluYXRlcy5cbiAgICAgICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgICAgIC8vICh4LCB5LCB6KSDiiIsgKHg9eC96LCB5PXkveilcbiAgICAgICAgdG9BZmZpbmUoaXopIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IHgsIHB5OiB5LCBwejogeiB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IHRoaXMuaXMwKCk7XG4gICAgICAgICAgICAvLyBJZiBpbnZaIHdhcyAwLCB3ZSByZXR1cm4gemVybyBwb2ludC4gSG93ZXZlciB3ZSBzdGlsbCB3YW50IHRvIGV4ZWN1dGVcbiAgICAgICAgICAgIC8vIGFsbCBvcGVyYXRpb25zLCBzbyB3ZSByZXBsYWNlIGludlogd2l0aCBhIHJhbmRvbSBudW1iZXIsIDEuXG4gICAgICAgICAgICBpZiAoaXogPT0gbnVsbClcbiAgICAgICAgICAgICAgICBpeiA9IGlzMCA/IEZwLk9ORSA6IEZwLmludih6KTtcbiAgICAgICAgICAgIGNvbnN0IGF4ID0gRnAubXVsKHgsIGl6KTtcbiAgICAgICAgICAgIGNvbnN0IGF5ID0gRnAubXVsKHksIGl6KTtcbiAgICAgICAgICAgIGNvbnN0IHp6ID0gRnAubXVsKHosIGl6KTtcbiAgICAgICAgICAgIGlmIChpczApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogRnAuWkVSTywgeTogRnAuWkVSTyB9O1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoenosIEZwLk9ORSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZaIHdhcyBpbnZhbGlkJyk7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBheCwgeTogYXkgfTtcbiAgICAgICAgfVxuICAgICAgICBpc1RvcnNpb25GcmVlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgaXNUb3JzaW9uRnJlZSB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gTm8gc3ViZ3JvdXBzLCBhbHdheXMgdG9yc2lvbi1mcmVlXG4gICAgICAgICAgICBpZiAoaXNUb3JzaW9uRnJlZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNUb3JzaW9uRnJlZShQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lzVG9yc2lvbkZyZWUoKSBoYXMgbm90IGJlZW4gZGVjbGFyZWQgZm9yIHRoZSBlbGxpcHRpYyBjdXJ2ZScpO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyQ29mYWN0b3IoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGg6IGNvZmFjdG9yLCBjbGVhckNvZmFjdG9yIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBGYXN0LXBhdGhcbiAgICAgICAgICAgIGlmIChjbGVhckNvZmFjdG9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBjbGVhckNvZmFjdG9yKFBvaW50LCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKENVUlZFLmgpO1xuICAgICAgICB9XG4gICAgICAgIHRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRvQnl0ZXMoUG9pbnQsIHRoaXMsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9IZXgoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmJ5dGVzVG9IZXgodGhpcy50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFBvaW50LkJBU0UgPSBuZXcgUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5LCBGcC5PTkUpO1xuICAgIFBvaW50LlpFUk8gPSBuZXcgUG9pbnQoRnAuWkVSTywgRnAuT05FLCBGcC5aRVJPKTtcbiAgICBjb25zdCBfYml0cyA9IENVUlZFLm5CaXRMZW5ndGg7XG4gICAgY29uc3Qgd25hZiA9ICgwLCBjdXJ2ZV9qc18xLndOQUYpKFBvaW50LCBDVVJWRS5lbmRvID8gTWF0aC5jZWlsKF9iaXRzIC8gMikgOiBfYml0cyk7XG4gICAgLy8gVmFsaWRhdGUgaWYgZ2VuZXJhdG9yIHBvaW50IGlzIG9uIGN1cnZlXG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsXG4gICAgICAgIHdlaWVyc3RyYXNzRXF1YXRpb24sXG4gICAgICAgIGlzV2l0aGluQ3VydmVPcmRlcixcbiAgICB9O1xufVxuZXhwb3J0cy53ZWllcnN0cmFzc1BvaW50cyA9IHdlaWVyc3RyYXNzUG9pbnRzO1xuZnVuY3Rpb24gdmFsaWRhdGVPcHRzKGN1cnZlKSB7XG4gICAgY29uc3Qgb3B0cyA9ICgwLCBjdXJ2ZV9qc18xLnZhbGlkYXRlQmFzaWMpKGN1cnZlKTtcbiAgICB1dC52YWxpZGF0ZU9iamVjdChvcHRzLCB7XG4gICAgICAgIGhhc2g6ICdoYXNoJyxcbiAgICAgICAgaG1hYzogJ2Z1bmN0aW9uJyxcbiAgICAgICAgcmFuZG9tQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgfSwge1xuICAgICAgICBiaXRzMmludDogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYml0czJpbnRfbW9kTjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgbG93UzogJ2Jvb2xlYW4nLFxuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgbG93UzogdHJ1ZSwgLi4ub3B0cyB9KTtcbn1cbmZ1bmN0aW9uIHdlaWVyc3RyYXNzKGN1cnZlRGVmKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB2YWxpZGF0ZU9wdHMoY3VydmVEZWYpO1xuICAgIGNvbnN0IHsgRnAsIG46IENVUlZFX09SREVSIH0gPSBDVVJWRTtcbiAgICBjb25zdCBjb21wcmVzc2VkTGVuID0gRnAuQllURVMgKyAxOyAvLyBlLmcuIDMzIGZvciAzMlxuICAgIGNvbnN0IHVuY29tcHJlc3NlZExlbiA9IDIgKiBGcC5CWVRFUyArIDE7IC8vIGUuZy4gNjUgZm9yIDMyXG4gICAgZnVuY3Rpb24gaXNWYWxpZEZpZWxkRWxlbWVudChudW0pIHtcbiAgICAgICAgcmV0dXJuIF8wbiA8IG51bSAmJiBudW0gPCBGcC5PUkRFUjsgLy8gMCBpcyBiYW5uZWQgc2luY2UgaXQncyBub3QgaW52ZXJ0aWJsZSBGRVxuICAgIH1cbiAgICBmdW5jdGlvbiBtb2ROKGEpIHtcbiAgICAgICAgcmV0dXJuIG1vZC5tb2QoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnZOKGEpIHtcbiAgICAgICAgcmV0dXJuIG1vZC5pbnZlcnQoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICBjb25zdCB7IFByb2plY3RpdmVQb2ludDogUG9pbnQsIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsIHdlaWVyc3RyYXNzRXF1YXRpb24sIGlzV2l0aGluQ3VydmVPcmRlciwgfSA9IHdlaWVyc3RyYXNzUG9pbnRzKHtcbiAgICAgICAgLi4uQ1VSVkUsXG4gICAgICAgIHRvQnl0ZXMoYywgcG9pbnQsIGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgY29uc3QgYSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICAgICAgICBjb25zdCB4ID0gRnAudG9CeXRlcyhhLngpO1xuICAgICAgICAgICAgY29uc3QgY2F0ID0gdXQuY29uY2F0Qnl0ZXM7XG4gICAgICAgICAgICBpZiAoaXNDb21wcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhdChVaW50OEFycmF5LmZyb20oW3BvaW50Lmhhc0V2ZW5ZKCkgPyAweDAyIDogMHgwM10pLCB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFsweDA0XSksIHgsIEZwLnRvQnl0ZXMoYS55KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21CeXRlcyhieXRlcykge1xuICAgICAgICAgICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgLy8gdGhpcy5hc3NlcnRWYWxpZGl0eSgpIGlzIGRvbmUgaW5zaWRlIG9mIGZyb21IZXhcbiAgICAgICAgICAgIGlmIChsZW4gPT09IGNvbXByZXNzZWRMZW4gJiYgKGhlYWQgPT09IDB4MDIgfHwgaGVhZCA9PT0gMHgwMykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gdXQuYnl0ZXNUb051bWJlckJFKHRhaWwpO1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEZpZWxkRWxlbWVudCh4KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBpcyBub3Qgb24gY3VydmUnKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5MiA9IHdlaWVyc3RyYXNzRXF1YXRpb24oeCk7IC8vIHnCsiA9IHjCsyArIGF4ICsgYlxuICAgICAgICAgICAgICAgIGxldCB5ID0gRnAuc3FydCh5Mik7IC8vIHkgPSB5wrIgXiAocCsxKS80XG4gICAgICAgICAgICAgICAgY29uc3QgaXNZT2RkID0gKHkgJiBfMW4pID09PSBfMW47XG4gICAgICAgICAgICAgICAgLy8gRUNEU0FcbiAgICAgICAgICAgICAgICBjb25zdCBpc0hlYWRPZGQgPSAoaGVhZCAmIDEpID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChpc0hlYWRPZGQgIT09IGlzWU9kZClcbiAgICAgICAgICAgICAgICAgICAgeSA9IEZwLm5lZyh5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW4gPT09IHVuY29tcHJlc3NlZExlbiAmJiBoZWFkID09PSAweDA0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvaW50IG9mIGxlbmd0aCAke2xlbn0gd2FzIGludmFsaWQuIEV4cGVjdGVkICR7Y29tcHJlc3NlZExlbn0gY29tcHJlc3NlZCBieXRlcyBvciAke3VuY29tcHJlc3NlZExlbn0gdW5jb21wcmVzc2VkIGJ5dGVzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3QgbnVtVG9OQnl0ZVN0ciA9IChudW0pID0+IHV0LmJ5dGVzVG9IZXgodXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpKTtcbiAgICBmdW5jdGlvbiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIobnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IEhBTEYgPSBDVVJWRV9PUkRFUiA+PiBfMW47XG4gICAgICAgIHJldHVybiBudW1iZXIgPiBIQUxGO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtYWxpemVTKHMpIHtcbiAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSA/IG1vZE4oLXMpIDogcztcbiAgICB9XG4gICAgLy8gc2xpY2UgYnl0ZXMgbnVtXG4gICAgY29uc3Qgc2xjTnVtID0gKGIsIGZyb20sIHRvKSA9PiB1dC5ieXRlc1RvTnVtYmVyQkUoYi5zbGljZShmcm9tLCB0bykpO1xuICAgIC8qKlxuICAgICAqIEVDRFNBIHNpZ25hdHVyZSB3aXRoIGl0cyAociwgcykgcHJvcGVydGllcy4gU3VwcG9ydHMgREVSICYgY29tcGFjdCByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG4gICAgY2xhc3MgU2lnbmF0dXJlIHtcbiAgICAgICAgY29uc3RydWN0b3IociwgcywgcmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIHRoaXMuciA9IHI7XG4gICAgICAgICAgICB0aGlzLnMgPSBzO1xuICAgICAgICAgICAgdGhpcy5yZWNvdmVyeSA9IHJlY292ZXJ5O1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhaXIgKGJ5dGVzIG9mIHIsIGJ5dGVzIG9mIHMpXG4gICAgICAgIHN0YXRpYyBmcm9tQ29tcGFjdChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBDVVJWRS5uQnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGhleCA9ICgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgnY29tcGFjdFNpZ25hdHVyZScsIGhleCwgbCAqIDIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUoc2xjTnVtKGhleCwgMCwgbCksIHNsY051bShoZXgsIGwsIDIgKiBsKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gREVSIGVuY29kZWQgRUNEU0Egc2lnbmF0dXJlXG4gICAgICAgIC8vIGh0dHBzOi8vYml0Y29pbi5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvNTc2NDQvd2hhdC1hcmUtdGhlLXBhcnRzLW9mLWEtYml0Y29pbi10cmFuc2FjdGlvbi1pbnB1dC1zY3JpcHRcbiAgICAgICAgc3RhdGljIGZyb21ERVIoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IGV4cG9ydHMuREVSLnRvU2lnKCgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgnREVSJywgaGV4KSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShyLCBzKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgICAgIC8vIGNhbiB1c2UgYXNzZXJ0R0UgaGVyZVxuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIodGhpcy5yKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3IgbXVzdCBiZSAwIDwgciA8IENVUlZFLm4nKTtcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKHRoaXMucykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzIG11c3QgYmUgMCA8IHMgPCBDVVJWRS5uJyk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkUmVjb3ZlcnlCaXQocmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHRoaXMuciwgdGhpcy5zLCByZWNvdmVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVjb3ZlclB1YmxpY0tleShtc2dIYXNoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHIsIHMsIHJlY292ZXJ5OiByZWMgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTigoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ21zZ0hhc2gnLCBtc2dIYXNoKSk7IC8vIFRydW5jYXRlIGhhc2hcbiAgICAgICAgICAgIGlmIChyZWMgPT0gbnVsbCB8fCAhWzAsIDEsIDIsIDNdLmluY2x1ZGVzKHJlYykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyeSBpZCBpbnZhbGlkJyk7XG4gICAgICAgICAgICBjb25zdCByYWRqID0gcmVjID09PSAyIHx8IHJlYyA9PT0gMyA/IHIgKyBDVVJWRS5uIDogcjtcbiAgICAgICAgICAgIGlmIChyYWRqID49IEZwLk9SREVSKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgMiBvciAzIGludmFsaWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IChyZWMgJiAxKSA9PT0gMCA/ICcwMicgOiAnMDMnO1xuICAgICAgICAgICAgY29uc3QgUiA9IFBvaW50LmZyb21IZXgocHJlZml4ICsgbnVtVG9OQnl0ZVN0cihyYWRqKSk7XG4gICAgICAgICAgICBjb25zdCBpciA9IGludk4ocmFkaik7IC8vIHJeLTFcbiAgICAgICAgICAgIGNvbnN0IHUxID0gbW9kTigtaCAqIGlyKTsgLy8gLWhyXi0xXG4gICAgICAgICAgICBjb25zdCB1MiA9IG1vZE4ocyAqIGlyKTsgLy8gc3JeLTFcbiAgICAgICAgICAgIGNvbnN0IFEgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFIsIHUxLCB1Mik7IC8vIChzcl4tMSlSLShocl4tMSlHID0gLShocl4tMSlHICsgKHNyXi0xKVxuICAgICAgICAgICAgaWYgKCFRKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncG9pbnQgYXQgaW5maW5pZnknKTsgLy8gdW5zYWZlIGlzIGZpbmU6IG5vIHByaXYgZGF0YSBsZWFrZWRcbiAgICAgICAgICAgIFEuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBRO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpZ25hdHVyZXMgc2hvdWxkIGJlIGxvdy1zLCB0byBwcmV2ZW50IG1hbGxlYWJpbGl0eS5cbiAgICAgICAgaGFzSGlnaFMoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHRoaXMucyk7XG4gICAgICAgIH1cbiAgICAgICAgbm9ybWFsaXplUygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc0hpZ2hTKCkgPyBuZXcgU2lnbmF0dXJlKHRoaXMuciwgbW9kTigtdGhpcy5zKSwgdGhpcy5yZWNvdmVyeSkgOiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIERFUi1lbmNvZGVkXG4gICAgICAgIHRvREVSUmF3Qnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdXQuaGV4VG9CeXRlcyh0aGlzLnRvREVSSGV4KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRvREVSSGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuREVSLmhleEZyb21TaWcoeyByOiB0aGlzLnIsIHM6IHRoaXMucyB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYWRkZWQgYnl0ZXMgb2YgciwgdGhlbiBwYWRkZWQgYnl0ZXMgb2Ygc1xuICAgICAgICB0b0NvbXBhY3RSYXdCeXRlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB1dC5oZXhUb0J5dGVzKHRoaXMudG9Db21wYWN0SGV4KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRvQ29tcGFjdEhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1Ub05CeXRlU3RyKHRoaXMucikgKyBudW1Ub05CeXRlU3RyKHRoaXMucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdXRpbHMgPSB7XG4gICAgICAgIGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcjogbm9ybVByaXZhdGVLZXlUb1NjYWxhcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2VzIGNyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSBwcml2YXRlIGtleSBmcm9tIHJhbmRvbSBvZiBzaXplIChuQml0TGVuZ3RoKzY0KVxuICAgICAgICAgKiBhcyBwZXIgRklQUyAxODYgQi40LjEgd2l0aCBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJhbmQgPSBDVVJWRS5yYW5kb21CeXRlcyhGcC5CWVRFUyArIDgpO1xuICAgICAgICAgICAgY29uc3QgbnVtID0gbW9kLmhhc2hUb1ByaXZhdGVTY2FsYXIocmFuZCwgQ1VSVkVfT1JERVIpO1xuICAgICAgICAgICAgcmV0dXJuIHV0Lm51bWJlclRvQnl0ZXNCRShudW0sIENVUlZFLm5CeXRlTGVuZ3RoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgcHJlY29tcHV0ZSB0YWJsZSBmb3IgYW4gYXJiaXRyYXJ5IEVDIHBvaW50LiBNYWtlcyBwb2ludCBcImNhY2hlZFwiLlxuICAgICAgICAgKiBBbGxvd3MgdG8gbWFzc2l2ZWx5IHNwZWVkLXVwIGBwb2ludC5tdWx0aXBseShzY2FsYXIpYC5cbiAgICAgICAgICogQHJldHVybnMgY2FjaGVkIHBvaW50XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGNvbnN0IGZhc3QgPSB1dGlscy5wcmVjb21wdXRlKDgsIFByb2plY3RpdmVQb2ludC5mcm9tSGV4KHNvbWVvbmVzUHViS2V5KSk7XG4gICAgICAgICAqIGZhc3QubXVsdGlwbHkocHJpdktleSk7IC8vIG11Y2ggZmFzdGVyIEVDREggbm93XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUgPSA4LCBwb2ludCA9IFBvaW50LkJBU0UpIHtcbiAgICAgICAgICAgIHBvaW50Ll9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpO1xuICAgICAgICAgICAgcG9pbnQubXVsdGlwbHkoQmlnSW50KDMpKTsgLy8gMyBpcyBhcmJpdHJhcnksIGp1c3QgbmVlZCBhbnkgbnVtYmVyIGhlcmVcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHB1YmxpYyBrZXkgZm9yIGEgcHJpdmF0ZSBrZXkuIENoZWNrcyBmb3IgdmFsaWRpdHkgb2YgdGhlIHByaXZhdGUga2V5LlxuICAgICAqIEBwYXJhbSBwcml2YXRlS2V5IHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICAgKiBAcmV0dXJucyBQdWJsaWMga2V5LCBmdWxsIHdoZW4gaXNDb21wcmVzc2VkPWZhbHNlOyBzaG9ydCB3aGVuIGlzQ29tcHJlc3NlZD10cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHByaXZhdGVLZXksIGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIFBvaW50LmZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVpY2sgYW5kIGRpcnR5IGNoZWNrIGZvciBpdGVtIGJlaW5nIHB1YmxpYyBrZXkuIERvZXMgbm90IHZhbGlkYXRlIGhleCwgb3IgYmVpbmcgb24tY3VydmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQcm9iUHViKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgYXJyID0gaXRlbSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4gICAgICAgIGNvbnN0IHN0ciA9IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJztcbiAgICAgICAgY29uc3QgbGVuID0gKGFyciB8fCBzdHIpICYmIGl0ZW0ubGVuZ3RoO1xuICAgICAgICBpZiAoYXJyKVxuICAgICAgICAgICAgcmV0dXJuIGxlbiA9PT0gY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IDIgKiBjb21wcmVzc2VkTGVuIHx8IGxlbiA9PT0gMiAqIHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVDREggKEVsbGlwdGljIEN1cnZlIERpZmZpZSBIZWxsbWFuKS5cbiAgICAgKiBDb21wdXRlcyBzaGFyZWQgcHVibGljIGtleSBmcm9tIHByaXZhdGUga2V5IGFuZCBwdWJsaWMga2V5LlxuICAgICAqIENoZWNrczogMSkgcHJpdmF0ZSBrZXkgdmFsaWRpdHkgMikgc2hhcmVkIGtleSBpcyBvbi1jdXJ2ZS5cbiAgICAgKiBEb2VzIE5PVCBoYXNoIHRoZSByZXN1bHQuXG4gICAgICogQHBhcmFtIHByaXZhdGVBIHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIHB1YmxpY0IgZGlmZmVyZW50IHB1YmxpYyBrZXlcbiAgICAgKiBAcGFyYW0gaXNDb21wcmVzc2VkIHdoZXRoZXIgdG8gcmV0dXJuIGNvbXBhY3QgKGRlZmF1bHQpLCBvciBmdWxsIGtleVxuICAgICAqIEByZXR1cm5zIHNoYXJlZCBwdWJsaWMga2V5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2hhcmVkU2VjcmV0KHByaXZhdGVBLCBwdWJsaWNCLCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIGlmIChpc1Byb2JQdWIocHJpdmF0ZUEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmcgbXVzdCBiZSBwcml2YXRlIGtleScpO1xuICAgICAgICBpZiAoIWlzUHJvYlB1YihwdWJsaWNCKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2Vjb25kIGFyZyBtdXN0IGJlIHB1YmxpYyBrZXknKTtcbiAgICAgICAgY29uc3QgYiA9IFBvaW50LmZyb21IZXgocHVibGljQik7IC8vIGNoZWNrIGZvciBiZWluZyBvbi1jdXJ2ZVxuICAgICAgICByZXR1cm4gYi5tdWx0aXBseShub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVBKSkudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpO1xuICAgIH1cbiAgICAvLyBSRkM2OTc5OiBlbnN1cmUgRUNEU0EgbXNnIGlzIFggYnl0ZXMgYW5kIDwgTi4gUkZDIHN1Z2dlc3RzIG9wdGlvbmFsIHRydW5jYXRpbmcgdmlhIGJpdHMyb2N0ZXRzLlxuICAgIC8vIEZJUFMgMTg2LTQgNC42IHN1Z2dlc3RzIHRoZSBsZWZ0bW9zdCBtaW4obkJpdExlbiwgb3V0TGVuKSBiaXRzLCB3aGljaCBtYXRjaGVzIGJpdHMyaW50LlxuICAgIC8vIGJpdHMyaW50IGNhbiBwcm9kdWNlIHJlcz5OLCB3ZSBjYW4gZG8gbW9kKHJlcywgTikgc2luY2UgdGhlIGJpdExlbiBpcyB0aGUgc2FtZS5cbiAgICAvLyBpbnQyb2N0ZXRzIGNhbid0IGJlIHVzZWQ7IHBhZHMgc21hbGwgbXNncyB3aXRoIDA6IHVuYWNjZXB0YXRibGUgZm9yIHRydW5jIGFzIHBlciBSRkMgdmVjdG9yc1xuICAgIGNvbnN0IGJpdHMyaW50ID0gQ1VSVkUuYml0czJpbnQgfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICAvLyBGb3IgY3VydmVzIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDA6IGJpdHMyb2N0ZXRzKGJpdHMyb2N0ZXRzKG0pKSAhPT0gYml0czJvY3RldHMobSlcbiAgICAgICAgICAgIC8vIGZvciBzb21lIGNhc2VzLCBzaW5jZSBieXRlcy5sZW5ndGggKiA4IGlzIG5vdCBhY3R1YWwgYml0TGVuZ3RoLlxuICAgICAgICAgICAgY29uc3QgbnVtID0gdXQuYnl0ZXNUb051bWJlckJFKGJ5dGVzKTsgLy8gY2hlY2sgZm9yID09IHU4IGRvbmUgaGVyZVxuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBieXRlcy5sZW5ndGggKiA4IC0gQ1VSVkUubkJpdExlbmd0aDsgLy8gdHJ1bmNhdGUgdG8gbkJpdExlbmd0aCBsZWZ0bW9zdCBiaXRzXG4gICAgICAgICAgICByZXR1cm4gZGVsdGEgPiAwID8gbnVtID4+IEJpZ0ludChkZWx0YSkgOiBudW07XG4gICAgICAgIH07XG4gICAgY29uc3QgYml0czJpbnRfbW9kTiA9IENVUlZFLmJpdHMyaW50X21vZE4gfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kTihiaXRzMmludChieXRlcykpOyAvLyBjYW4ndCB1c2UgYnl0ZXNUb051bWJlckJFIGhlcmVcbiAgICAgICAgfTtcbiAgICAvLyBOT1RFOiBwYWRzIG91dHB1dCB3aXRoIHplcm8gYXMgcGVyIHNwZWNcbiAgICBjb25zdCBPUkRFUl9NQVNLID0gdXQuYml0TWFzayhDVVJWRS5uQml0TGVuZ3RoKTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0byBieXRlcy4gQ2hlY2tzIGlmIG51bSBpbiBgWzAuLk9SREVSX01BU0stMV1gIGUuZy46IGBbMC4uMl4yNTYtMV1gLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludDJvY3RldHMobnVtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmlnaW50IGV4cGVjdGVkJyk7XG4gICAgICAgIGlmICghKF8wbiA8PSBudW0gJiYgbnVtIDwgT1JERVJfTUFTSykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJpZ2ludCBleHBlY3RlZCA8IDJeJHtDVVJWRS5uQml0TGVuZ3RofWApO1xuICAgICAgICAvLyB3b3JrcyB3aXRoIG9yZGVyLCBjYW4gaGF2ZSBkaWZmZXJlbnQgc2l6ZSB0aGFuIG51bVRvRmllbGQhXG4gICAgICAgIHJldHVybiB1dC5udW1iZXJUb0J5dGVzQkUobnVtLCBDVVJWRS5uQnl0ZUxlbmd0aCk7XG4gICAgfVxuICAgIC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjJcbiAgICAvLyBDcmVhdGVzIFJGQzY5Nzkgc2VlZDsgY29udmVydHMgbXNnL3ByaXZLZXkgdG8gbnVtYmVycy5cbiAgICAvLyBVc2VkIG9ubHkgaW4gc2lnbiwgbm90IGluIHZlcmlmeS5cbiAgICAvLyBOT1RFOiB3ZSBjYW5ub3QgYXNzdW1lIGhlcmUgdGhhdCBtc2dIYXNoIGhhcyBzYW1lIGFtb3VudCBvZiBieXRlcyBhcyBjdXJ2ZSBvcmRlciwgdGhpcyB3aWxsIGJlIHdyb25nIGF0IGxlYXN0IGZvciBQNTIxLlxuICAgIC8vIEFsc28gaXQgY2FuIGJlIGJpZ2dlciBmb3IgUDIyNCArIFNIQTI1NlxuICAgIGZ1bmN0aW9uIHByZXBTaWcobXNnSGFzaCwgcHJpdmF0ZUtleSwgb3B0cyA9IGRlZmF1bHRTaWdPcHRzKSB7XG4gICAgICAgIGlmIChbJ3JlY292ZXJlZCcsICdjYW5vbmljYWwnXS5zb21lKChrKSA9PiBrIGluIG9wdHMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduKCkgbGVnYWN5IG9wdGlvbnMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICBjb25zdCB7IGhhc2gsIHJhbmRvbUJ5dGVzIH0gPSBDVVJWRTtcbiAgICAgICAgbGV0IHsgbG93UywgcHJlaGFzaCwgZXh0cmFFbnRyb3B5OiBlbnQgfSA9IG9wdHM7IC8vIGdlbmVyYXRlcyBsb3ctcyBzaWdzIGJ5IGRlZmF1bHRcbiAgICAgICAgaWYgKGxvd1MgPT0gbnVsbClcbiAgICAgICAgICAgIGxvd1MgPSB0cnVlOyAvLyBSRkM2OTc5IDMuMjogd2Ugc2tpcCBzdGVwIEEsIGJlY2F1c2Ugd2UgYWxyZWFkeSBwcm92aWRlIGhhc2hcbiAgICAgICAgbXNnSGFzaCA9ICgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICBpZiAocHJlaGFzaClcbiAgICAgICAgICAgIG1zZ0hhc2ggPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ3ByZWhhc2hlZCBtc2dIYXNoJywgaGFzaChtc2dIYXNoKSk7XG4gICAgICAgIC8vIFdlIGNhbid0IGxhdGVyIGNhbGwgYml0czJvY3RldHMsIHNpbmNlIG5lc3RlZCBiaXRzMmludCBpcyBicm9rZW4gZm9yIGN1cnZlc1xuICAgICAgICAvLyB3aXRoIG5CaXRMZW5ndGggJSA4ICE9PSAwLiBCZWNhdXNlIG9mIHRoYXQsIHdlIHVud3JhcCBpdCBoZXJlIGFzIGludDJvY3RldHMgY2FsbC5cbiAgICAgICAgLy8gY29uc3QgYml0czJvY3RldHMgPSAoYml0cykgPT4gaW50Mm9jdGV0cyhiaXRzMmludF9tb2ROKGJpdHMpKVxuICAgICAgICBjb25zdCBoMWludCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7XG4gICAgICAgIGNvbnN0IGQgPSBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpOyAvLyB2YWxpZGF0ZSBwcml2YXRlIGtleSwgY29udmVydCB0byBiaWdpbnRcbiAgICAgICAgY29uc3Qgc2VlZEFyZ3MgPSBbaW50Mm9jdGV0cyhkKSwgaW50Mm9jdGV0cyhoMWludCldO1xuICAgICAgICAvLyBleHRyYUVudHJvcHkuIFJGQzY5NzkgMy42OiBhZGRpdGlvbmFsIGsnIChvcHRpb25hbCkuXG4gICAgICAgIGlmIChlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSyA9IEhNQUNfSyhWIHx8IDB4MDAgfHwgaW50Mm9jdGV0cyh4KSB8fCBiaXRzMm9jdGV0cyhoMSkgfHwgaycpXG4gICAgICAgICAgICBjb25zdCBlID0gZW50ID09PSB0cnVlID8gcmFuZG9tQnl0ZXMoRnAuQllURVMpIDogZW50OyAvLyBnZW5lcmF0ZSByYW5kb20gYnl0ZXMgT1IgcGFzcyBhcy1pc1xuICAgICAgICAgICAgc2VlZEFyZ3MucHVzaCgoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ2V4dHJhRW50cm9weScsIGUsIEZwLkJZVEVTKSk7IC8vIGNoZWNrIGZvciBiZWluZyBvZiBzaXplIEJZVEVTXG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VlZCA9IHV0LmNvbmNhdEJ5dGVzKC4uLnNlZWRBcmdzKTsgLy8gU3RlcCBEIG9mIFJGQzY5NzkgMy4yXG4gICAgICAgIGNvbnN0IG0gPSBoMWludDsgLy8gTk9URTogbm8gbmVlZCB0byBjYWxsIGJpdHMyaW50IHNlY29uZCB0aW1lIGhlcmUsIGl0IGlzIGluc2lkZSB0cnVuY2F0ZUhhc2ghXG4gICAgICAgIC8vIENvbnZlcnRzIHNpZ25hdHVyZSBwYXJhbXMgaW50byBwb2ludCB3IHIvcywgY2hlY2tzIHJlc3VsdCBmb3IgdmFsaWRpdHkuXG4gICAgICAgIGZ1bmN0aW9uIGsyc2lnKGtCeXRlcykge1xuICAgICAgICAgICAgLy8gUkZDIDY5NzkgU2VjdGlvbiAzLjIsIHN0ZXAgMzogayA9IGJpdHMyaW50KFQpXG4gICAgICAgICAgICBjb25zdCBrID0gYml0czJpbnQoa0J5dGVzKTsgLy8gQ2Fubm90IHVzZSBmaWVsZHMgbWV0aG9kcywgc2luY2UgaXQgaXMgZ3JvdXAgZWxlbWVudFxuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIoaykpXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBJbXBvcnRhbnQ6IGFsbCBtb2QoKSBjYWxscyBoZXJlIG11c3QgYmUgZG9uZSBvdmVyIE5cbiAgICAgICAgICAgIGNvbnN0IGlrID0gaW52TihrKTsgLy8ga14tMSBtb2QgblxuICAgICAgICAgICAgY29uc3QgcSA9IFBvaW50LkJBU0UubXVsdGlwbHkoaykudG9BZmZpbmUoKTsgLy8gcSA9IEdrXG4gICAgICAgICAgICBjb25zdCByID0gbW9kTihxLngpOyAvLyByID0gcS54IG1vZCBuXG4gICAgICAgICAgICBpZiAociA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIENhbiB1c2Ugc2NhbGFyIGJsaW5kaW5nIGJeLTEoYm0gKyBiZHIpIHdoZXJlIGIg4oiIIFsxLHHiiJIxXSBhY2NvcmRpbmcgdG9cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdGNoZXMuaWFjci5vcmcvaW5kZXgucGhwL1RDSEVTL2FydGljbGUvdmlldy83MzM3LzY1MDkuIFdlJ3ZlIGRlY2lkZWQgYWdhaW5zdCBpdDpcbiAgICAgICAgICAgIC8vIGEpIGRlcGVuZGVuY3kgb24gQ1NQUk5HIGIpIDE1JSBzbG93ZG93biBjKSBkb2Vzbid0IHJlYWxseSBoZWxwIHNpbmNlIGJpZ2ludHMgYXJlIG5vdCBDVFxuICAgICAgICAgICAgY29uc3QgcyA9IG1vZE4oaWsgKiBtb2ROKG0gKyByICogZCkpOyAvLyBOb3QgdXNpbmcgYmxpbmRpbmcgaGVyZVxuICAgICAgICAgICAgaWYgKHMgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgcmVjb3ZlcnkgPSAocS54ID09PSByID8gMCA6IDIpIHwgTnVtYmVyKHEueSAmIF8xbik7IC8vIHJlY292ZXJ5IGJpdCAoMiBvciAzLCB3aGVuIHEueCA+IG4pXG4gICAgICAgICAgICBsZXQgbm9ybVMgPSBzO1xuICAgICAgICAgICAgaWYgKGxvd1MgJiYgaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHMpKSB7XG4gICAgICAgICAgICAgICAgbm9ybVMgPSBub3JtYWxpemVTKHMpOyAvLyBpZiBsb3dTIHdhcyBwYXNzZWQsIGVuc3VyZSBzIGlzIGFsd2F5c1xuICAgICAgICAgICAgICAgIHJlY292ZXJ5IF49IDE7IC8vIC8vIGluIHRoZSBib3R0b20gaGFsZiBvZiBOXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShyLCBub3JtUywgcmVjb3ZlcnkpOyAvLyB1c2Ugbm9ybVMsIG5vdCBzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc2VlZCwgazJzaWcgfTtcbiAgICB9XG4gICAgY29uc3QgZGVmYXVsdFNpZ09wdHMgPSB7IGxvd1M6IENVUlZFLmxvd1MsIHByZWhhc2g6IGZhbHNlIH07XG4gICAgY29uc3QgZGVmYXVsdFZlck9wdHMgPSB7IGxvd1M6IENVUlZFLmxvd1MsIHByZWhhc2g6IGZhbHNlIH07XG4gICAgLyoqXG4gICAgICogU2lnbnMgbWVzc2FnZSBoYXNoIHdpdGggYSBwcml2YXRlIGtleS5cbiAgICAgKiBgYGBcbiAgICAgKiBzaWduKG0sIGQsIGspIHdoZXJlXG4gICAgICogICAoeCwgeSkgPSBHIMOXIGtcbiAgICAgKiAgIHIgPSB4IG1vZCBuXG4gICAgICogICBzID0gKG0gKyBkcikvayBtb2QgblxuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBtc2dIYXNoIE5PVCBtZXNzYWdlLiBtc2cgbmVlZHMgdG8gYmUgaGFzaGVkIHRvIGBtc2dIYXNoYCwgb3IgdXNlIGBwcmVoYXNoYC5cbiAgICAgKiBAcGFyYW0gcHJpdktleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBvcHRzIGxvd1MgZm9yIG5vbi1tYWxsZWFibGUgc2lncy4gZXh0cmFFbnRyb3B5IGZvciBtaXhpbmcgcmFuZG9tbmVzcyBpbnRvIGsuIHByZWhhc2ggd2lsbCBoYXNoIGZpcnN0IGFyZy5cbiAgICAgKiBAcmV0dXJucyBzaWduYXR1cmUgd2l0aCByZWNvdmVyeSBwYXJhbVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNpZ24obXNnSGFzaCwgcHJpdktleSwgb3B0cyA9IGRlZmF1bHRTaWdPcHRzKSB7XG4gICAgICAgIGNvbnN0IHsgc2VlZCwgazJzaWcgfSA9IHByZXBTaWcobXNnSGFzaCwgcHJpdktleSwgb3B0cyk7IC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjIuXG4gICAgICAgIGNvbnN0IEMgPSBDVVJWRTtcbiAgICAgICAgY29uc3QgZHJiZyA9IHV0LmNyZWF0ZUhtYWNEcmJnKEMuaGFzaC5vdXRwdXRMZW4sIEMubkJ5dGVMZW5ndGgsIEMuaG1hYyk7XG4gICAgICAgIHJldHVybiBkcmJnKHNlZWQsIGsyc2lnKTsgLy8gU3RlcHMgQiwgQywgRCwgRSwgRiwgR1xuICAgIH1cbiAgICAvLyBFbmFibGUgcHJlY29tcHV0ZXMuIFNsb3dzIGRvd24gZmlyc3QgcHVibGljS2V5IGNvbXB1dGF0aW9uIGJ5IDIwbXMuXG4gICAgUG9pbnQuQkFTRS5fc2V0V2luZG93U2l6ZSg4KTtcbiAgICAvLyB1dGlscy5wcmVjb21wdXRlKDgsIFByb2plY3RpdmVQb2ludC5CQVNFKVxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIGEgc2lnbmF0dXJlIGFnYWluc3QgbWVzc2FnZSBoYXNoIGFuZCBwdWJsaWMga2V5LlxuICAgICAqIFJlamVjdHMgbG93UyBzaWduYXR1cmVzIGJ5IGRlZmF1bHQ6IHRvIG92ZXJyaWRlLFxuICAgICAqIHNwZWNpZnkgb3B0aW9uIGB7bG93UzogZmFsc2V9YC4gSW1wbGVtZW50cyBzZWN0aW9uIDQuMS40IGZyb20gaHR0cHM6Ly93d3cuc2VjZy5vcmcvc2VjMS12Mi5wZGY6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiB2ZXJpZnkociwgcywgaCwgUCkgd2hlcmVcbiAgICAgKiAgIFUxID0gaHNeLTEgbW9kIG5cbiAgICAgKiAgIFUyID0gcnNeLTEgbW9kIG5cbiAgICAgKiAgIFIgPSBVMeKLhUcgLSBVMuKLhVBcbiAgICAgKiAgIG1vZChSLngsIG4pID09IHJcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2ZXJpZnkoc2lnbmF0dXJlLCBtc2dIYXNoLCBwdWJsaWNLZXksIG9wdHMgPSBkZWZhdWx0VmVyT3B0cykge1xuICAgICAgICBjb25zdCBzZyA9IHNpZ25hdHVyZTtcbiAgICAgICAgbXNnSGFzaCA9ICgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICBwdWJsaWNLZXkgPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ3B1YmxpY0tleScsIHB1YmxpY0tleSk7XG4gICAgICAgIGlmICgnc3RyaWN0JyBpbiBvcHRzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zLnN0cmljdCB3YXMgcmVuYW1lZCB0byBsb3dTJyk7XG4gICAgICAgIGNvbnN0IHsgbG93UywgcHJlaGFzaCB9ID0gb3B0cztcbiAgICAgICAgbGV0IF9zaWcgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBQO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZyA9PT0gJ3N0cmluZycgfHwgc2cgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICAgICAgLy8gU2lnbmF0dXJlIGNhbiBiZSByZXByZXNlbnRlZCBpbiAyIHdheXM6IGNvbXBhY3QgKDIqbkJ5dGVMZW5ndGgpICYgREVSICh2YXJpYWJsZS1sZW5ndGgpLlxuICAgICAgICAgICAgICAgIC8vIFNpbmNlIERFUiBjYW4gYWxzbyBiZSAyKm5CeXRlTGVuZ3RoIGJ5dGVzLCB3ZSBjaGVjayBmb3IgaXQgZmlyc3QuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgX3NpZyA9IFNpZ25hdHVyZS5mcm9tREVSKHNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGRlckVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGRlckVycm9yIGluc3RhbmNlb2YgZXhwb3J0cy5ERVIuRXJyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRlckVycm9yO1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21Db21wYWN0KHNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2cgPT09ICdvYmplY3QnICYmIHR5cGVvZiBzZy5yID09PSAnYmlnaW50JyAmJiB0eXBlb2Ygc2cucyA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IHNnO1xuICAgICAgICAgICAgICAgIF9zaWcgPSBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQQVJTRScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUCA9IFBvaW50LmZyb21IZXgocHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlID09PSAnUEFSU0UnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2lnbmF0dXJlIG11c3QgYmUgU2lnbmF0dXJlIGluc3RhbmNlLCBVaW50OEFycmF5IG9yIGhleCBzdHJpbmdgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG93UyAmJiBfc2lnLmhhc0hpZ2hTKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IENVUlZFLmhhc2gobXNnSGFzaCk7XG4gICAgICAgIGNvbnN0IHsgciwgcyB9ID0gX3NpZztcbiAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgY29uc3QgaXMgPSBpbnZOKHMpOyAvLyBzXi0xXG4gICAgICAgIGNvbnN0IHUxID0gbW9kTihoICogaXMpOyAvLyB1MSA9IGhzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IHUyID0gbW9kTihyICogaXMpOyAvLyB1MiA9IHJzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IFIgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFAsIHUxLCB1Mik/LnRvQWZmaW5lKCk7IC8vIFIgPSB1MeKLhUcgKyB1MuKLhVBcbiAgICAgICAgaWYgKCFSKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCB2ID0gbW9kTihSLngpO1xuICAgICAgICByZXR1cm4gdiA9PT0gcjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIGdldFB1YmxpY0tleSxcbiAgICAgICAgZ2V0U2hhcmVkU2VjcmV0LFxuICAgICAgICBzaWduLFxuICAgICAgICB2ZXJpZnksXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIFNpZ25hdHVyZSxcbiAgICAgICAgdXRpbHMsXG4gICAgfTtcbn1cbmV4cG9ydHMud2VpZXJzdHJhc3MgPSB3ZWllcnN0cmFzcztcbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFNoYWxsdWUgYW5kIHZhbiBkZSBXb2VzdGlqbmUgbWV0aG9kIGZvciBhbnkgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBUT0RPOiBjaGVjayBpZiB0aGVyZSBpcyBhIHdheSB0byBtZXJnZSB0aGlzIHdpdGggdXZSYXRpbyBpbiBFZHdhcmRzOyBtb3ZlIHRvIG1vZHVsYXIuXG4gKiBiID0gVHJ1ZSBhbmQgeSA9IHNxcnQodSAvIHYpIGlmICh1IC8gdikgaXMgc3F1YXJlIGluIEYsIGFuZFxuICogYiA9IEZhbHNlIGFuZCB5ID0gc3FydChaICogKHUgLyB2KSkgb3RoZXJ3aXNlLlxuICogQHBhcmFtIEZwXG4gKiBAcGFyYW0gWlxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gU1dVRnBTcXJ0UmF0aW8oRnAsIFopIHtcbiAgICAvLyBHZW5lcmljIGltcGxlbWVudGF0aW9uXG4gICAgY29uc3QgcSA9IEZwLk9SREVSO1xuICAgIGxldCBsID0gXzBuO1xuICAgIGZvciAobGV0IG8gPSBxIC0gXzFuOyBvICUgXzJuID09PSBfMG47IG8gLz0gXzJuKVxuICAgICAgICBsICs9IF8xbjtcbiAgICBjb25zdCBjMSA9IGw7IC8vIDEuIGMxLCB0aGUgbGFyZ2VzdCBpbnRlZ2VyIHN1Y2ggdGhhdCAyXmMxIGRpdmlkZXMgcSAtIDEuXG4gICAgLy8gV2UgbmVlZCAybiAqKiBjMSBhbmQgMm4gKiogKGMxLTEpLiBXZSBjYW4ndCB1c2UgKio7IGJ1dCB3ZSBjYW4gdXNlIDw8LlxuICAgIC8vIDJuICoqIGMxID09IDJuIDw8IChjMS0xKVxuICAgIGNvbnN0IF8ybl9wb3dfYzFfMSA9IF8ybiA8PCAoYzEgLSBfMW4gLSBfMW4pO1xuICAgIGNvbnN0IF8ybl9wb3dfYzEgPSBfMm5fcG93X2MxXzEgKiBfMm47XG4gICAgY29uc3QgYzIgPSAocSAtIF8xbikgLyBfMm5fcG93X2MxOyAvLyAyLiBjMiA9IChxIC0gMSkgLyAoMl5jMSkgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzMgPSAoYzIgLSBfMW4pIC8gXzJuOyAvLyAzLiBjMyA9IChjMiAtIDEpIC8gMiAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzQgPSBfMm5fcG93X2MxIC0gXzFuOyAvLyA0LiBjNCA9IDJeYzEgLSAxICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzUgPSBfMm5fcG93X2MxXzE7IC8vIDUuIGM1ID0gMl4oYzEgLSAxKSAgICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzYgPSBGcC5wb3coWiwgYzIpOyAvLyA2LiBjNiA9IFpeYzJcbiAgICBjb25zdCBjNyA9IEZwLnBvdyhaLCAoYzIgKyBfMW4pIC8gXzJuKTsgLy8gNy4gYzcgPSBaXigoYzIgKyAxKSAvIDIpXG4gICAgbGV0IHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XG4gICAgICAgIGxldCB0djEgPSBjNjsgLy8gMS4gdHYxID0gYzZcbiAgICAgICAgbGV0IHR2MiA9IEZwLnBvdyh2LCBjNCk7IC8vIDIuIHR2MiA9IHZeYzRcbiAgICAgICAgbGV0IHR2MyA9IEZwLnNxcih0djIpOyAvLyAzLiB0djMgPSB0djJeMlxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCB2KTsgLy8gNC4gdHYzID0gdHYzICogdlxuICAgICAgICBsZXQgdHY1ID0gRnAubXVsKHUsIHR2Myk7IC8vIDUuIHR2NSA9IHUgKiB0djNcbiAgICAgICAgdHY1ID0gRnAucG93KHR2NSwgYzMpOyAvLyA2LiB0djUgPSB0djVeYzNcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NSwgdHYyKTsgLy8gNy4gdHY1ID0gdHY1ICogdHYyXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djUsIHYpOyAvLyA4LiB0djIgPSB0djUgKiB2XG4gICAgICAgIHR2MyA9IEZwLm11bCh0djUsIHUpOyAvLyA5LiB0djMgPSB0djUgKiB1XG4gICAgICAgIGxldCB0djQgPSBGcC5tdWwodHYzLCB0djIpOyAvLyAxMC4gdHY0ID0gdHYzICogdHYyXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djQsIGM1KTsgLy8gMTEuIHR2NSA9IHR2NF5jNVxuICAgICAgICBsZXQgaXNRUiA9IEZwLmVxbCh0djUsIEZwLk9ORSk7IC8vIDEyLiBpc1FSID0gdHY1ID09IDFcbiAgICAgICAgdHYyID0gRnAubXVsKHR2MywgYzcpOyAvLyAxMy4gdHYyID0gdHYzICogYzdcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMTQuIHR2NSA9IHR2NCAqIHR2MVxuICAgICAgICB0djMgPSBGcC5jbW92KHR2MiwgdHYzLCBpc1FSKTsgLy8gMTUuIHR2MyA9IENNT1YodHYyLCB0djMsIGlzUVIpXG4gICAgICAgIHR2NCA9IEZwLmNtb3YodHY1LCB0djQsIGlzUVIpOyAvLyAxNi4gdHY0ID0gQ01PVih0djUsIHR2NCwgaXNRUilcbiAgICAgICAgLy8gMTcuIGZvciBpIGluIChjMSwgYzEgLSAxLCAuLi4sIDIpOlxuICAgICAgICBmb3IgKGxldCBpID0gYzE7IGkgPiBfMW47IGktLSkge1xuICAgICAgICAgICAgbGV0IHR2NSA9IGkgLSBfMm47IC8vIDE4LiAgICB0djUgPSBpIC0gMlxuICAgICAgICAgICAgdHY1ID0gXzJuIDw8ICh0djUgLSBfMW4pOyAvLyAxOS4gICAgdHY1ID0gMl50djVcbiAgICAgICAgICAgIGxldCB0dnY1ID0gRnAucG93KHR2NCwgdHY1KTsgLy8gMjAuICAgIHR2NSA9IHR2NF50djVcbiAgICAgICAgICAgIGNvbnN0IGUxID0gRnAuZXFsKHR2djUsIEZwLk9ORSk7IC8vIDIxLiAgICBlMSA9IHR2NSA9PSAxXG4gICAgICAgICAgICB0djIgPSBGcC5tdWwodHYzLCB0djEpOyAvLyAyMi4gICAgdHYyID0gdHYzICogdHYxXG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djEpOyAvLyAyMy4gICAgdHYxID0gdHYxICogdHYxXG4gICAgICAgICAgICB0dnY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMjQuICAgIHR2NSA9IHR2NCAqIHR2MVxuICAgICAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgZTEpOyAvLyAyNS4gICAgdHYzID0gQ01PVih0djIsIHR2MywgZTEpXG4gICAgICAgICAgICB0djQgPSBGcC5jbW92KHR2djUsIHR2NCwgZTEpOyAvLyAyNi4gICAgdHY0ID0gQ01PVih0djUsIHR2NCwgZTEpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHR2MyB9O1xuICAgIH07XG4gICAgaWYgKEZwLk9SREVSICUgXzRuID09PSBfM24pIHtcbiAgICAgICAgLy8gc3FydF9yYXRpb18zbW9kNCh1LCB2KVxuICAgICAgICBjb25zdCBjMSA9IChGcC5PUkRFUiAtIF8zbikgLyBfNG47IC8vIDEuIGMxID0gKHEgLSAzKSAvIDQgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgICAgIGNvbnN0IGMyID0gRnAuc3FydChGcC5uZWcoWikpOyAvLyAyLiBjMiA9IHNxcnQoLVopXG4gICAgICAgIHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XG4gICAgICAgICAgICBsZXQgdHYxID0gRnAuc3FyKHYpOyAvLyAxLiB0djEgPSB2XjJcbiAgICAgICAgICAgIGNvbnN0IHR2MiA9IEZwLm11bCh1LCB2KTsgLy8gMi4gdHYyID0gdSAqIHZcbiAgICAgICAgICAgIHR2MSA9IEZwLm11bCh0djEsIHR2Mik7IC8vIDMuIHR2MSA9IHR2MSAqIHR2MlxuICAgICAgICAgICAgbGV0IHkxID0gRnAucG93KHR2MSwgYzEpOyAvLyA0LiB5MSA9IHR2MV5jMVxuICAgICAgICAgICAgeTEgPSBGcC5tdWwoeTEsIHR2Mik7IC8vIDUuIHkxID0geTEgKiB0djJcbiAgICAgICAgICAgIGNvbnN0IHkyID0gRnAubXVsKHkxLCBjMik7IC8vIDYuIHkyID0geTEgKiBjMlxuICAgICAgICAgICAgY29uc3QgdHYzID0gRnAubXVsKEZwLnNxcih5MSksIHYpOyAvLyA3LiB0djMgPSB5MV4yOyA4LiB0djMgPSB0djMgKiB2XG4gICAgICAgICAgICBjb25zdCBpc1FSID0gRnAuZXFsKHR2MywgdSk7IC8vIDkuIGlzUVIgPSB0djMgPT0gdVxuICAgICAgICAgICAgbGV0IHkgPSBGcC5jbW92KHkyLCB5MSwgaXNRUik7IC8vIDEwLiB5ID0gQ01PVih5MiwgeTEsIGlzUVIpXG4gICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBpc1FSLCB2YWx1ZTogeSB9OyAvLyAxMS4gcmV0dXJuIChpc1FSLCB5KSBpc1FSID8geSA6IHkqYzJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gTm8gY3VydmVzIHVzZXMgdGhhdFxuICAgIC8vIGlmIChGcC5PUkRFUiAlIF84biA9PT0gXzVuKSAvLyBzcXJ0X3JhdGlvXzVtb2Q4XG4gICAgcmV0dXJuIHNxcnRSYXRpbztcbn1cbmV4cG9ydHMuU1dVRnBTcXJ0UmF0aW8gPSBTV1VGcFNxcnRSYXRpbztcbi8qKlxuICogRnJvbSBkcmFmdC1pcnRmLWNmcmctaGFzaC10by1jdXJ2ZS0xNlxuICovXG5mdW5jdGlvbiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCBvcHRzKSB7XG4gICAgbW9kLnZhbGlkYXRlRmllbGQoRnApO1xuICAgIGlmICghRnAuaXNWYWxpZChvcHRzLkEpIHx8ICFGcC5pc1ZhbGlkKG9wdHMuQikgfHwgIUZwLmlzVmFsaWQob3B0cy5aKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlU2ltcGxlU1dVOiBpbnZhbGlkIG9wdHMnKTtcbiAgICBjb25zdCBzcXJ0UmF0aW8gPSBTV1VGcFNxcnRSYXRpbyhGcCwgb3B0cy5aKTtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZwLmlzT2RkIGlzIG5vdCBpbXBsZW1lbnRlZCEnKTtcbiAgICAvLyBJbnB1dDogdSwgYW4gZWxlbWVudCBvZiBGLlxuICAgIC8vIE91dHB1dDogKHgsIHkpLCBhIHBvaW50IG9uIEUuXG4gICAgcmV0dXJuICh1KSA9PiB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBsZXQgdHYxLCB0djIsIHR2MywgdHY0LCB0djUsIHR2NiwgeCwgeTtcbiAgICAgICAgdHYxID0gRnAuc3FyKHUpOyAvLyAxLiAgdHYxID0gdV4yXG4gICAgICAgIHR2MSA9IEZwLm11bCh0djEsIG9wdHMuWik7IC8vIDIuICB0djEgPSBaICogdHYxXG4gICAgICAgIHR2MiA9IEZwLnNxcih0djEpOyAvLyAzLiAgdHYyID0gdHYxXjJcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHYxKTsgLy8gNC4gIHR2MiA9IHR2MiArIHR2MVxuICAgICAgICB0djMgPSBGcC5hZGQodHYyLCBGcC5PTkUpOyAvLyA1LiAgdHYzID0gdHYyICsgMVxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCBvcHRzLkIpOyAvLyA2LiAgdHYzID0gQiAqIHR2M1xuICAgICAgICB0djQgPSBGcC5jbW92KG9wdHMuWiwgRnAubmVnKHR2MiksICFGcC5lcWwodHYyLCBGcC5aRVJPKSk7IC8vIDcuICB0djQgPSBDTU9WKFosIC10djIsIHR2MiAhPSAwKVxuICAgICAgICB0djQgPSBGcC5tdWwodHY0LCBvcHRzLkEpOyAvLyA4LiAgdHY0ID0gQSAqIHR2NFxuICAgICAgICB0djIgPSBGcC5zcXIodHYzKTsgLy8gOS4gIHR2MiA9IHR2M14yXG4gICAgICAgIHR2NiA9IEZwLnNxcih0djQpOyAvLyAxMC4gdHY2ID0gdHY0XjJcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5BKTsgLy8gMTEuIHR2NSA9IEEgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTIuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB0djIgPSBGcC5tdWwodHYyLCB0djMpOyAvLyAxMy4gdHYyID0gdHYyICogdHYzXG4gICAgICAgIHR2NiA9IEZwLm11bCh0djYsIHR2NCk7IC8vIDE0LiB0djYgPSB0djYgKiB0djRcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5CKTsgLy8gMTUuIHR2NSA9IEIgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTYuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB4ID0gRnAubXVsKHR2MSwgdHYzKTsgLy8gMTcuICAgeCA9IHR2MSAqIHR2M1xuICAgICAgICBjb25zdCB7IGlzVmFsaWQsIHZhbHVlIH0gPSBzcXJ0UmF0aW8odHYyLCB0djYpOyAvLyAxOC4gKGlzX2d4MV9zcXVhcmUsIHkxKSA9IHNxcnRfcmF0aW8odHYyLCB0djYpXG4gICAgICAgIHkgPSBGcC5tdWwodHYxLCB1KTsgLy8gMTkuICAgeSA9IHR2MSAqIHUgIC0+IFogKiB1XjMgKiB5MVxuICAgICAgICB5ID0gRnAubXVsKHksIHZhbHVlKTsgLy8gMjAuICAgeSA9IHkgKiB5MVxuICAgICAgICB4ID0gRnAuY21vdih4LCB0djMsIGlzVmFsaWQpOyAvLyAyMS4gICB4ID0gQ01PVih4LCB0djMsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIHkgPSBGcC5jbW92KHksIHZhbHVlLCBpc1ZhbGlkKTsgLy8gMjIuICAgeSA9IENNT1YoeSwgeTEsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIGNvbnN0IGUxID0gRnAuaXNPZGQodSkgPT09IEZwLmlzT2RkKHkpOyAvLyAyMy4gIGUxID0gc2duMCh1KSA9PSBzZ24wKHkpXG4gICAgICAgIHkgPSBGcC5jbW92KEZwLm5lZyh5KSwgeSwgZTEpOyAvLyAyNC4gICB5ID0gQ01PVigteSwgeSwgZTEpXG4gICAgICAgIHggPSBGcC5kaXYoeCwgdHY0KTsgLy8gMjUuICAgeCA9IHggLyB0djRcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH07XG59XG5leHBvcnRzLm1hcFRvQ3VydmVTaW1wbGVTV1UgPSBtYXBUb0N1cnZlU2ltcGxlU1dVO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2VpZXJzdHJhc3MuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibWFwVG9DdXJ2ZVNpbXBsZVNXVSIsIlNXVUZwU3FydFJhdGlvIiwid2VpZXJzdHJhc3MiLCJ3ZWllcnN0cmFzc1BvaW50cyIsIkRFUiIsIm1vZCIsInJlcXVpcmUiLCJ1dCIsInV0aWxzX2pzXzEiLCJjdXJ2ZV9qc18xIiwidmFsaWRhdGVQb2ludE9wdHMiLCJjdXJ2ZSIsIm9wdHMiLCJ2YWxpZGF0ZUJhc2ljIiwidmFsaWRhdGVPYmplY3QiLCJhIiwiYiIsImFsbG93ZWRQcml2YXRlS2V5TGVuZ3RocyIsIndyYXBQcml2YXRlS2V5IiwiaXNUb3JzaW9uRnJlZSIsImNsZWFyQ29mYWN0b3IiLCJhbGxvd0luZmluaXR5UG9pbnQiLCJmcm9tQnl0ZXMiLCJ0b0J5dGVzIiwiZW5kbyIsIkZwIiwiZXFsIiwiWkVSTyIsIkVycm9yIiwiYmV0YSIsInNwbGl0U2NhbGFyIiwiZnJlZXplIiwiYnl0ZXNUb051bWJlckJFIiwiYjJuIiwiaGV4VG9CeXRlcyIsImgyYiIsIkVyciIsIkRFUkVyciIsImNvbnN0cnVjdG9yIiwibSIsIl9wYXJzZUludCIsImRhdGEiLCJFIiwibGVuZ3RoIiwibGVuIiwicmVzIiwic3ViYXJyYXkiLCJkIiwibCIsInRvU2lnIiwiaGV4IiwiVWludDhBcnJheSIsInIiLCJzQnl0ZXMiLCJzIiwickJ5dGVzTGVmdCIsImhleEZyb21TaWciLCJzaWciLCJzbGljZSIsIk51bWJlciIsInBhcnNlSW50IiwiaCIsIm51bSIsInRvU3RyaW5nIiwic2hsIiwicmhsIiwic2wiLCJybCIsIl8wbiIsIkJpZ0ludCIsIl8xbiIsIl8ybiIsIl8zbiIsIl80biIsIkNVUlZFIiwiYyIsInBvaW50IiwiaXNDb21wcmVzc2VkIiwidG9BZmZpbmUiLCJjb25jYXRCeXRlcyIsImZyb20iLCJ4IiwieSIsImJ5dGVzIiwidGFpbCIsIkJZVEVTIiwid2VpZXJzdHJhc3NFcXVhdGlvbiIsIngyIiwic3FyIiwieDMiLCJtdWwiLCJhZGQiLCJHeSIsIkd4IiwiaXNXaXRoaW5DdXJ2ZU9yZGVyIiwibiIsImFzc2VydEdFIiwibm9ybVByaXZhdGVLZXlUb1NjYWxhciIsImtleSIsImxlbmd0aHMiLCJuQnl0ZUxlbmd0aCIsImJ5dGVzVG9IZXgiLCJpbmNsdWRlcyIsInBhZFN0YXJ0IiwiZW5zdXJlQnl0ZXMiLCJlcnJvciIsInBvaW50UHJlY29tcHV0ZXMiLCJNYXAiLCJhc3NlcnRQcmpQb2ludCIsIm90aGVyIiwiUG9pbnQiLCJweCIsInB5IiwicHoiLCJpc1ZhbGlkIiwiZnJvbUFmZmluZSIsInAiLCJpczAiLCJpIiwiT05FIiwibm9ybWFsaXplWiIsInBvaW50cyIsInRvSW52IiwiaW52ZXJ0QmF0Y2giLCJtYXAiLCJmcm9tSGV4IiwiUCIsImFzc2VydFZhbGlkaXR5IiwiZnJvbVByaXZhdGVLZXkiLCJwcml2YXRlS2V5IiwiQkFTRSIsIm11bHRpcGx5IiwiX3NldFdpbmRvd1NpemUiLCJ3aW5kb3dTaXplIiwiX1dJTkRPV19TSVpFIiwiZGVsZXRlIiwibGVmdCIsInJpZ2h0IiwiaGFzRXZlblkiLCJpc09kZCIsImVxdWFscyIsIlgxIiwiWTEiLCJaMSIsIlgyIiwiWTIiLCJaMiIsIlUxIiwiVTIiLCJuZWdhdGUiLCJuZWciLCJkb3VibGUiLCJiMyIsIlgzIiwiWTMiLCJaMyIsInQwIiwidDEiLCJ0MiIsInQzIiwic3ViIiwidDQiLCJ0NSIsInN1YnRyYWN0Iiwid05BRiIsInduYWYiLCJ3TkFGQ2FjaGVkIiwiY29tcCIsIm11bHRpcGx5VW5zYWZlIiwiSSIsInVuc2FmZUxhZGRlciIsImsxbmVnIiwiazEiLCJrMm5lZyIsImsyIiwiazFwIiwiazJwIiwic2NhbGFyIiwiZmFrZSIsImYiLCJmMXAiLCJmMnAiLCJjb25zdFRpbWVOZWdhdGUiLCJtdWx0aXBseUFuZEFkZFVuc2FmZSIsIlEiLCJHIiwic3VtIiwidW5kZWZpbmVkIiwiaXoiLCJ6IiwiaW52IiwiYXgiLCJheSIsInp6IiwiY29mYWN0b3IiLCJ0b1Jhd0J5dGVzIiwidG9IZXgiLCJfYml0cyIsIm5CaXRMZW5ndGgiLCJNYXRoIiwiY2VpbCIsIlByb2plY3RpdmVQb2ludCIsInZhbGlkYXRlT3B0cyIsImhhc2giLCJobWFjIiwicmFuZG9tQnl0ZXMiLCJiaXRzMmludCIsImJpdHMyaW50X21vZE4iLCJsb3dTIiwiY3VydmVEZWYiLCJDVVJWRV9PUkRFUiIsImNvbXByZXNzZWRMZW4iLCJ1bmNvbXByZXNzZWRMZW4iLCJpc1ZhbGlkRmllbGRFbGVtZW50IiwiT1JERVIiLCJtb2ROIiwiaW52TiIsImludmVydCIsImNhdCIsImhlYWQiLCJ5MiIsInNxcnQiLCJpc1lPZGQiLCJpc0hlYWRPZGQiLCJudW1Ub05CeXRlU3RyIiwibnVtYmVyVG9CeXRlc0JFIiwiaXNCaWdnZXJUaGFuSGFsZk9yZGVyIiwibnVtYmVyIiwiSEFMRiIsIm5vcm1hbGl6ZVMiLCJzbGNOdW0iLCJ0byIsIlNpZ25hdHVyZSIsInJlY292ZXJ5IiwiZnJvbUNvbXBhY3QiLCJmcm9tREVSIiwiYWRkUmVjb3ZlcnlCaXQiLCJyZWNvdmVyUHVibGljS2V5IiwibXNnSGFzaCIsInJlYyIsInJhZGoiLCJwcmVmaXgiLCJSIiwiaXIiLCJ1MSIsInUyIiwiaGFzSGlnaFMiLCJ0b0RFUlJhd0J5dGVzIiwidG9ERVJIZXgiLCJ0b0NvbXBhY3RSYXdCeXRlcyIsInRvQ29tcGFjdEhleCIsInV0aWxzIiwiaXNWYWxpZFByaXZhdGVLZXkiLCJyYW5kb21Qcml2YXRlS2V5IiwicmFuZCIsImhhc2hUb1ByaXZhdGVTY2FsYXIiLCJwcmVjb21wdXRlIiwiZ2V0UHVibGljS2V5IiwiaXNQcm9iUHViIiwiaXRlbSIsImFyciIsInN0ciIsImdldFNoYXJlZFNlY3JldCIsInByaXZhdGVBIiwicHVibGljQiIsImRlbHRhIiwiT1JERVJfTUFTSyIsImJpdE1hc2siLCJpbnQyb2N0ZXRzIiwicHJlcFNpZyIsImRlZmF1bHRTaWdPcHRzIiwic29tZSIsImsiLCJwcmVoYXNoIiwiZXh0cmFFbnRyb3B5IiwiZW50IiwiaDFpbnQiLCJzZWVkQXJncyIsImUiLCJwdXNoIiwic2VlZCIsImsyc2lnIiwia0J5dGVzIiwiaWsiLCJxIiwibm9ybVMiLCJkZWZhdWx0VmVyT3B0cyIsInNpZ24iLCJwcml2S2V5IiwiQyIsImRyYmciLCJjcmVhdGVIbWFjRHJiZyIsIm91dHB1dExlbiIsInZlcmlmeSIsInNpZ25hdHVyZSIsInB1YmxpY0tleSIsInNnIiwiX3NpZyIsImRlckVycm9yIiwibWVzc2FnZSIsImlzIiwidiIsIloiLCJvIiwiYzEiLCJfMm5fcG93X2MxXzEiLCJfMm5fcG93X2MxIiwiYzIiLCJjMyIsImM0IiwiYzUiLCJjNiIsInBvdyIsImM3Iiwic3FydFJhdGlvIiwidSIsInR2MSIsInR2MiIsInR2MyIsInR2NSIsInR2NCIsImlzUVIiLCJjbW92IiwidHZ2NSIsImUxIiwieTEiLCJ2YWxpZGF0ZUZpZWxkIiwiQSIsIkIiLCJ0djYiLCJkaXYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/curves/abstract/weierstrass.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/curves/secp256k1.js":
/*!************************************************************************************!*\
  !*** ./node_modules/ethereum-cryptography/node_modules/@noble/curves/secp256k1.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.secp256k1 = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/sha256.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/utils.js\");\nconst modular_js_1 = __webpack_require__(/*! ./abstract/modular.js */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/curves/abstract/modular.js\");\nconst weierstrass_js_1 = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/curves/abstract/weierstrass.js\");\nconst utils_js_1 = __webpack_require__(/*! ./abstract/utils.js */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/curves/abstract/utils.js\");\nconst hash_to_curve_js_1 = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/curves/abstract/hash-to-curve.js\");\nconst _shortw_utils_js_1 = __webpack_require__(/*! ./_shortw_utils.js */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/curves/_shortw_utils.js\");\nconst secp256k1P = BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\");\nconst secp256k1N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b)=>(a + b / _2n) / b;\n/**\n * ‚àön = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */ function sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = y * y * y % P; // x^3, 11\n    const b3 = b2 * b2 * y % P; // x^7\n    const b6 = (0, modular_js_1.pow2)(b3, _3n, P) * b3 % P;\n    const b9 = (0, modular_js_1.pow2)(b6, _3n, P) * b3 % P;\n    const b11 = (0, modular_js_1.pow2)(b9, _2n, P) * b2 % P;\n    const b22 = (0, modular_js_1.pow2)(b11, _11n, P) * b11 % P;\n    const b44 = (0, modular_js_1.pow2)(b22, _22n, P) * b22 % P;\n    const b88 = (0, modular_js_1.pow2)(b44, _44n, P) * b44 % P;\n    const b176 = (0, modular_js_1.pow2)(b88, _88n, P) * b88 % P;\n    const b220 = (0, modular_js_1.pow2)(b176, _44n, P) * b44 % P;\n    const b223 = (0, modular_js_1.pow2)(b220, _3n, P) * b3 % P;\n    const t1 = (0, modular_js_1.pow2)(b223, _23n, P) * b22 % P;\n    const t2 = (0, modular_js_1.pow2)(t1, _6n, P) * b2 % P;\n    const root = (0, modular_js_1.pow2)(t2, _2n, P);\n    if (!Fp.eql(Fp.sqr(root), y)) throw new Error(\"Cannot find square root\");\n    return root;\n}\nconst Fp = (0, modular_js_1.Field)(secp256k1P, undefined, undefined, {\n    sqrt: sqrtMod\n});\nexports.secp256k1 = (0, _shortw_utils_js_1.createCurve)({\n    a: BigInt(0),\n    b: BigInt(7),\n    Fp,\n    n: secp256k1N,\n    // Base point (x, y) aka generator point\n    Gx: BigInt(\"55066263022277343669578718895168534326250603453777594175500187360389116729240\"),\n    Gy: BigInt(\"32670510020758816978083085130507043184471273380659243275938904335757337482424\"),\n    h: BigInt(1),\n    lowS: true,\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */ endo: {\n        beta: BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\"),\n        splitScalar: (k)=>{\n            const n = secp256k1N;\n            const a1 = BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\");\n            const b1 = -_1n * BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\");\n            const a2 = BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\");\n            const b2 = a1;\n            const POW_2_128 = BigInt(\"0x100000000000000000000000000000000\"); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0, modular_js_1.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg) k1 = n - k1;\n            if (k2neg) k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error(\"splitScalar: Endomorphism failed, k=\" + k);\n            }\n            return {\n                k1neg,\n                k1,\n                k2neg,\n                k2\n            };\n        }\n    }\n}, sha256_1.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x)=>typeof x === \"bigint\" && _0n < x && x < secp256k1P;\nconst ge = (x)=>typeof x === \"bigint\" && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */ const TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c)=>c.charCodeAt(0)));\n        tagP = (0, utils_js_1.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point)=>point.toRawBytes(true).slice(1);\nconst numTo32b = (n)=>(0, utils_js_1.numberToBytesBE)(n, 32);\nconst modP = (x)=>(0, modular_js_1.mod)(x, secp256k1P);\nconst modN = (x)=>(0, modular_js_1.mod)(x, secp256k1N);\nconst Point = exports.secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b)=>Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'‚ãÖG; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return {\n        scalar: scalar,\n        bytes: pointToBytes(p)\n    };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */ function lift_x(x) {\n    if (!fe(x)) throw new Error(\"bad x: need 0 < x < p\"); // Fail if x ‚â• p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x¬≥ + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n) y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */ function challenge(...args) {\n    return modN((0, utils_js_1.bytesToNumberBE)(taggedHash(\"BIP0340/challenge\", ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */ function schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'‚â•n. Ret bytes(d'‚ãÖG)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */ function schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {\n    const m = (0, utils_js_1.ensureBytes)(\"message\", message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0, utils_js_1.ensureBytes)(\"auxRand\", auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ (0, utils_js_1.bytesToNumberBE)(taggedHash(\"BIP0340/aux\", a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash(\"BIP0340/nonce\", t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN((0, utils_js_1.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n) throw new Error(\"sign failed: k is zero\"); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'‚ãÖG.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px)) throw new Error(\"sign: Invalid signature produced\");\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */ function schnorrVerify(signature, message, publicKey) {\n    const sig = (0, utils_js_1.ensureBytes)(\"signature\", signature, 64);\n    const m = (0, utils_js_1.ensureBytes)(\"message\", message);\n    const pub = (0, utils_js_1.ensureBytes)(\"publicKey\", publicKey, 32);\n    try {\n        const P = lift_x((0, utils_js_1.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = (0, utils_js_1.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ‚â• p.\n        if (!fe(r)) return false;\n        const s = (0, utils_js_1.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ‚â• n.\n        if (!ge(s)) return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = s‚ãÖG - e‚ãÖP\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ‚â† r.\n    } catch (error) {\n        return false;\n    }\n}\nexports.schnorr = (()=>({\n        getPublicKey: schnorrGetPublicKey,\n        sign: schnorrSign,\n        verify: schnorrVerify,\n        utils: {\n            randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,\n            lift_x,\n            pointToBytes,\n            numberToBytesBE: utils_js_1.numberToBytesBE,\n            bytesToNumberBE: utils_js_1.bytesToNumberBE,\n            taggedHash,\n            mod: modular_js_1.mod\n        }\n    }))();\nconst isoMap = /* @__PURE__ */ (()=>(0, hash_to_curve_js_1.isogenyMap)(Fp, [\n        // xNum\n        [\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7\",\n            \"0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581\",\n            \"0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262\",\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c\"\n        ],\n        // xDen\n        [\n            \"0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b\",\n            \"0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ],\n        // yNum\n        [\n            \"0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c\",\n            \"0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3\",\n            \"0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931\",\n            \"0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84\"\n        ],\n        // yDen\n        [\n            \"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b\",\n            \"0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573\",\n            \"0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ]\n    ].map((i)=>i.map((j)=>BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (()=>(0, weierstrass_js_1.mapToCurveSimpleSWU)(Fp, {\n        A: BigInt(\"0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533\"),\n        B: BigInt(\"1771\"),\n        Z: Fp.create(BigInt(\"-11\"))\n    }))();\nconst htf = /* @__PURE__ */ (()=>(0, hash_to_curve_js_1.createHasher)(exports.secp256k1.ProjectivePoint, (scalars)=>{\n        const { x, y } = mapSWU(Fp.create(scalars[0]));\n        return isoMap(x, y);\n    }, {\n        DST: \"secp256k1_XMD:SHA-256_SSWU_RO_\",\n        encodeDST: \"secp256k1_XMD:SHA-256_SSWU_NU_\",\n        p: Fp.ORDER,\n        m: 1,\n        k: 128,\n        expand: \"xmd\",\n        hash: sha256_1.sha256\n    }))();\nexports.hashToCurve = (()=>htf.hashToCurve)();\nexports.encodeToCurve = (()=>htf.encodeToCurve)(); //# sourceMappingURL=secp256k1.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL3NlY3AyNTZrMS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQscUJBQXFCLEdBQUdBLG1CQUFtQixHQUFHQSxlQUFlLEdBQUdBLGlCQUFpQixHQUFHLEtBQUs7QUFDekYsb0VBQW9FLEdBQ3BFLE1BQU1NLFdBQVdDLG1CQUFPQSxDQUFDLDZHQUFzQjtBQUMvQyxNQUFNQyxVQUFVRCxtQkFBT0EsQ0FBQywyR0FBcUI7QUFDN0MsTUFBTUUsZUFBZUYsbUJBQU9BLENBQUMsd0hBQXVCO0FBQ3BELE1BQU1HLG1CQUFtQkgsbUJBQU9BLENBQUMsZ0lBQTJCO0FBQzVELE1BQU1JLGFBQWFKLG1CQUFPQSxDQUFDLG9IQUFxQjtBQUNoRCxNQUFNSyxxQkFBcUJMLG1CQUFPQSxDQUFDLG9JQUE2QjtBQUNoRSxNQUFNTSxxQkFBcUJOLG1CQUFPQSxDQUFDLGtIQUFvQjtBQUN2RCxNQUFNTyxhQUFhQyxPQUFPO0FBQzFCLE1BQU1DLGFBQWFELE9BQU87QUFDMUIsTUFBTUUsTUFBTUYsT0FBTztBQUNuQixNQUFNRyxNQUFNSCxPQUFPO0FBQ25CLE1BQU1JLGFBQWEsQ0FBQ0MsR0FBR0MsSUFBTSxDQUFDRCxJQUFJQyxJQUFJSCxHQUFFLElBQUtHO0FBQzdDOzs7Q0FHQyxHQUNELFNBQVNDLFFBQVFDLENBQUM7SUFDZCxNQUFNQyxJQUFJVjtJQUNWLGtCQUFrQjtJQUNsQixNQUFNVyxNQUFNVixPQUFPLElBQUlXLE1BQU1YLE9BQU8sSUFBSVksT0FBT1osT0FBTyxLQUFLYSxPQUFPYixPQUFPO0lBQ3pFLGtCQUFrQjtJQUNsQixNQUFNYyxPQUFPZCxPQUFPLEtBQUtlLE9BQU9mLE9BQU8sS0FBS2dCLE9BQU9oQixPQUFPO0lBQzFELE1BQU1pQixLQUFLLElBQUtULElBQUlBLElBQUtD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QUFHdkosbUJBQW1Cd0osWUFBWSxFQUFFcEssUUFBUUssU0FBUyxDQUFDK0YsZUFBZSxFQUFFLENBQUNpRTtRQUN4RyxNQUFNLEVBQUV2RixDQUFDLEVBQUV2RCxDQUFDLEVBQUUsR0FBR3NJLE9BQU85RyxHQUFHbUgsTUFBTSxDQUFDRyxPQUFPLENBQUMsRUFBRTtRQUM1QyxPQUFPYixPQUFPMUUsR0FBR3ZEO0lBQ3JCLEdBQUc7UUFDQytJLEtBQUs7UUFDTEMsV0FBVztRQUNYekQsR0FBRy9ELEdBQUd5SCxLQUFLO1FBQ1h6QyxHQUFHO1FBQ0hoRSxHQUFHO1FBQ0gwRyxRQUFRO1FBQ1JDLE1BQU1wSyxTQUFTcUUsTUFBTTtJQUN6QixFQUFDO0FBQ0QzRSxtQkFBbUIsR0FBRyxDQUFDLElBQU1tSyxJQUFJaEssV0FBVztBQUM1Q0gscUJBQXFCLEdBQUcsQ0FBQyxJQUFNbUssSUFBSWpLLGFBQWEsS0FDaEQscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9zZWNwMjU2azEuanM/OTQzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW5jb2RlVG9DdXJ2ZSA9IGV4cG9ydHMuaGFzaFRvQ3VydmUgPSBleHBvcnRzLnNjaG5vcnIgPSBleHBvcnRzLnNlY3AyNTZrMSA9IHZvaWQgMDtcbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmNvbnN0IHNoYTI1Nl8xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCIpO1xuY29uc3QgbW9kdWxhcl9qc18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3QvbW9kdWxhci5qc1wiKTtcbmNvbnN0IHdlaWVyc3RyYXNzX2pzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC93ZWllcnN0cmFzcy5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC91dGlscy5qc1wiKTtcbmNvbnN0IGhhc2hfdG9fY3VydmVfanNfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanNcIik7XG5jb25zdCBfc2hvcnR3X3V0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi9fc2hvcnR3X3V0aWxzLmpzXCIpO1xuY29uc3Qgc2VjcDI1NmsxUCA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmYzJmJyk7XG5jb25zdCBzZWNwMjU2azFOID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDEnKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IGRpdk5lYXJlc3QgPSAoYSwgYikgPT4gKGEgKyBiIC8gXzJuKSAvIGI7XG4vKipcbiAqIOKImm4gPSBuXigocCsxKS80KSBmb3IgZmllbGRzIHAgPSAzIG1vZCA0LiBXZSB1bndyYXAgdGhlIGxvb3AgYW5kIG11bHRpcGx5IGJpdC1ieS1iaXQuXG4gKiAoUCsxbi80bikudG9TdHJpbmcoMikgd291bGQgcHJvZHVjZSBiaXRzIFsyMjN4IDEsIDAsIDIyeCAxLCA0eCAwLCAxMSwgMDBdXG4gKi9cbmZ1bmN0aW9uIHNxcnRNb2QoeSkge1xuICAgIGNvbnN0IFAgPSBzZWNwMjU2azFQO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF8zbiA9IEJpZ0ludCgzKSwgXzZuID0gQmlnSW50KDYpLCBfMTFuID0gQmlnSW50KDExKSwgXzIybiA9IEJpZ0ludCgyMik7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgXzIzbiA9IEJpZ0ludCgyMyksIF80NG4gPSBCaWdJbnQoNDQpLCBfODhuID0gQmlnSW50KDg4KTtcbiAgICBjb25zdCBiMiA9ICh5ICogeSAqIHkpICUgUDsgLy8geF4zLCAxMVxuICAgIGNvbnN0IGIzID0gKGIyICogYjIgKiB5KSAlIFA7IC8vIHheN1xuICAgIGNvbnN0IGI2ID0gKCgwLCBtb2R1bGFyX2pzXzEucG93MikoYjMsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IGI5ID0gKCgwLCBtb2R1bGFyX2pzXzEucG93MikoYjYsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IGIxMSA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKGI5LCBfMm4sIFApICogYjIpICUgUDtcbiAgICBjb25zdCBiMjIgPSAoKDAsIG1vZHVsYXJfanNfMS5wb3cyKShiMTEsIF8xMW4sIFApICogYjExKSAlIFA7XG4gICAgY29uc3QgYjQ0ID0gKCgwLCBtb2R1bGFyX2pzXzEucG93MikoYjIyLCBfMjJuLCBQKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IGI4OCA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKGI0NCwgXzQ0biwgUCkgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMTc2ID0gKCgwLCBtb2R1bGFyX2pzXzEucG93MikoYjg4LCBfODhuLCBQKSAqIGI4OCkgJSBQO1xuICAgIGNvbnN0IGIyMjAgPSAoKDAsIG1vZHVsYXJfanNfMS5wb3cyKShiMTc2LCBfNDRuLCBQKSAqIGI0NCkgJSBQO1xuICAgIGNvbnN0IGIyMjMgPSAoKDAsIG1vZHVsYXJfanNfMS5wb3cyKShiMjIwLCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCB0MSA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKGIyMjMsIF8yM24sIFApICogYjIyKSAlIFA7XG4gICAgY29uc3QgdDIgPSAoKDAsIG1vZHVsYXJfanNfMS5wb3cyKSh0MSwgXzZuLCBQKSAqIGIyKSAlIFA7XG4gICAgY29uc3Qgcm9vdCA9ICgwLCBtb2R1bGFyX2pzXzEucG93MikodDIsIF8ybiwgUCk7XG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCB5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgIHJldHVybiByb290O1xufVxuY29uc3QgRnAgPSAoMCwgbW9kdWxhcl9qc18xLkZpZWxkKShzZWNwMjU2azFQLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgeyBzcXJ0OiBzcXJ0TW9kIH0pO1xuZXhwb3J0cy5zZWNwMjU2azEgPSAoMCwgX3Nob3J0d191dGlsc19qc18xLmNyZWF0ZUN1cnZlKSh7XG4gICAgYTogQmlnSW50KDApLFxuICAgIGI6IEJpZ0ludCg3KSxcbiAgICBGcCxcbiAgICBuOiBzZWNwMjU2azFOLFxuICAgIC8vIEJhc2UgcG9pbnQgKHgsIHkpIGFrYSBnZW5lcmF0b3IgcG9pbnRcbiAgICBHeDogQmlnSW50KCc1NTA2NjI2MzAyMjI3NzM0MzY2OTU3ODcxODg5NTE2ODUzNDMyNjI1MDYwMzQ1Mzc3NzU5NDE3NTUwMDE4NzM2MDM4OTExNjcyOTI0MCcpLFxuICAgIEd5OiBCaWdJbnQoJzMyNjcwNTEwMDIwNzU4ODE2OTc4MDgzMDg1MTMwNTA3MDQzMTg0NDcxMjczMzgwNjU5MjQzMjc1OTM4OTA0MzM1NzU3MzM3NDgyNDI0JyksXG4gICAgaDogQmlnSW50KDEpLFxuICAgIGxvd1M6IHRydWUsXG4gICAgLyoqXG4gICAgICogc2VjcDI1NmsxIGJlbG9uZ3MgdG8gS29ibGl0eiBjdXJ2ZXM6IGl0IGhhcyBlZmZpY2llbnRseSBjb21wdXRhYmxlIGVuZG9tb3JwaGlzbS5cbiAgICAgKiBFbmRvbW9ycGhpc20gdXNlcyAyeCBsZXNzIFJBTSwgc3BlZWRzIHVwIHByZWNvbXB1dGF0aW9uIGJ5IDJ4IGFuZCBFQ0RIIC8ga2V5IHJlY292ZXJ5IGJ5IDIwJS5cbiAgICAgKiBGb3IgcHJlY29tcHV0ZWQgd05BRiBpdCB0cmFkZXMgb2ZmIDEvMiBpbml0IHRpbWUgJiAxLzMgcmFtIGZvciAyMCUgcGVyZiBoaXQuXG4gICAgICogRXhwbGFuYXRpb246IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxtaWxsci9lYjY3MDgwNjc5M2U4NGRmNjI4YTdjNDM0YTg3MzA2NlxuICAgICAqL1xuICAgIGVuZG86IHtcbiAgICAgICAgYmV0YTogQmlnSW50KCcweDdhZTk2YTJiNjU3YzA3MTA2ZTY0NDc5ZWFjMzQzNGU5OWNmMDQ5NzUxMmY1ODk5NWMxMzk2YzI4NzE5NTAxZWUnKSxcbiAgICAgICAgc3BsaXRTY2FsYXI6IChrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuID0gc2VjcDI1NmsxTjtcbiAgICAgICAgICAgIGNvbnN0IGExID0gQmlnSW50KCcweDMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1Jyk7XG4gICAgICAgICAgICBjb25zdCBiMSA9IC1fMW4gKiBCaWdJbnQoJzB4ZTQ0MzdlZDYwMTBlODgyODZmNTQ3ZmE5MGFiZmU0YzMnKTtcbiAgICAgICAgICAgIGNvbnN0IGEyID0gQmlnSW50KCcweDExNGNhNTBmN2E4ZTJmM2Y2NTdjMTEwOGQ5ZDQ0Y2ZkOCcpO1xuICAgICAgICAgICAgY29uc3QgYjIgPSBhMTtcbiAgICAgICAgICAgIGNvbnN0IFBPV18yXzEyOCA9IEJpZ0ludCgnMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKTsgLy8gKDJuKioxMjhuKS50b1N0cmluZygxNilcbiAgICAgICAgICAgIGNvbnN0IGMxID0gZGl2TmVhcmVzdChiMiAqIGssIG4pO1xuICAgICAgICAgICAgY29uc3QgYzIgPSBkaXZOZWFyZXN0KC1iMSAqIGssIG4pO1xuICAgICAgICAgICAgbGV0IGsxID0gKDAsIG1vZHVsYXJfanNfMS5tb2QpKGsgLSBjMSAqIGExIC0gYzIgKiBhMiwgbik7XG4gICAgICAgICAgICBsZXQgazIgPSAoMCwgbW9kdWxhcl9qc18xLm1vZCkoLWMxICogYjEgLSBjMiAqIGIyLCBuKTtcbiAgICAgICAgICAgIGNvbnN0IGsxbmVnID0gazEgPiBQT1dfMl8xMjg7XG4gICAgICAgICAgICBjb25zdCBrMm5lZyA9IGsyID4gUE9XXzJfMTI4O1xuICAgICAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgICAgIGsxID0gbiAtIGsxO1xuICAgICAgICAgICAgaWYgKGsybmVnKVxuICAgICAgICAgICAgICAgIGsyID0gbiAtIGsyO1xuICAgICAgICAgICAgaWYgKGsxID4gUE9XXzJfMTI4IHx8IGsyID4gUE9XXzJfMTI4KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcGxpdFNjYWxhcjogRW5kb21vcnBoaXNtIGZhaWxlZCwgaz0nICsgayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBrMW5lZywgazEsIGsybmVnLCBrMiB9O1xuICAgICAgICB9LFxuICAgIH0sXG59LCBzaGEyNTZfMS5zaGEyNTYpO1xuLy8gU2Nobm9yciBzaWduYXR1cmVzIGFyZSBzdXBlcmlvciB0byBFQ0RTQSBmcm9tIGFib3ZlLiBCZWxvdyBpcyBTY2hub3JyLXNwZWNpZmljIEJJUDAzNDAgY29kZS5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAzNDAubWVkaWF3aWtpXG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBmZSA9ICh4KSA9PiB0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgeCAmJiB4IDwgc2VjcDI1NmsxUDtcbmNvbnN0IGdlID0gKHgpID0+IHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiBfMG4gPCB4ICYmIHggPCBzZWNwMjU2azFOO1xuLyoqIEFuIG9iamVjdCBtYXBwaW5nIHRhZ3MgdG8gdGhlaXIgdGFnZ2VkIGhhc2ggcHJlZml4IG9mIFtTSEEyNTYodGFnKSB8IFNIQTI1Nih0YWcpXSAqL1xuY29uc3QgVEFHR0VEX0hBU0hfUFJFRklYRVMgPSB7fTtcbmZ1bmN0aW9uIHRhZ2dlZEhhc2godGFnLCAuLi5tZXNzYWdlcykge1xuICAgIGxldCB0YWdQID0gVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXTtcbiAgICBpZiAodGFnUCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHRhZ0ggPSAoMCwgc2hhMjU2XzEuc2hhMjU2KShVaW50OEFycmF5LmZyb20odGFnLCAoYykgPT4gYy5jaGFyQ29kZUF0KDApKSk7XG4gICAgICAgIHRhZ1AgPSAoMCwgdXRpbHNfanNfMS5jb25jYXRCeXRlcykodGFnSCwgdGFnSCk7XG4gICAgICAgIFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ10gPSB0YWdQO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIHNoYTI1Nl8xLnNoYTI1NikoKDAsIHV0aWxzX2pzXzEuY29uY2F0Qnl0ZXMpKHRhZ1AsIC4uLm1lc3NhZ2VzKSk7XG59XG4vLyBFQ0RTQSBjb21wYWN0IHBvaW50cyBhcmUgMzMtYnl0ZS4gU2Nobm9yciBpcyAzMjogd2Ugc3RyaXAgZmlyc3QgYnl0ZSAweDAyIG9yIDB4MDNcbmNvbnN0IHBvaW50VG9CeXRlcyA9IChwb2ludCkgPT4gcG9pbnQudG9SYXdCeXRlcyh0cnVlKS5zbGljZSgxKTtcbmNvbnN0IG51bVRvMzJiID0gKG4pID0+ICgwLCB1dGlsc19qc18xLm51bWJlclRvQnl0ZXNCRSkobiwgMzIpO1xuY29uc3QgbW9kUCA9ICh4KSA9PiAoMCwgbW9kdWxhcl9qc18xLm1vZCkoeCwgc2VjcDI1NmsxUCk7XG5jb25zdCBtb2ROID0gKHgpID0+ICgwLCBtb2R1bGFyX2pzXzEubW9kKSh4LCBzZWNwMjU2azFOKTtcbmNvbnN0IFBvaW50ID0gZXhwb3J0cy5zZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50O1xuY29uc3QgR211bEFkZCA9IChRLCBhLCBiKSA9PiBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpO1xuLy8gQ2FsY3VsYXRlIHBvaW50LCBzY2FsYXIgYW5kIGJ5dGVzXG5mdW5jdGlvbiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXYpIHtcbiAgICBsZXQgZF8gPSBleHBvcnRzLnNlY3AyNTZrMS51dGlscy5ub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXYpOyAvLyBzYW1lIG1ldGhvZCBleGVjdXRlZCBpbiBmcm9tUHJpdmF0ZUtleVxuICAgIGxldCBwID0gUG9pbnQuZnJvbVByaXZhdGVLZXkoZF8pOyAvLyBQID0gZCfii4VHOyAwIDwgZCcgPCBuIGNoZWNrIGlzIGRvbmUgaW5zaWRlXG4gICAgY29uc3Qgc2NhbGFyID0gcC5oYXNFdmVuWSgpID8gZF8gOiBtb2ROKC1kXyk7XG4gICAgcmV0dXJuIHsgc2NhbGFyOiBzY2FsYXIsIGJ5dGVzOiBwb2ludFRvQnl0ZXMocCkgfTtcbn1cbi8qKlxuICogbGlmdF94IGZyb20gQklQMzQwLiBDb252ZXJ0IDMyLWJ5dGUgeCBjb29yZGluYXRlIHRvIGVsbGlwdGljIGN1cnZlIHBvaW50LlxuICogQHJldHVybnMgdmFsaWQgcG9pbnQgY2hlY2tlZCBmb3IgYmVpbmcgb24tY3VydmVcbiAqL1xuZnVuY3Rpb24gbGlmdF94KHgpIHtcbiAgICBpZiAoIWZlKHgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCB4OiBuZWVkIDAgPCB4IDwgcCcpOyAvLyBGYWlsIGlmIHgg4omlIHAuXG4gICAgY29uc3QgeHggPSBtb2RQKHggKiB4KTtcbiAgICBjb25zdCBjID0gbW9kUCh4eCAqIHggKyBCaWdJbnQoNykpOyAvLyBMZXQgYyA9IHjCsyArIDcgbW9kIHAuXG4gICAgbGV0IHkgPSBzcXJ0TW9kKGMpOyAvLyBMZXQgeSA9IGNeKHArMSkvNCBtb2QgcC5cbiAgICBpZiAoeSAlIF8ybiAhPT0gXzBuKVxuICAgICAgICB5ID0gbW9kUCgteSk7IC8vIFJldHVybiB0aGUgdW5pcXVlIHBvaW50IFAgc3VjaCB0aGF0IHgoUCkgPSB4IGFuZFxuICAgIGNvbnN0IHAgPSBuZXcgUG9pbnQoeCwgeSwgXzFuKTsgLy8geShQKSA9IHkgaWYgeSBtb2QgMiA9IDAgb3IgeShQKSA9IHAteSBvdGhlcndpc2UuXG4gICAgcC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIHJldHVybiBwO1xufVxuLyoqXG4gKiBDcmVhdGUgdGFnZ2VkIGhhc2gsIGNvbnZlcnQgaXQgdG8gYmlnaW50LCByZWR1Y2UgbW9kdWxvLW4uXG4gKi9cbmZ1bmN0aW9uIGNoYWxsZW5nZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIG1vZE4oKDAsIHV0aWxzX2pzXzEuYnl0ZXNUb051bWJlckJFKSh0YWdnZWRIYXNoKCdCSVAwMzQwL2NoYWxsZW5nZScsIC4uLmFyZ3MpKSk7XG59XG4vKipcbiAqIFNjaG5vcnIgcHVibGljIGtleSBpcyBqdXN0IGB4YCBjb29yZGluYXRlIG9mIFBvaW50IGFzIHBlciBCSVAzNDAuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJHZXRQdWJsaWNLZXkocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpLmJ5dGVzOyAvLyBkJz1pbnQoc2spLiBGYWlsIGlmIGQnPTAgb3IgZCfiiaVuLiBSZXQgYnl0ZXMoZCfii4VHKVxufVxuLyoqXG4gKiBDcmVhdGVzIFNjaG5vcnIgc2lnbmF0dXJlIGFzIHBlciBCSVAzNDAuIFZlcmlmaWVzIGl0c2VsZiBiZWZvcmUgcmV0dXJuaW5nIGFueXRoaW5nLlxuICogYXV4UmFuZCBpcyBvcHRpb25hbCBhbmQgaXMgbm90IHRoZSBzb2xlIHNvdXJjZSBvZiBrIGdlbmVyYXRpb246IGJhZCBDU1BSTkcgd29uJ3QgYmUgZGFuZ2Vyb3VzLlxuICovXG5mdW5jdGlvbiBzY2hub3JyU2lnbihtZXNzYWdlLCBwcml2YXRlS2V5LCBhdXhSYW5kID0gKDAsIHV0aWxzXzEucmFuZG9tQnl0ZXMpKDMyKSkge1xuICAgIGNvbnN0IG0gPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCB7IGJ5dGVzOiBweCwgc2NhbGFyOiBkIH0gPSBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpOyAvLyBjaGVja3MgZm9yIGlzV2l0aGluQ3VydmVPcmRlclxuICAgIGNvbnN0IGEgPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ2F1eFJhbmQnLCBhdXhSYW5kLCAzMik7IC8vIEF1eGlsaWFyeSByYW5kb20gZGF0YSBhOiBhIDMyLWJ5dGUgYXJyYXlcbiAgICBjb25zdCB0ID0gbnVtVG8zMmIoZCBeICgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJCRSkodGFnZ2VkSGFzaCgnQklQMDM0MC9hdXgnLCBhKSkpOyAvLyBMZXQgdCBiZSB0aGUgYnl0ZS13aXNlIHhvciBvZiBieXRlcyhkKSBhbmQgaGFzaC9hdXgoYSlcbiAgICBjb25zdCByYW5kID0gdGFnZ2VkSGFzaCgnQklQMDM0MC9ub25jZScsIHQsIHB4LCBtKTsgLy8gTGV0IHJhbmQgPSBoYXNoL25vbmNlKHQgfHwgYnl0ZXMoUCkgfHwgbSlcbiAgICBjb25zdCBrXyA9IG1vZE4oKDAsIHV0aWxzX2pzXzEuYnl0ZXNUb051bWJlckJFKShyYW5kKSk7IC8vIExldCBrJyA9IGludChyYW5kKSBtb2QgblxuICAgIGlmIChrXyA9PT0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ24gZmFpbGVkOiBrIGlzIHplcm8nKTsgLy8gRmFpbCBpZiBrJyA9IDAuXG4gICAgY29uc3QgeyBieXRlczogcngsIHNjYWxhcjogayB9ID0gc2Nobm9yckdldEV4dFB1YktleShrXyk7IC8vIExldCBSID0gayfii4VHLlxuICAgIGNvbnN0IGUgPSBjaGFsbGVuZ2UocngsIHB4LCBtKTsgLy8gTGV0IGUgPSBpbnQoaGFzaC9jaGFsbGVuZ2UoYnl0ZXMoUikgfHwgYnl0ZXMoUCkgfHwgbSkpIG1vZCBuLlxuICAgIGNvbnN0IHNpZyA9IG5ldyBVaW50OEFycmF5KDY0KTsgLy8gTGV0IHNpZyA9IGJ5dGVzKFIpIHx8IGJ5dGVzKChrICsgZWQpIG1vZCBuKS5cbiAgICBzaWcuc2V0KHJ4LCAwKTtcbiAgICBzaWcuc2V0KG51bVRvMzJiKG1vZE4oayArIGUgKiBkKSksIDMyKTtcbiAgICAvLyBJZiBWZXJpZnkoYnl0ZXMoUCksIG0sIHNpZykgKHNlZSBiZWxvdykgcmV0dXJucyBmYWlsdXJlLCBhYm9ydFxuICAgIGlmICghc2Nobm9yclZlcmlmeShzaWcsIG0sIHB4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduOiBJbnZhbGlkIHNpZ25hdHVyZSBwcm9kdWNlZCcpO1xuICAgIHJldHVybiBzaWc7XG59XG4vKipcbiAqIFZlcmlmaWVzIFNjaG5vcnIgc2lnbmF0dXJlLlxuICogV2lsbCBzd2FsbG93IGVycm9ycyAmIHJldHVybiBmYWxzZSBleGNlcHQgZm9yIGluaXRpYWwgdHlwZSB2YWxpZGF0aW9uIG9mIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yclZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSkge1xuICAgIGNvbnN0IHNpZyA9ICgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgnc2lnbmF0dXJlJywgc2lnbmF0dXJlLCA2NCk7XG4gICAgY29uc3QgbSA9ICgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgnbWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgIGNvbnN0IHB1YiA9ICgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgncHVibGljS2V5JywgcHVibGljS2V5LCAzMik7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgUCA9IGxpZnRfeCgoMCwgdXRpbHNfanNfMS5ieXRlc1RvTnVtYmVyQkUpKHB1YikpOyAvLyBQID0gbGlmdF94KGludChwaykpOyBmYWlsIGlmIHRoYXQgZmFpbHNcbiAgICAgICAgY29uc3QgciA9ICgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJCRSkoc2lnLnN1YmFycmF5KDAsIDMyKSk7IC8vIExldCByID0gaW50KHNpZ1swOjMyXSk7IGZhaWwgaWYgciDiiaUgcC5cbiAgICAgICAgaWYgKCFmZShyKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgcyA9ICgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJCRSkoc2lnLnN1YmFycmF5KDMyLCA2NCkpOyAvLyBMZXQgcyA9IGludChzaWdbMzI6NjRdKTsgZmFpbCBpZiBzIOKJpSBuLlxuICAgICAgICBpZiAoIWdlKHMpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBlID0gY2hhbGxlbmdlKG51bVRvMzJiKHIpLCBwb2ludFRvQnl0ZXMoUCksIG0pOyAvLyBpbnQoY2hhbGxlbmdlKGJ5dGVzKHIpfHxieXRlcyhQKXx8bSkpJW5cbiAgICAgICAgY29uc3QgUiA9IEdtdWxBZGQoUCwgcywgbW9kTigtZSkpOyAvLyBSID0gc+KLhUcgLSBl4ouFUFxuICAgICAgICBpZiAoIVIgfHwgIVIuaGFzRXZlblkoKSB8fCBSLnRvQWZmaW5lKCkueCAhPT0gcilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gLWVQID09IChuLWUpUFxuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gRmFpbCBpZiBpc19pbmZpbml0ZShSKSAvIG5vdCBoYXNfZXZlbl95KFIpIC8geChSKSDiiaAgci5cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLnNjaG5vcnIgPSAoKCkgPT4gKHtcbiAgICBnZXRQdWJsaWNLZXk6IHNjaG5vcnJHZXRQdWJsaWNLZXksXG4gICAgc2lnbjogc2Nobm9yclNpZ24sXG4gICAgdmVyaWZ5OiBzY2hub3JyVmVyaWZ5LFxuICAgIHV0aWxzOiB7XG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6IGV4cG9ydHMuc2VjcDI1NmsxLnV0aWxzLnJhbmRvbVByaXZhdGVLZXksXG4gICAgICAgIGxpZnRfeCxcbiAgICAgICAgcG9pbnRUb0J5dGVzLFxuICAgICAgICBudW1iZXJUb0J5dGVzQkU6IHV0aWxzX2pzXzEubnVtYmVyVG9CeXRlc0JFLFxuICAgICAgICBieXRlc1RvTnVtYmVyQkU6IHV0aWxzX2pzXzEuYnl0ZXNUb051bWJlckJFLFxuICAgICAgICB0YWdnZWRIYXNoLFxuICAgICAgICBtb2Q6IG1vZHVsYXJfanNfMS5tb2QsXG4gICAgfSxcbn0pKSgpO1xuY29uc3QgaXNvTWFwID0gLyogQF9fUFVSRV9fICovICgoKSA9PiAoMCwgaGFzaF90b19jdXJ2ZV9qc18xLmlzb2dlbnlNYXApKEZwLCBbXG4gICAgLy8geE51bVxuICAgIFtcbiAgICAgICAgJzB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYThjNycsXG4gICAgICAgICcweDdkM2Q0YzgwYmMzMjFkNWI5ZjMxNWNlYTdmZDQ0YzVkNTk1ZDJmYzBiZjYzYjkyZGZmZjEwNDRmMTdjNjU4MScsXG4gICAgICAgICcweDUzNGMzMjhkMjNmMjM0ZTZlMmE0MTNkZWNhMjVjYWVjZTQ1MDYxNDQwMzdjNDAzMTRlY2JkMGI1M2Q5ZGQyNjInLFxuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhODhjJyxcbiAgICBdLFxuICAgIC8vIHhEZW5cbiAgICBbXG4gICAgICAgICcweGQzNTc3MTE5M2Q5NDkxOGE5Y2EzNGNjYmI3YjY0MGRkODZjZDQwOTU0MmY4NDg3ZDlmZTZiNzQ1NzgxZWI0OWInLFxuICAgICAgICAnMHhlZGFkYzZmNjQzODNkYzFkZjdjNGIyZDUxYjU0MjI1NDA2ZDM2YjY0MWY1ZTQxYmJjNTJhNTY2MTJhOGM2ZDE0JyxcbiAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIC8vIExBU1QgMVxuICAgIF0sXG4gICAgLy8geU51bVxuICAgIFtcbiAgICAgICAgJzB4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGI4ZTM4ZTIzYycsXG4gICAgICAgICcweGM3NWUwYzMyZDVjYjdjMGZhOWQwYTU0YjEyYTBhNmQ1NjQ3YWIwNDZkNjg2ZGE2ZmRmZmM5MGZjMjAxZDcxYTMnLFxuICAgICAgICAnMHgyOWE2MTk0NjkxZjkxYTczNzE1MjA5ZWY2NTEyZTU3NjcyMjgzMGEyMDFiZTIwMThhNzY1ZTg1YTllY2VlOTMxJyxcbiAgICAgICAgJzB4MmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmYzOGUzOGQ4NCcsXG4gICAgXSxcbiAgICAvLyB5RGVuXG4gICAgW1xuICAgICAgICAnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmOTNiJyxcbiAgICAgICAgJzB4N2EwNjUzNGJiOGJkYjQ5ZmQ1ZTllNjYzMjcyMmMyOTg5NDY3YzFiZmM4ZThkOTc4ZGZiNDI1ZDI2ODVjMjU3MycsXG4gICAgICAgICcweDY0ODRhYTcxNjU0NWNhMmNmM2E3MGMzZmE4ZmUzMzdlMGEzZDIxMTYyZjBkNjI5OWE3YmY4MTkyYmZkMmE3NmYnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbl0ubWFwKChpKSA9PiBpLm1hcCgoaikgPT4gQmlnSW50KGopKSkpKSgpO1xuY29uc3QgbWFwU1dVID0gLyogQF9fUFVSRV9fICovICgoKSA9PiAoMCwgd2VpZXJzdHJhc3NfanNfMS5tYXBUb0N1cnZlU2ltcGxlU1dVKShGcCwge1xuICAgIEE6IEJpZ0ludCgnMHgzZjg3MzFhYmRkNjYxYWRjYTA4YTU1NThmMGY1ZDI3MmU5NTNkMzYzY2I2ZjBlNWQ0MDU0NDdjMDFhNDQ0NTMzJyksXG4gICAgQjogQmlnSW50KCcxNzcxJyksXG4gICAgWjogRnAuY3JlYXRlKEJpZ0ludCgnLTExJykpLFxufSkpKCk7XG5jb25zdCBodGYgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICgwLCBoYXNoX3RvX2N1cnZlX2pzXzEuY3JlYXRlSGFzaGVyKShleHBvcnRzLnNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQsIChzY2FsYXJzKSA9PiB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBtYXBTV1UoRnAuY3JlYXRlKHNjYWxhcnNbMF0pKTtcbiAgICByZXR1cm4gaXNvTWFwKHgsIHkpO1xufSwge1xuICAgIERTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPXycsXG4gICAgZW5jb2RlRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfTlVfJyxcbiAgICBwOiBGcC5PUkRFUixcbiAgICBtOiAxLFxuICAgIGs6IDEyOCxcbiAgICBleHBhbmQ6ICd4bWQnLFxuICAgIGhhc2g6IHNoYTI1Nl8xLnNoYTI1Nixcbn0pKSgpO1xuZXhwb3J0cy5oYXNoVG9DdXJ2ZSA9ICgoKSA9PiBodGYuaGFzaFRvQ3VydmUpKCk7XG5leHBvcnRzLmVuY29kZVRvQ3VydmUgPSAoKCkgPT4gaHRmLmVuY29kZVRvQ3VydmUpKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWNwMjU2azEuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW5jb2RlVG9DdXJ2ZSIsImhhc2hUb0N1cnZlIiwic2Nobm9yciIsInNlY3AyNTZrMSIsInNoYTI1Nl8xIiwicmVxdWlyZSIsInV0aWxzXzEiLCJtb2R1bGFyX2pzXzEiLCJ3ZWllcnN0cmFzc19qc18xIiwidXRpbHNfanNfMSIsImhhc2hfdG9fY3VydmVfanNfMSIsIl9zaG9ydHdfdXRpbHNfanNfMSIsInNlY3AyNTZrMVAiLCJCaWdJbnQiLCJzZWNwMjU2azFOIiwiXzFuIiwiXzJuIiwiZGl2TmVhcmVzdCIsImEiLCJiIiwic3FydE1vZCIsInkiLCJQIiwiXzNuIiwiXzZuIiwiXzExbiIsIl8yMm4iLCJfMjNuIiwiXzQ0biIsIl84OG4iLCJiMiIsImIzIiwiYjYiLCJwb3cyIiwiYjkiLCJiMTEiLCJiMjIiLCJiNDQiLCJiODgiLCJiMTc2IiwiYjIyMCIsImIyMjMiLCJ0MSIsInQyIiwicm9vdCIsIkZwIiwiZXFsIiwic3FyIiwiRXJyb3IiLCJGaWVsZCIsInVuZGVmaW5lZCIsInNxcnQiLCJjcmVhdGVDdXJ2ZSIsIm4iLCJHeCIsIkd5IiwiaCIsImxvd1MiLCJlbmRvIiwiYmV0YSIsInNwbGl0U2NhbGFyIiwiayIsImExIiwiYjEiLCJhMiIsIlBPV18yXzEyOCIsImMxIiwiYzIiLCJrMSIsIm1vZCIsImsyIiwiazFuZWciLCJrMm5lZyIsInNoYTI1NiIsIl8wbiIsImZlIiwieCIsImdlIiwiVEFHR0VEX0hBU0hfUFJFRklYRVMiLCJ0YWdnZWRIYXNoIiwidGFnIiwibWVzc2FnZXMiLCJ0YWdQIiwidGFnSCIsIlVpbnQ4QXJyYXkiLCJmcm9tIiwiYyIsImNoYXJDb2RlQXQiLCJjb25jYXRCeXRlcyIsInBvaW50VG9CeXRlcyIsInBvaW50IiwidG9SYXdCeXRlcyIsInNsaWNlIiwibnVtVG8zMmIiLCJudW1iZXJUb0J5dGVzQkUiLCJtb2RQIiwibW9kTiIsIlBvaW50IiwiUHJvamVjdGl2ZVBvaW50IiwiR211bEFkZCIsIlEiLCJCQVNFIiwibXVsdGlwbHlBbmRBZGRVbnNhZmUiLCJzY2hub3JyR2V0RXh0UHViS2V5IiwicHJpdiIsImRfIiwidXRpbHMiLCJub3JtUHJpdmF0ZUtleVRvU2NhbGFyIiwicCIsImZyb21Qcml2YXRlS2V5Iiwic2NhbGFyIiwiaGFzRXZlblkiLCJieXRlcyIsImxpZnRfeCIsInh4IiwiYXNzZXJ0VmFsaWRpdHkiLCJjaGFsbGVuZ2UiLCJhcmdzIiwiYnl0ZXNUb051bWJlckJFIiwic2Nobm9yckdldFB1YmxpY0tleSIsInByaXZhdGVLZXkiLCJzY2hub3JyU2lnbiIsIm1lc3NhZ2UiLCJhdXhSYW5kIiwicmFuZG9tQnl0ZXMiLCJtIiwiZW5zdXJlQnl0ZXMiLCJweCIsImQiLCJ0IiwicmFuZCIsImtfIiwicngiLCJlIiwic2lnIiwic2V0Iiwic2Nobm9yclZlcmlmeSIsInNpZ25hdHVyZSIsInB1YmxpY0tleSIsInB1YiIsInIiLCJzdWJhcnJheSIsInMiLCJSIiwidG9BZmZpbmUiLCJlcnJvciIsImdldFB1YmxpY0tleSIsInNpZ24iLCJ2ZXJpZnkiLCJyYW5kb21Qcml2YXRlS2V5IiwiaXNvTWFwIiwiaXNvZ2VueU1hcCIsIm1hcCIsImkiLCJqIiwibWFwU1dVIiwibWFwVG9DdXJ2ZVNpbXBsZVNXVSIsIkEiLCJCIiwiWiIsImNyZWF0ZSIsImh0ZiIsImNyZWF0ZUhhc2hlciIsInNjYWxhcnMiLCJEU1QiLCJlbmNvZGVEU1QiLCJPUkRFUiIsImV4cGFuZCIsImhhc2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/curves/secp256k1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/_assert.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ethereum-cryptography/node_modules/@noble/hashes/_assert.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);\n}\nexports.number = number;\nfunction bool(b) {\n    if (typeof b !== \"boolean\") throw new Error(`Expected boolean, not ${b}`);\n}\nexports.bool = bool;\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array)) throw new Error(\"Expected Uint8Array\");\n    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nexports.bytes = bytes;\nfunction hash(hash) {\n    if (typeof hash !== \"function\" || typeof hash.create !== \"function\") throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nexports.hash = hash;\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed) throw new Error(\"Hash instance has been destroyed\");\n    if (checkFinished && instance.finished) throw new Error(\"Hash#digest() has already been called\");\n}\nexports.exists = exists;\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexports.output = output;\nconst assert = {\n    number,\n    bool,\n    bytes,\n    hash,\n    exists,\n    output\n};\nexports[\"default\"] = assert; //# sourceMappingURL=_assert.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL19hc3NlcnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGNBQWMsR0FBR0EsY0FBYyxHQUFHQSxZQUFZLEdBQUdBLGFBQWEsR0FBR0EsWUFBWSxHQUFHQSxjQUFjLEdBQUcsS0FBSztBQUN0RyxTQUFTTyxPQUFPQyxDQUFDO0lBQ2IsSUFBSSxDQUFDQyxPQUFPQyxhQUFhLENBQUNGLE1BQU1BLElBQUksR0FDaEMsTUFBTSxJQUFJRyxNQUFNLENBQUMsd0JBQXdCLEVBQUVILEVBQUUsQ0FBQztBQUN0RDtBQUNBUixjQUFjLEdBQUdPO0FBQ2pCLFNBQVNELEtBQUtNLENBQUM7SUFDWCxJQUFJLE9BQU9BLE1BQU0sV0FDYixNQUFNLElBQUlELE1BQU0sQ0FBQyxzQkFBc0IsRUFBRUMsRUFBRSxDQUFDO0FBQ3BEO0FBQ0FaLFlBQVksR0FBR007QUFDZixTQUFTRCxNQUFNTyxDQUFDLEVBQUUsR0FBR0MsT0FBTztJQUN4QixJQUFJLENBQUVELENBQUFBLGFBQWFFLFVBQVMsR0FDeEIsTUFBTSxJQUFJSCxNQUFNO0lBQ3BCLElBQUlFLFFBQVFFLE1BQU0sR0FBRyxLQUFLLENBQUNGLFFBQVFHLFFBQVEsQ0FBQ0osRUFBRUcsTUFBTSxHQUNoRCxNQUFNLElBQUlKLE1BQU0sQ0FBQyw4QkFBOEIsRUFBRUUsUUFBUSxnQkFBZ0IsRUFBRUQsRUFBRUcsTUFBTSxDQUFDLENBQUM7QUFDN0Y7QUFDQWYsYUFBYSxHQUFHSztBQUNoQixTQUFTRCxLQUFLQSxJQUFJO0lBQ2QsSUFBSSxPQUFPQSxTQUFTLGNBQWMsT0FBT0EsS0FBS2EsTUFBTSxLQUFLLFlBQ3JELE1BQU0sSUFBSU4sTUFBTTtJQUNwQkosT0FBT0gsS0FBS2MsU0FBUztJQUNyQlgsT0FBT0gsS0FBS2UsUUFBUTtBQUN4QjtBQUNBbkIsWUFBWSxHQUFHSTtBQUNmLFNBQVNELE9BQU9pQixRQUFRLEVBQUVDLGdCQUFnQixJQUFJO0lBQzFDLElBQUlELFNBQVNFLFNBQVMsRUFDbEIsTUFBTSxJQUFJWCxNQUFNO0lBQ3BCLElBQUlVLGlCQUFpQkQsU0FBU0csUUFBUSxFQUNsQyxNQUFNLElBQUlaLE1BQU07QUFDeEI7QUFDQVgsY0FBYyxHQUFHRztBQUNqQixTQUFTRCxPQUFPc0IsR0FBRyxFQUFFSixRQUFRO0lBQ3pCZixNQUFNbUI7SUFDTixNQUFNQyxNQUFNTCxTQUFTRixTQUFTO0lBQzlCLElBQUlNLElBQUlULE1BQU0sR0FBR1UsS0FBSztRQUNsQixNQUFNLElBQUlkLE1BQU0sQ0FBQyxzREFBc0QsRUFBRWMsSUFBSSxDQUFDO0lBQ2xGO0FBQ0o7QUFDQXpCLGNBQWMsR0FBR0U7QUFDakIsTUFBTXdCLFNBQVM7SUFDWG5CO0lBQ0FEO0lBQ0FEO0lBQ0FEO0lBQ0FEO0lBQ0FEO0FBQ0o7QUFDQUYsa0JBQWUsR0FBRzBCLFFBQ2xCLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bS1jcnlwdG9ncmFwaHkvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX2Fzc2VydC5qcz9jZTIwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5vdXRwdXQgPSBleHBvcnRzLmV4aXN0cyA9IGV4cG9ydHMuaGFzaCA9IGV4cG9ydHMuYnl0ZXMgPSBleHBvcnRzLmJvb2wgPSBleHBvcnRzLm51bWJlciA9IHZvaWQgMDtcbmZ1bmN0aW9uIG51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBwb3NpdGl2ZSBpbnRlZ2VyOiAke259YCk7XG59XG5leHBvcnRzLm51bWJlciA9IG51bWJlcjtcbmZ1bmN0aW9uIGJvb2woYikge1xuICAgIGlmICh0eXBlb2YgYiAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGJvb2xlYW4sIG5vdCAke2J9YCk7XG59XG5leHBvcnRzLmJvb2wgPSBib29sO1xuZnVuY3Rpb24gYnl0ZXMoYiwgLi4ubGVuZ3Rocykge1xuICAgIGlmICghKGIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5Jyk7XG4gICAgaWYgKGxlbmd0aHMubGVuZ3RoID4gMCAmJiAhbGVuZ3Rocy5pbmNsdWRlcyhiLmxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgVWludDhBcnJheSBvZiBsZW5ndGggJHtsZW5ndGhzfSwgbm90IG9mIGxlbmd0aD0ke2IubGVuZ3RofWApO1xufVxuZXhwb3J0cy5ieXRlcyA9IGJ5dGVzO1xuZnVuY3Rpb24gaGFzaChoYXNoKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoYXNoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvcicpO1xuICAgIG51bWJlcihoYXNoLm91dHB1dExlbik7XG4gICAgbnVtYmVyKGhhc2guYmxvY2tMZW4pO1xufVxuZXhwb3J0cy5oYXNoID0gaGFzaDtcbmZ1bmN0aW9uIGV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuZXhwb3J0cy5leGlzdHMgPSBleGlzdHM7XG5mdW5jdGlvbiBvdXRwdXQob3V0LCBpbnN0YW5jZSkge1xuICAgIGJ5dGVzKG91dCk7XG4gICAgY29uc3QgbWluID0gaW5zdGFuY2Uub3V0cHV0TGVuO1xuICAgIGlmIChvdXQubGVuZ3RoIDwgbWluKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgJHttaW59YCk7XG4gICAgfVxufVxuZXhwb3J0cy5vdXRwdXQgPSBvdXRwdXQ7XG5jb25zdCBhc3NlcnQgPSB7XG4gICAgbnVtYmVyLFxuICAgIGJvb2wsXG4gICAgYnl0ZXMsXG4gICAgaGFzaCxcbiAgICBleGlzdHMsXG4gICAgb3V0cHV0LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGFzc2VydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9hc3NlcnQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwib3V0cHV0IiwiZXhpc3RzIiwiaGFzaCIsImJ5dGVzIiwiYm9vbCIsIm51bWJlciIsIm4iLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwiRXJyb3IiLCJiIiwibGVuZ3RocyIsIlVpbnQ4QXJyYXkiLCJsZW5ndGgiLCJpbmNsdWRlcyIsImNyZWF0ZSIsIm91dHB1dExlbiIsImJsb2NrTGVuIiwiaW5zdGFuY2UiLCJjaGVja0ZpbmlzaGVkIiwiZGVzdHJveWVkIiwiZmluaXNoZWQiLCJvdXQiLCJtaW4iLCJhc3NlcnQiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/_assert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/_sha2.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ethereum-cryptography/node_modules/@noble/hashes/_sha2.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SHA2 = void 0;\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/_assert.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/utils.js\");\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === \"function\") return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number(value >> _32n & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends utils_js_1.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE){\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0, utils_js_1.createView)(this.buffer);\n    }\n    update(data) {\n        _assert_js_1.default.exists(this);\n        const { view, buffer, blockLen } = this;\n        data = (0, utils_js_1.toBytes)(data);\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0, utils_js_1.createView)(data);\n                for(; blockLen <= len - pos; pos += blockLen)this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        _assert_js_1.default.exists(this);\n        _assert_js_1.default.output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 128;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for(let i = pos; i < blockLen; i++)buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0, utils_js_1.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4) throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length) throw new Error(\"_sha2: outputLen bigger than state\");\n        for(let i = 0; i < outLen; i++)oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen) to.buffer.set(buffer);\n        return to;\n    }\n}\nexports.SHA2 = SHA2; //# sourceMappingURL=_sha2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL19zaGEyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxZQUFZLEdBQUcsS0FBSztBQUNwQixNQUFNRyxlQUFlQyxtQkFBT0EsQ0FBQyxzR0FBYztBQUMzQyxNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQyxrR0FBWTtBQUN2Qyx5QkFBeUI7QUFDekIsU0FBU0UsYUFBYUMsSUFBSSxFQUFFQyxVQUFVLEVBQUVQLEtBQUssRUFBRVEsSUFBSTtJQUMvQyxJQUFJLE9BQU9GLEtBQUtELFlBQVksS0FBSyxZQUM3QixPQUFPQyxLQUFLRCxZQUFZLENBQUNFLFlBQVlQLE9BQU9RO0lBQ2hELE1BQU1DLE9BQU9DLE9BQU87SUFDcEIsTUFBTUMsV0FBV0QsT0FBTztJQUN4QixNQUFNRSxLQUFLQyxPQUFPLFNBQVVKLE9BQVFFO0lBQ3BDLE1BQU1HLEtBQUtELE9BQU9iLFFBQVFXO0lBQzFCLE1BQU1JLElBQUlQLE9BQU8sSUFBSTtJQUNyQixNQUFNUSxJQUFJUixPQUFPLElBQUk7SUFDckJGLEtBQUtXLFNBQVMsQ0FBQ1YsYUFBYVEsR0FBR0gsSUFBSUo7SUFDbkNGLEtBQUtXLFNBQVMsQ0FBQ1YsYUFBYVMsR0FBR0YsSUFBSU47QUFDdkM7QUFDQSw2QkFBNkI7QUFDN0IsTUFBTVAsYUFBYUcsV0FBV2MsSUFBSTtJQUM5QkMsWUFBWUMsUUFBUSxFQUFFQyxTQUFTLEVBQUVDLFNBQVMsRUFBRWQsSUFBSSxDQUFFO1FBQzlDLEtBQUs7UUFDTCxJQUFJLENBQUNZLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDQyxTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ0MsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNkLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNlLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ0MsR0FBRyxHQUFHO1FBQ1gsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDQyxNQUFNLEdBQUcsSUFBSUMsV0FBV1I7UUFDN0IsSUFBSSxDQUFDZCxJQUFJLEdBQUcsQ0FBQyxHQUFHRixXQUFXeUIsVUFBVSxFQUFFLElBQUksQ0FBQ0YsTUFBTTtJQUN0RDtJQUNBRyxPQUFPQyxJQUFJLEVBQUU7UUFDVDdCLGFBQWE4QixPQUFPLENBQUNDLE1BQU0sQ0FBQyxJQUFJO1FBQ2hDLE1BQU0sRUFBRTNCLElBQUksRUFBRXFCLE1BQU0sRUFBRVAsUUFBUSxFQUFFLEdBQUcsSUFBSTtRQUN2Q1csT0FBTyxDQUFDLEdBQUczQixXQUFXOEIsT0FBTyxFQUFFSDtRQUMvQixNQUFNSSxNQUFNSixLQUFLUCxNQUFNO1FBQ3ZCLElBQUssSUFBSUMsTUFBTSxHQUFHQSxNQUFNVSxLQUFNO1lBQzFCLE1BQU1DLE9BQU9DLEtBQUtDLEdBQUcsQ0FBQ2xCLFdBQVcsSUFBSSxDQUFDSyxHQUFHLEVBQUVVLE1BQU1WO1lBQ2pELDhFQUE4RTtZQUM5RSxJQUFJVyxTQUFTaEIsVUFBVTtnQkFDbkIsTUFBTW1CLFdBQVcsQ0FBQyxHQUFHbkMsV0FBV3lCLFVBQVUsRUFBRUU7Z0JBQzVDLE1BQU9YLFlBQVllLE1BQU1WLEtBQUtBLE9BQU9MLFNBQ2pDLElBQUksQ0FBQ29CLE9BQU8sQ0FBQ0QsVUFBVWQ7Z0JBQzNCO1lBQ0o7WUFDQUUsT0FBT2MsR0FBRyxDQUFDVixLQUFLVyxRQUFRLENBQUNqQixLQUFLQSxNQUFNVyxPQUFPLElBQUksQ0FBQ1gsR0FBRztZQUNuRCxJQUFJLENBQUNBLEdBQUcsSUFBSVc7WUFDWlgsT0FBT1c7WUFDUCxJQUFJLElBQUksQ0FBQ1gsR0FBRyxLQUFLTCxVQUFVO2dCQUN2QixJQUFJLENBQUNvQixPQUFPLENBQUNsQyxNQUFNO2dCQUNuQixJQUFJLENBQUNtQixHQUFHLEdBQUc7WUFDZjtRQUNKO1FBQ0EsSUFBSSxDQUFDRCxNQUFNLElBQUlPLEtBQUtQLE1BQU07UUFDMUIsSUFBSSxDQUFDbUIsVUFBVTtRQUNmLE9BQU8sSUFBSTtJQUNmO0lBQ0FDLFdBQVdDLEdBQUcsRUFBRTtRQUNaM0MsYUFBYThCLE9BQU8sQ0FBQ0MsTUFBTSxDQUFDLElBQUk7UUFDaEMvQixhQUFhOEIsT0FBTyxDQUFDYyxNQUFNLENBQUNELEtBQUssSUFBSTtRQUNyQyxJQUFJLENBQUN0QixRQUFRLEdBQUc7UUFDaEIsVUFBVTtRQUNWLGlFQUFpRTtRQUNqRSxzRUFBc0U7UUFDdEUsTUFBTSxFQUFFSSxNQUFNLEVBQUVyQixJQUFJLEVBQUVjLFFBQVEsRUFBRVosSUFBSSxFQUFFLEdBQUcsSUFBSTtRQUM3QyxJQUFJLEVBQUVpQixHQUFHLEVBQUUsR0FBRyxJQUFJO1FBQ2xCLG9DQUFvQztRQUNwQ0UsTUFBTSxDQUFDRixNQUFNLEdBQUc7UUFDaEIsSUFBSSxDQUFDRSxNQUFNLENBQUNlLFFBQVEsQ0FBQ2pCLEtBQUtzQixJQUFJLENBQUM7UUFDL0Isc0hBQXNIO1FBQ3RILElBQUksSUFBSSxDQUFDekIsU0FBUyxHQUFHRixXQUFXSyxLQUFLO1lBQ2pDLElBQUksQ0FBQ2UsT0FBTyxDQUFDbEMsTUFBTTtZQUNuQm1CLE1BQU07UUFDVjtRQUNBLHVDQUF1QztRQUN2QyxJQUFLLElBQUl1QixJQUFJdkIsS0FBS3VCLElBQUk1QixVQUFVNEIsSUFDNUJyQixNQUFNLENBQUNxQixFQUFFLEdBQUc7UUFDaEIsZ0dBQWdHO1FBQ2hHLG9GQUFvRjtRQUNwRixpREFBaUQ7UUFDakQzQyxhQUFhQyxNQUFNYyxXQUFXLEdBQUdWLE9BQU8sSUFBSSxDQUFDYyxNQUFNLEdBQUcsSUFBSWhCO1FBQzFELElBQUksQ0FBQ2dDLE9BQU8sQ0FBQ2xDLE1BQU07UUFDbkIsTUFBTTJDLFFBQVEsQ0FBQyxHQUFHN0MsV0FBV3lCLFVBQVUsRUFBRWdCO1FBQ3pDLE1BQU1WLE1BQU0sSUFBSSxDQUFDZCxTQUFTO1FBQzFCLHlGQUF5RjtRQUN6RixJQUFJYyxNQUFNLEdBQ04sTUFBTSxJQUFJZSxNQUFNO1FBQ3BCLE1BQU1DLFNBQVNoQixNQUFNO1FBQ3JCLE1BQU1pQixRQUFRLElBQUksQ0FBQ0MsR0FBRztRQUN0QixJQUFJRixTQUFTQyxNQUFNNUIsTUFBTSxFQUNyQixNQUFNLElBQUkwQixNQUFNO1FBQ3BCLElBQUssSUFBSUYsSUFBSSxHQUFHQSxJQUFJRyxRQUFRSCxJQUN4QkMsTUFBTWhDLFNBQVMsQ0FBQyxJQUFJK0IsR0FBR0ksS0FBSyxDQUFDSixFQUFFLEVBQUV4QztJQUN6QztJQUNBOEMsU0FBUztRQUNMLE1BQU0sRUFBRTNCLE1BQU0sRUFBRU4sU0FBUyxFQUFFLEdBQUcsSUFBSTtRQUNsQyxJQUFJLENBQUN1QixVQUFVLENBQUNqQjtRQUNoQixNQUFNNEIsTUFBTTVCLE9BQU82QixLQUFLLENBQUMsR0FBR25DO1FBQzVCLElBQUksQ0FBQ29DLE9BQU87UUFDWixPQUFPRjtJQUNYO0lBQ0FHLFdBQVdDLEVBQUUsRUFBRTtRQUNYQSxNQUFPQSxDQUFBQSxLQUFLLElBQUksSUFBSSxDQUFDeEMsV0FBVyxFQUFDO1FBQ2pDd0MsR0FBR2xCLEdBQUcsSUFBSSxJQUFJLENBQUNZLEdBQUc7UUFDbEIsTUFBTSxFQUFFakMsUUFBUSxFQUFFTyxNQUFNLEVBQUVILE1BQU0sRUFBRUQsUUFBUSxFQUFFRyxTQUFTLEVBQUVELEdBQUcsRUFBRSxHQUFHLElBQUk7UUFDbkVrQyxHQUFHbkMsTUFBTSxHQUFHQTtRQUNabUMsR0FBR2xDLEdBQUcsR0FBR0E7UUFDVGtDLEdBQUdwQyxRQUFRLEdBQUdBO1FBQ2RvQyxHQUFHakMsU0FBUyxHQUFHQTtRQUNmLElBQUlGLFNBQVNKLFVBQ1R1QyxHQUFHaEMsTUFBTSxDQUFDYyxHQUFHLENBQUNkO1FBQ2xCLE9BQU9nQztJQUNYO0FBQ0o7QUFDQTVELFlBQVksR0FBR0UsTUFDZixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL19zaGEyLmpzPzQxYjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNIQTIgPSB2b2lkIDA7XG5jb25zdCBfYXNzZXJ0X2pzXzEgPSByZXF1aXJlKFwiLi9fYXNzZXJ0LmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gUG9seWZpbGwgZm9yIFNhZmFyaSAxNFxuZnVuY3Rpb24gc2V0QmlnVWludDY0KHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZpZXcuc2V0QmlnVWludDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKTtcbiAgICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbiAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgICBjb25zdCB3aCA9IE51bWJlcigodmFsdWUgPj4gXzMybikgJiBfdTMyX21heCk7XG4gICAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XG4gICAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcbiAgICBjb25zdCBsID0gaXNMRSA/IDAgOiA0O1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcbn1cbi8vIEJhc2UgU0hBMiBjbGFzcyAoUkZDIDYyMzQpXG5jbGFzcyBTSEEyIGV4dGVuZHMgdXRpbHNfanNfMS5IYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgb3V0cHV0TGVuLCBwYWRPZmZzZXQsIGlzTEUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5wYWRPZmZzZXQgPSBwYWRPZmZzZXQ7XG4gICAgICAgIHRoaXMuaXNMRSA9IGlzTEU7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICB0aGlzLnZpZXcgPSAoMCwgdXRpbHNfanNfMS5jcmVhdGVWaWV3KSh0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIF9hc3NlcnRfanNfMS5kZWZhdWx0LmV4aXN0cyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyB2aWV3LCBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gKDAsIHV0aWxzX2pzXzEudG9CeXRlcykoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIC8vIEZhc3QgcGF0aDogd2UgaGF2ZSBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gaW5wdXQsIGNhc3QgaXQgdG8gdmlldyBhbmQgcHJvY2Vzc1xuICAgICAgICAgICAgaWYgKHRha2UgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSAoMCwgdXRpbHNfanNfMS5jcmVhdGVWaWV3KShkYXRhKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhkYXRhVmlldywgcG9zKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5yb3VuZENsZWFuKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5leGlzdHModGhpcyk7XG4gICAgICAgIF9hc3NlcnRfanNfMS5kZWZhdWx0Lm91dHB1dChvdXQsIHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gUGFkZGluZ1xuICAgICAgICAvLyBXZSBjYW4gYXZvaWQgYWxsb2NhdGlvbiBvZiBidWZmZXIgZm9yIHBhZGRpbmcgY29tcGxldGVseSBpZiBpdFxuICAgICAgICAvLyB3YXMgcHJldmlvdXNseSBub3QgYWxsb2NhdGVkIGhlcmUuIEJ1dCBpdCB3b24ndCBjaGFuZ2UgcGVyZm9ybWFuY2UuXG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCB2aWV3LCBibG9ja0xlbiwgaXNMRSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcG9zIH0gPSB0aGlzO1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGJpdCAnMScgdG8gdGhlIG1lc3NhZ2VcbiAgICAgICAgYnVmZmVyW3BvcysrXSA9IDBiMTAwMDAwMDA7XG4gICAgICAgIHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvcykuZmlsbCgwKTtcbiAgICAgICAgLy8gd2UgaGF2ZSBsZXNzIHRoYW4gcGFkT2Zmc2V0IGxlZnQgaW4gYnVmZmVyLCBzbyB3ZSBjYW5ub3QgcHV0IGxlbmd0aCBpbiBjdXJyZW50IGJsb2NrLCBuZWVkIHByb2Nlc3MgaXQgYW5kIHBhZCBhZ2FpblxuICAgICAgICBpZiAodGhpcy5wYWRPZmZzZXQgPiBibG9ja0xlbiAtIHBvcykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWQgdW50aWwgZnVsbCBibG9jayBieXRlIHdpdGggemVyb3NcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGJsb2NrTGVuOyBpKyspXG4gICAgICAgICAgICBidWZmZXJbaV0gPSAwO1xuICAgICAgICAvLyBOb3RlOiBzaGE1MTIgcmVxdWlyZXMgbGVuZ3RoIHRvIGJlIDEyOGJpdCBpbnRlZ2VyLCBidXQgbGVuZ3RoIGluIEpTIHdpbGwgb3ZlcmZsb3cgYmVmb3JlIHRoYXRcbiAgICAgICAgLy8gWW91IG5lZWQgdG8gd3JpdGUgYXJvdW5kIDIgZXhhYnl0ZXMgKHU2NF9tYXggLyA4IC8gKDEwMjQqKjYpKSBmb3IgdGhpcyB0byBoYXBwZW4uXG4gICAgICAgIC8vIFNvIHdlIGp1c3Qgd3JpdGUgbG93ZXN0IDY0IGJpdHMgb2YgdGhhdCB2YWx1ZS5cbiAgICAgICAgc2V0QmlnVWludDY0KHZpZXcsIGJsb2NrTGVuIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIGlzTEUpO1xuICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgIGNvbnN0IG92aWV3ID0gKDAsIHV0aWxzX2pzXzEuY3JlYXRlVmlldykob3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIHNob3VsZCBiZSBmdXNlZCBpbiBzaW5nbGUgb3Agd2l0aCBtb2R1bG8gYnkgSklUXG4gICAgICAgIGlmIChsZW4gJSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XG4gICAgICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgICAgICAgICAgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRvLnBvcyA9IHBvcztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG5leHBvcnRzLlNIQTIgPSBTSEEyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3NoYTIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiU0hBMiIsIl9hc3NlcnRfanNfMSIsInJlcXVpcmUiLCJ1dGlsc19qc18xIiwic2V0QmlnVWludDY0IiwidmlldyIsImJ5dGVPZmZzZXQiLCJpc0xFIiwiXzMybiIsIkJpZ0ludCIsIl91MzJfbWF4Iiwid2giLCJOdW1iZXIiLCJ3bCIsImgiLCJsIiwic2V0VWludDMyIiwiSGFzaCIsImNvbnN0cnVjdG9yIiwiYmxvY2tMZW4iLCJvdXRwdXRMZW4iLCJwYWRPZmZzZXQiLCJmaW5pc2hlZCIsImxlbmd0aCIsInBvcyIsImRlc3Ryb3llZCIsImJ1ZmZlciIsIlVpbnQ4QXJyYXkiLCJjcmVhdGVWaWV3IiwidXBkYXRlIiwiZGF0YSIsImRlZmF1bHQiLCJleGlzdHMiLCJ0b0J5dGVzIiwibGVuIiwidGFrZSIsIk1hdGgiLCJtaW4iLCJkYXRhVmlldyIsInByb2Nlc3MiLCJzZXQiLCJzdWJhcnJheSIsInJvdW5kQ2xlYW4iLCJkaWdlc3RJbnRvIiwib3V0Iiwib3V0cHV0IiwiZmlsbCIsImkiLCJvdmlldyIsIkVycm9yIiwib3V0TGVuIiwic3RhdGUiLCJnZXQiLCJkaWdlc3QiLCJyZXMiLCJzbGljZSIsImRlc3Ryb3kiLCJfY2xvbmVJbnRvIiwidG8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/_sha2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/_u64.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/ethereum-cryptography/node_modules/@noble/hashes/_u64.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.add = exports.toBig = exports.split = exports.fromBig = void 0;\nconst U32_MASK64 = BigInt(2 ** 32 - 1);\nconst _32n = BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le) return {\n        h: Number(n & U32_MASK64),\n        l: Number(n >> _32n & U32_MASK64)\n    };\n    return {\n        h: Number(n >> _32n & U32_MASK64) | 0,\n        l: Number(n & U32_MASK64) | 0\n    };\n}\nexports.fromBig = fromBig;\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for(let i = 0; i < lst.length; i++){\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [\n            h,\n            l\n        ];\n    }\n    return [\n        Ah,\n        Al\n    ];\n}\nexports.split = split;\nconst toBig = (h, l)=>BigInt(h >>> 0) << _32n | BigInt(l >>> 0);\nexports.toBig = toBig;\n// for Shift in [0, 32)\nconst shrSH = (h, l, s)=>h >>> s;\nconst shrSL = (h, l, s)=>h << 32 - s | l >>> s;\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s)=>h >>> s | l << 32 - s;\nconst rotrSL = (h, l, s)=>h << 32 - s | l >>> s;\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s)=>h << 64 - s | l >>> s - 32;\nconst rotrBL = (h, l, s)=>h >>> s - 32 | l << 64 - s;\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (h, l)=>l;\nconst rotr32L = (h, l)=>h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s)=>h << s | l >>> 32 - s;\nconst rotlSL = (h, l, s)=>l << s | h >>> 32 - s;\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s)=>l << s - 32 | h >>> 64 - s;\nconst rotlBL = (h, l, s)=>h << s - 32 | l >>> 64 - s;\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\n// Removing \"export\" has 5% perf penalty -_-\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return {\n        h: Ah + Bh + (l / 2 ** 32 | 0) | 0,\n        l: l | 0\n    };\n}\nexports.add = add;\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch)=>Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;\nconst add4L = (Al, Bl, Cl, Dl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh)=>Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh)=>Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;\n// prettier-ignore\nconst u64 = {\n    fromBig,\n    split,\n    toBig: exports.toBig,\n    shrSH,\n    shrSL,\n    rotrSH,\n    rotrSL,\n    rotrBH,\n    rotrBL,\n    rotr32H,\n    rotr32L,\n    rotlSH,\n    rotlSL,\n    rotlBH,\n    rotlBL,\n    add,\n    add3L,\n    add3H,\n    add4L,\n    add4H,\n    add5H,\n    add5L\n};\nexports[\"default\"] = u64; //# sourceMappingURL=_u64.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL191NjQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELFdBQVcsR0FBR0EsYUFBYSxHQUFHQSxhQUFhLEdBQUdBLGVBQWUsR0FBRyxLQUFLO0FBQ3JFLE1BQU1NLGFBQWFDLE9BQU8sS0FBSyxLQUFLO0FBQ3BDLE1BQU1DLE9BQU9ELE9BQU87QUFDcEIsK0VBQStFO0FBQy9FLFNBQVNGLFFBQVFJLENBQUMsRUFBRUMsS0FBSyxLQUFLO0lBQzFCLElBQUlBLElBQ0EsT0FBTztRQUFFQyxHQUFHQyxPQUFPSCxJQUFJSDtRQUFhTyxHQUFHRCxPQUFPLEtBQU1KLE9BQVFGO0lBQVk7SUFDNUUsT0FBTztRQUFFSyxHQUFHQyxPQUFPLEtBQU1KLE9BQVFGLGNBQWM7UUFBR08sR0FBR0QsT0FBT0gsSUFBSUgsY0FBYztJQUFFO0FBQ3BGO0FBQ0FOLGVBQWUsR0FBR0s7QUFDbEIsU0FBU0QsTUFBTVUsR0FBRyxFQUFFSixLQUFLLEtBQUs7SUFDMUIsSUFBSUssS0FBSyxJQUFJQyxZQUFZRixJQUFJRyxNQUFNO0lBQ25DLElBQUlDLEtBQUssSUFBSUYsWUFBWUYsSUFBSUcsTUFBTTtJQUNuQyxJQUFLLElBQUlFLElBQUksR0FBR0EsSUFBSUwsSUFBSUcsTUFBTSxFQUFFRSxJQUFLO1FBQ2pDLE1BQU0sRUFBRVIsQ0FBQyxFQUFFRSxDQUFDLEVBQUUsR0FBR1IsUUFBUVMsR0FBRyxDQUFDSyxFQUFFLEVBQUVUO1FBQ2pDLENBQUNLLEVBQUUsQ0FBQ0ksRUFBRSxFQUFFRCxFQUFFLENBQUNDLEVBQUUsQ0FBQyxHQUFHO1lBQUNSO1lBQUdFO1NBQUU7SUFDM0I7SUFDQSxPQUFPO1FBQUNFO1FBQUlHO0tBQUc7QUFDbkI7QUFDQWxCLGFBQWEsR0FBR0k7QUFDaEIsTUFBTUQsUUFBUSxD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UUcsS0FBSztJQUNwQ2lCO0lBQU9FO0lBQ1BDO0lBQVFDO0lBQVFDO0lBQVFDO0lBQ3hCQztJQUFTQztJQUNUQztJQUFRQztJQUFRQztJQUFRQztJQUN4QjlCO0lBQUtpQztJQUFPRTtJQUFPRztJQUFPRTtJQUFPSTtJQUFPRjtBQUM1QztBQUNBNUMsa0JBQWUsR0FBR2dELEtBQ2xCLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bS1jcnlwdG9ncmFwaHkvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX3U2NC5qcz8wYmFiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hZGQgPSBleHBvcnRzLnRvQmlnID0gZXhwb3J0cy5zcGxpdCA9IGV4cG9ydHMuZnJvbUJpZyA9IHZvaWQgMDtcbmNvbnN0IFUzMl9NQVNLNjQgPSBCaWdJbnQoMiAqKiAzMiAtIDEpO1xuY29uc3QgXzMybiA9IEJpZ0ludCgzMik7XG4vLyBXZSBhcmUgbm90IHVzaW5nIEJpZ1VpbnQ2NEFycmF5LCBiZWNhdXNlIHRoZXkgYXJlIGV4dHJlbWVseSBzbG93IGFzIHBlciAyMDIyXG5mdW5jdGlvbiBmcm9tQmlnKG4sIGxlID0gZmFsc2UpIHtcbiAgICBpZiAobGUpXG4gICAgICAgIHJldHVybiB7IGg6IE51bWJlcihuICYgVTMyX01BU0s2NCksIGw6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIH07XG4gICAgcmV0dXJuIHsgaDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfCAwLCBsOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpIHwgMCB9O1xufVxuZXhwb3J0cy5mcm9tQmlnID0gZnJvbUJpZztcbmZ1bmN0aW9uIHNwbGl0KGxzdCwgbGUgPSBmYWxzZSkge1xuICAgIGxldCBBaCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBsZXQgQWwgPSBuZXcgVWludDMyQXJyYXkobHN0Lmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyBoLCBsIH0gPSBmcm9tQmlnKGxzdFtpXSwgbGUpO1xuICAgICAgICBbQWhbaV0sIEFsW2ldXSA9IFtoLCBsXTtcbiAgICB9XG4gICAgcmV0dXJuIFtBaCwgQWxdO1xufVxuZXhwb3J0cy5zcGxpdCA9IHNwbGl0O1xuY29uc3QgdG9CaWcgPSAoaCwgbCkgPT4gKEJpZ0ludChoID4+PiAwKSA8PCBfMzJuKSB8IEJpZ0ludChsID4+PiAwKTtcbmV4cG9ydHMudG9CaWcgPSB0b0JpZztcbi8vIGZvciBTaGlmdCBpbiBbMCwgMzIpXG5jb25zdCBzaHJTSCA9IChoLCBsLCBzKSA9PiBoID4+PiBzO1xuY29uc3Qgc2hyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RyU0ggPSAoaCwgbCwgcykgPT4gKGggPj4+IHMpIHwgKGwgPDwgKDMyIC0gcykpO1xuY29uc3Qgcm90clNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdHJCSCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoNjQgLSBzKSkgfCAobCA+Pj4gKHMgLSAzMikpO1xuY29uc3Qgcm90ckJMID0gKGgsIGwsIHMpID0+IChoID4+PiAocyAtIDMyKSkgfCAobCA8PCAoNjQgLSBzKSk7XG4vLyBSaWdodCByb3RhdGUgZm9yIHNoaWZ0PT09MzIgKGp1c3Qgc3dhcHMgbCZoKVxuY29uc3Qgcm90cjMySCA9IChoLCBsKSA9PiBsO1xuY29uc3Qgcm90cjMyTCA9IChoLCBsKSA9PiBoO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdGxTSCA9IChoLCBsLCBzKSA9PiAoaCA8PCBzKSB8IChsID4+PiAoMzIgLSBzKSk7XG5jb25zdCByb3RsU0wgPSAoaCwgbCwgcykgPT4gKGwgPDwgcykgfCAoaCA+Pj4gKDMyIC0gcykpO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RsQkggPSAoaCwgbCwgcykgPT4gKGwgPDwgKHMgLSAzMikpIHwgKGggPj4+ICg2NCAtIHMpKTtcbmNvbnN0IHJvdGxCTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAocyAtIDMyKSkgfCAobCA+Pj4gKDY0IC0gcykpO1xuLy8gSlMgdXNlcyAzMi1iaXQgc2lnbmVkIGludGVnZXJzIGZvciBiaXR3aXNlIG9wZXJhdGlvbnMgd2hpY2ggbWVhbnMgd2UgY2Fubm90XG4vLyBzaW1wbGUgdGFrZSBjYXJyeSBvdXQgb2YgbG93IGJpdCBzdW0gYnkgc2hpZnQsIHdlIG5lZWQgdG8gdXNlIGRpdmlzaW9uLlxuLy8gUmVtb3ZpbmcgXCJleHBvcnRcIiBoYXMgNSUgcGVyZiBwZW5hbHR5IC1fLVxuZnVuY3Rpb24gYWRkKEFoLCBBbCwgQmgsIEJsKSB7XG4gICAgY29uc3QgbCA9IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApO1xuICAgIHJldHVybiB7IGg6IChBaCArIEJoICsgKChsIC8gMiAqKiAzMikgfCAwKSkgfCAwLCBsOiBsIHwgMCB9O1xufVxuZXhwb3J0cy5hZGQgPSBhZGQ7XG4vLyBBZGRpdGlvbiB3aXRoIG1vcmUgdGhhbiAyIGVsZW1lbnRzXG5jb25zdCBhZGQzTCA9IChBbCwgQmwsIENsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCk7XG5jb25zdCBhZGQzSCA9IChsb3csIEFoLCBCaCwgQ2gpID0+IChBaCArIEJoICsgQ2ggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDRMID0gKEFsLCBCbCwgQ2wsIERsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApO1xuY29uc3QgYWRkNEggPSAobG93LCBBaCwgQmgsIENoLCBEaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ1TCA9IChBbCwgQmwsIENsLCBEbCwgRWwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCkgKyAoRWwgPj4+IDApO1xuY29uc3QgYWRkNUggPSAobG93LCBBaCwgQmgsIENoLCBEaCwgRWgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArIEVoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IHU2NCA9IHtcbiAgICBmcm9tQmlnLCBzcGxpdCwgdG9CaWc6IGV4cG9ydHMudG9CaWcsXG4gICAgc2hyU0gsIHNoclNMLFxuICAgIHJvdHJTSCwgcm90clNMLCByb3RyQkgsIHJvdHJCTCxcbiAgICByb3RyMzJILCByb3RyMzJMLFxuICAgIHJvdGxTSCwgcm90bFNMLCByb3RsQkgsIHJvdGxCTCxcbiAgICBhZGQsIGFkZDNMLCBhZGQzSCwgYWRkNEwsIGFkZDRILCBhZGQ1SCwgYWRkNUwsXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gdTY0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3U2NC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJhZGQiLCJ0b0JpZyIsInNwbGl0IiwiZnJvbUJpZyIsIlUzMl9NQVNLNjQiLCJCaWdJbnQiLCJfMzJuIiwibiIsImxlIiwiaCIsIk51bWJlciIsImwiLCJsc3QiLCJBaCIsIlVpbnQzMkFycmF5IiwibGVuZ3RoIiwiQWwiLCJpIiwic2hyU0giLCJzIiwic2hyU0wiLCJyb3RyU0giLCJyb3RyU0wiLCJyb3RyQkgiLCJyb3RyQkwiLCJyb3RyMzJIIiwicm90cjMyTCIsInJvdGxTSCIsInJvdGxTTCIsInJvdGxCSCIsInJvdGxCTCIsIkJoIiwiQmwiLCJhZGQzTCIsIkNsIiwiYWRkM0giLCJsb3ciLCJDaCIsImFkZDRMIiwiRGwiLCJhZGQ0SCIsIkRoIiwiYWRkNUwiLCJFbCIsImFkZDVIIiwiRWgiLCJ1NjQiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/_u64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/cryptoNode.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/ethereum-cryptography/node_modules/@noble/hashes/cryptoNode.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.crypto = void 0;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\n// The file will throw on node.js 14 and earlier.\n// @ts-ignore\nconst nc = __webpack_require__(/*! node:crypto */ \"node:crypto\");\nexports.crypto = nc && typeof nc === \"object\" && \"webcrypto\" in nc ? nc.webcrypto : undefined; //# sourceMappingURL=cryptoNode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2NyeXB0b05vZGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGNBQWMsR0FBRyxLQUFLO0FBQ3RCLG9GQUFvRjtBQUNwRiw0QkFBNEI7QUFDNUIsaURBQWlEO0FBQ2pELGFBQWE7QUFDYixNQUFNRyxLQUFLQyxtQkFBT0EsQ0FBQyxnQ0FBYTtBQUNoQ0osY0FBYyxHQUFHRyxNQUFNLE9BQU9BLE9BQU8sWUFBWSxlQUFlQSxLQUFLQSxHQUFHRSxTQUFTLEdBQUdDLFdBQ3BGLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bS1jcnlwdG9ncmFwaHkvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvY3J5cHRvTm9kZS5qcz9hMTNjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcnlwdG8gPSB2b2lkIDA7XG4vLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbi8vIFNlZSB1dGlscy50cyBmb3IgZGV0YWlscy5cbi8vIFRoZSBmaWxlIHdpbGwgdGhyb3cgb24gbm9kZS5qcyAxNCBhbmQgZWFybGllci5cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IG5jID0gcmVxdWlyZShcIm5vZGU6Y3J5cHRvXCIpO1xuZXhwb3J0cy5jcnlwdG8gPSBuYyAmJiB0eXBlb2YgbmMgPT09ICdvYmplY3QnICYmICd3ZWJjcnlwdG8nIGluIG5jID8gbmMud2ViY3J5cHRvIDogdW5kZWZpbmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvTm9kZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjcnlwdG8iLCJuYyIsInJlcXVpcmUiLCJ3ZWJjcnlwdG8iLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/cryptoNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/hmac.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/ethereum-cryptography/node_modules/@noble/hashes/hmac.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.hmac = exports.HMAC = void 0;\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/_assert.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/utils.js\");\n// HMAC (RFC 2104)\nclass HMAC extends utils_js_1.Hash {\n    constructor(hash, _key){\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        _assert_js_1.default.hash(hash);\n        const key = (0, utils_js_1.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== \"function\") throw new Error(\"Expected instance of class which extends utils.Hash\");\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        _assert_js_1.default.exists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        _assert_js_1.default.exists(this);\n        _assert_js_1.default.bytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\nexports.HMAC = HMAC;\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */ const hmac = (hash, key, message)=>new HMAC(hash, key).update(message).digest();\nexports.hmac = hmac;\nexports.hmac.create = (hash, key)=>new HMAC(hash, key); //# sourceMappingURL=hmac.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2htYWMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELFlBQVksR0FBR0EsWUFBWSxHQUFHLEtBQUs7QUFDbkMsTUFBTUksZUFBZUMsbUJBQU9BLENBQUMsc0dBQWM7QUFDM0MsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsa0dBQVk7QUFDdkMsa0JBQWtCO0FBQ2xCLE1BQU1GLGFBQWFHLFdBQVdDLElBQUk7SUFDOUJDLFlBQVlDLElBQUksRUFBRUMsSUFBSSxDQUFFO1FBQ3BCLEtBQUs7UUFDTCxJQUFJLENBQUNDLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNDLFNBQVMsR0FBRztRQUNqQlIsYUFBYVMsT0FBTyxDQUFDSixJQUFJLENBQUNBO1FBQzFCLE1BQU1LLE1BQU0sQ0FBQyxHQUFHUixXQUFXUyxPQUFPLEVBQUVMO1FBQ3BDLElBQUksQ0FBQ00sS0FBSyxHQUFHUCxLQUFLUSxNQUFNO1FBQ3hCLElBQUksT0FBTyxJQUFJLENBQUNELEtBQUssQ0FBQ0UsTUFBTSxLQUFLLFlBQzdCLE1BQU0sSUFBSUMsTUFBTTtRQUNwQixJQUFJLENBQUNDLFFBQVEsR0FBRyxJQUFJLENBQUNKLEtBQUssQ0FBQ0ksUUFBUTtRQUNuQyxJQUFJLENBQUNDLFNBQVMsR0FBRyxJQUFJLENBQUNMLEtBQUssQ0FBQ0ssU0FBUztRQUNyQyxNQUFNRCxXQUFXLElBQUksQ0FBQ0EsUUFBUTtRQUM5QixNQUFNRSxNQUFNLElBQUlDLFdBQVdIO1FBQzNCLHdDQUF3QztRQUN4Q0UsSUFBSUUsR0FBRyxDQUFDVixJQUFJVyxNQUFNLEdBQUdMLFdBQVdYLEtBQUtRLE1BQU0sR0FBR0MsTUFBTSxDQUFDSixLQUFLWSxNQUFNLEtBQUtaO1FBQ3JFLElBQUssSUFBSWEsSUFBSSxHQUFHQSxJQUFJTCxJQUFJRyxNQUFNLEVBQUVFLElBQzVCTCxHQUFHLENBQUNLLEVBQUUsSUFBSTtRQUNkLElBQUksQ0FBQ1gsS0FBSyxDQUFDRSxNQUFNLENBQUNJO1FBQ2xCLG1IQUFtSDtRQUNuSCxJQUFJLENBQUNNLEtBQUssR0FBR25CLEtBQUtRLE1BQU07UUFDeEIsdUNBQXVDO1FBQ3ZDLElBQUssSUFBSVUsSUFBSSxHQUFHQSxJQUFJTCxJQUFJRyxNQUFNLEVBQUVFLElBQzVCTCxHQUFHLENBQUNLLEVBQUUsSUFBSSxPQUFPO1FBQ3JCLElBQUksQ0FBQ0MsS0FBSyxDQUFDVixNQUFNLENBQUNJO1FBQ2xCQSxJQUFJTyxJQUFJLENBQUM7SUFDYjtJQUNBWCxPQUFPWSxHQUFHLEVBQUU7UUFDUjFCLGFBQWFTLE9BQU8sQ0FBQ2tCLE1BQU0sQ0FBQyxJQUFJO1FBQ2hDLElBQUksQ0FBQ2YsS0FBSyxDQUFDRSxNQUFNLENBQUNZO1FBQ2xCLE9BQU8sSUFBSTtJQUNmO0lBQ0FFLFdBQVdDLEdBQUcsRUFBRTtRQUNaN0IsYUFBYVMsT0FBTyxDQUFDa0IsTUFBTSxDQUFDLElBQUk7UUFDaEMzQixhQUFhUyxPQUFPLENBQUNxQixLQUFLLENBQUNELEtBQUssSUFBSSxDQUFDWixTQUFTO1FBQzlDLElBQUksQ0FBQ1YsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0ssS0FBSyxDQUFDZ0IsVUFBVSxDQUFDQztRQUN0QixJQUFJLENBQUNMLEtBQUssQ0FBQ1YsTUFBTSxDQUFDZTtRQUNsQixJQUFJLENBQUNMLEtBQUssQ0FBQ0ksVUFBVSxDQUFDQztRQUN0QixJQUFJLENBQUNFLE9BQU87SUFDaEI7SUFDQVQsU0FBUztRQUNMLE1BQU1PLE1BQU0sSUFBSVYsV0FBVyxJQUFJLENBQUNLLEtBQUssQ0FBQ1AsU0FBUztRQUMvQyxJQUFJLENBQUNXLFVBQVUsQ0FBQ0M7UUFDaEIsT0FBT0E7SUFDWDtJQUNBRyxXQUFXQyxFQUFFLEVBQUU7UUFDWCxtR0FBbUc7UUFDbkdBLE1BQU9BLENBQUFBLEtBQUt2QyxPQUFPbUIsTUFBTSxDQUFDbkIsT0FBT3dDLGNBQWMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxFQUFDO1FBQ3pELE1BQU0sRUFBRVYsS0FBSyxFQUFFWixLQUFLLEVBQUVMLFFBQVEsRUFBRUMsU0FBUyxFQUFFUSxRQUFRLEVBQUVDLFNBQVMsRUFBRSxHQUFHLElBQUk7UUFDdkVnQixLQUFLQTtRQUNMQSxHQUFHMUIsUUFBUSxHQUFHQTtRQUNkMEIsR0FBR3pCLFNBQVMsR0FBR0E7UUFDZnlCLEdBQUdqQixRQUFRLEdBQUdBO1FBQ2RpQixHQUFHaEIsU0FBUyxHQUFHQTtRQUNmZ0IsR0FBR1QsS0FBSyxHQUFHQSxNQUFNUSxVQUFVLENBQUNDLEdBQUdULEtBQUs7UUFDcENTLEdBQUdyQixLQUFLLEdBQUdBLE1BQU1vQixVQUFVLENBQUNDLEdBQUdyQixLQUFLO1FBQ3BDLE9BQU9xQjtJQUNYO0lBQ0FGLFVBQVU7UUFDTixJQUFJLENBQUN2QixTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDZ0IsS0FBSyxDQUFDTyxPQUFPO1FBQ2xCLElBQUksQ0FBQ25CLEtBQUssQ0FBQ21CLE9BQU87SUFDdEI7QUFDSjtBQUNBbkMsWUFBWSxHQUFHRztBQUNmOzs7OztDQUtDLEdBQ0QsTUFBTUQsT0FBTyxDQUFDTyxNQUFNSyxLQUFLeUIsVUFBWSxJQUFJcEMsS0FBS00sTUFBTUssS0FBS0ksTUFBTSxDQUFDcUIsU0FBU2IsTUFBTTtBQUMvRTFCLFlBQVksR0FBR0U7QUFDZkYsbUJBQW1CLEdBQUcsQ0FBQ1MsTUFBTUssTUFBUSxJQUFJWCxLQUFLTSxNQUFNSyxNQUNwRCxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2htYWMuanM/OTRkNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaG1hYyA9IGV4cG9ydHMuSE1BQyA9IHZvaWQgMDtcbmNvbnN0IF9hc3NlcnRfanNfMSA9IHJlcXVpcmUoXCIuL19hc3NlcnQuanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vLyBITUFDIChSRkMgMjEwNClcbmNsYXNzIEhNQUMgZXh0ZW5kcyB1dGlsc19qc18xLkhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGhhc2gsIF9rZXkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5oYXNoKGhhc2gpO1xuICAgICAgICBjb25zdCBrZXkgPSAoMCwgdXRpbHNfanNfMS50b0J5dGVzKShfa2V5KTtcbiAgICAgICAgdGhpcy5pSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5pSGFzaC51cGRhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaCcpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gdGhpcy5pSGFzaC5ibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSB0aGlzLmlIYXNoLm91dHB1dExlbjtcbiAgICAgICAgY29uc3QgYmxvY2tMZW4gPSB0aGlzLmJsb2NrTGVuO1xuICAgICAgICBjb25zdCBwYWQgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIC8vIGJsb2NrTGVuIGNhbiBiZSBiaWdnZXIgdGhhbiBvdXRwdXRMZW5cbiAgICAgICAgcGFkLnNldChrZXkubGVuZ3RoID4gYmxvY2tMZW4gPyBoYXNoLmNyZWF0ZSgpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpIDoga2V5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNjtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgLy8gQnkgZG9pbmcgdXBkYXRlIChwcm9jZXNzaW5nIG9mIGZpcnN0IGJsb2NrKSBvZiBvdXRlciBoYXNoIGhlcmUgd2UgY2FuIHJlLXVzZSBpdCBiZXR3ZWVuIG11bHRpcGxlIGNhbGxzIHZpYSBjbG9uZVxuICAgICAgICB0aGlzLm9IYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgLy8gVW5kbyBpbnRlcm5hbCBYT1IgJiYgYXBwbHkgb3V0ZXIgWE9SXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzYgXiAweDVjO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICBwYWQuZmlsbCgwKTtcbiAgICB9XG4gICAgdXBkYXRlKGJ1Zikge1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5leGlzdHModGhpcyk7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKGJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5leGlzdHModGhpcyk7XG4gICAgICAgIF9hc3NlcnRfanNfMS5kZWZhdWx0LmJ5dGVzKG91dCwgdGhpcy5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSh0aGlzLm9IYXNoLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXcgaW5zdGFuY2Ugd2l0aG91dCBjYWxsaW5nIGNvbnN0cnVjdG9yIHNpbmNlIGtleSBhbHJlYWR5IGluIHN0YXRlIGFuZCB3ZSBkb24ndCBrbm93IGl0LlxuICAgICAgICB0byB8fCAodG8gPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwge30pKTtcbiAgICAgICAgY29uc3QgeyBvSGFzaCwgaUhhc2gsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIGJsb2NrTGVuLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRvID0gdG87XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgdG8uYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5vSGFzaCA9IG9IYXNoLl9jbG9uZUludG8odG8ub0hhc2gpO1xuICAgICAgICB0by5pSGFzaCA9IGlIYXNoLl9jbG9uZUludG8odG8uaUhhc2gpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vSGFzaC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaUhhc2guZGVzdHJveSgpO1xuICAgIH1cbn1cbmV4cG9ydHMuSE1BQyA9IEhNQUM7XG4vKipcbiAqIEhNQUM6IFJGQzIxMDQgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLlxuICogQHBhcmFtIGhhc2ggLSBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgZS5nLiBzaGEyNTZcbiAqIEBwYXJhbSBrZXkgLSBtZXNzYWdlIGtleVxuICogQHBhcmFtIG1lc3NhZ2UgLSBtZXNzYWdlIGRhdGFcbiAqL1xuY29uc3QgaG1hYyA9IChoYXNoLCBrZXksIG1lc3NhZ2UpID0+IG5ldyBITUFDKGhhc2gsIGtleSkudXBkYXRlKG1lc3NhZ2UpLmRpZ2VzdCgpO1xuZXhwb3J0cy5obWFjID0gaG1hYztcbmV4cG9ydHMuaG1hYy5jcmVhdGUgPSAoaGFzaCwga2V5KSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG1hYy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJobWFjIiwiSE1BQyIsIl9hc3NlcnRfanNfMSIsInJlcXVpcmUiLCJ1dGlsc19qc18xIiwiSGFzaCIsImNvbnN0cnVjdG9yIiwiaGFzaCIsIl9rZXkiLCJmaW5pc2hlZCIsImRlc3Ryb3llZCIsImRlZmF1bHQiLCJrZXkiLCJ0b0J5dGVzIiwiaUhhc2giLCJjcmVhdGUiLCJ1cGRhdGUiLCJFcnJvciIsImJsb2NrTGVuIiwib3V0cHV0TGVuIiwicGFkIiwiVWludDhBcnJheSIsInNldCIsImxlbmd0aCIsImRpZ2VzdCIsImkiLCJvSGFzaCIsImZpbGwiLCJidWYiLCJleGlzdHMiLCJkaWdlc3RJbnRvIiwib3V0IiwiYnl0ZXMiLCJkZXN0cm95IiwiX2Nsb25lSW50byIsInRvIiwiZ2V0UHJvdG90eXBlT2YiLCJtZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/hmac.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/sha256.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ethereum-cryptography/node_modules/@noble/hashes/sha256.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.sha224 = exports.sha256 = void 0;\nconst _sha2_js_1 = __webpack_require__(/*! ./_sha2.js */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/_sha2.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/utils.js\");\n// Choice: a ? b : c\nconst Chi = (a, b, c)=>a & b ^ ~a & c;\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c)=>a & b ^ a & c ^ b & c;\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = new Uint32Array([\n    0x428a2f98,\n    0x71374491,\n    0xb5c0fbcf,\n    0xe9b5dba5,\n    0x3956c25b,\n    0x59f111f1,\n    0x923f82a4,\n    0xab1c5ed5,\n    0xd807aa98,\n    0x12835b01,\n    0x243185be,\n    0x550c7dc3,\n    0x72be5d74,\n    0x80deb1fe,\n    0x9bdc06a7,\n    0xc19bf174,\n    0xe49b69c1,\n    0xefbe4786,\n    0x0fc19dc6,\n    0x240ca1cc,\n    0x2de92c6f,\n    0x4a7484aa,\n    0x5cb0a9dc,\n    0x76f988da,\n    0x983e5152,\n    0xa831c66d,\n    0xb00327c8,\n    0xbf597fc7,\n    0xc6e00bf3,\n    0xd5a79147,\n    0x06ca6351,\n    0x14292967,\n    0x27b70a85,\n    0x2e1b2138,\n    0x4d2c6dfc,\n    0x53380d13,\n    0x650a7354,\n    0x766a0abb,\n    0x81c2c92e,\n    0x92722c85,\n    0xa2bfe8a1,\n    0xa81a664b,\n    0xc24b8b70,\n    0xc76c51a3,\n    0xd192e819,\n    0xd6990624,\n    0xf40e3585,\n    0x106aa070,\n    0x19a4c116,\n    0x1e376c08,\n    0x2748774c,\n    0x34b0bcb5,\n    0x391c0cb3,\n    0x4ed8aa4a,\n    0x5b9cca4f,\n    0x682e6ff3,\n    0x748f82ee,\n    0x78a5636f,\n    0x84c87814,\n    0x8cc70208,\n    0x90befffa,\n    0xa4506ceb,\n    0xbef9a3f7,\n    0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = new Uint32Array([\n    0x6a09e667,\n    0xbb67ae85,\n    0x3c6ef372,\n    0xa54ff53a,\n    0x510e527f,\n    0x9b05688c,\n    0x1f83d9ab,\n    0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = new Uint32Array(64);\nclass SHA256 extends _sha2_js_1.SHA2 {\n    constructor(){\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [\n            A,\n            B,\n            C,\n            D,\n            E,\n            F,\n            G,\n            H\n        ];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for(let i = 0; i < 16; i++, offset += 4)SHA256_W[i] = view.getUint32(offset, false);\n        for(let i = 16; i < 64; i++){\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;\n            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;\n            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for(let i = 0; i < 64; i++){\n            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);\n            const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;\n            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);\n            const T2 = sigma0 + Maj(A, B, C) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = D + T1 | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = T1 + T2 | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = A + this.A | 0;\n        B = B + this.B | 0;\n        C = C + this.C | 0;\n        D = D + this.D | 0;\n        E = E + this.E | 0;\n        F = F + this.F | 0;\n        G = G + this.G | 0;\n        H = H + this.H | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor(){\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */ exports.sha256 = (0, utils_js_1.wrapConstructor)(()=>new SHA256());\nexports.sha224 = (0, utils_js_1.wrapConstructor)(()=>new SHA224()); //# sourceMappingURL=sha256.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3NoYTI1Ni5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsY0FBYyxHQUFHQSxjQUFjLEdBQUcsS0FBSztBQUN2QyxNQUFNSSxhQUFhQyxtQkFBT0EsQ0FBQyxrR0FBWTtBQUN2QyxNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQyxrR0FBWTtBQUN2QyxvQkFBb0I7QUFDcEIsTUFBTUUsTUFBTSxDQUFDQyxHQUFHQyxHQUFHQyxJQUFNLElBQUtELElBQU0sQ0FBQ0QsSUFBSUU7QUFDekMsb0RBQW9EO0FBQ3BELE1BQU1DLE1BQU0sQ0FBQ0gsR0FBR0MsR0FBR0MsSUFBTSxJQUFLRCxJQUFNRCxJQUFJRSxJQUFNRCxJQUFJQztBQUNsRCxtQkFBbUI7QUFDbkIseUZBQXlGO0FBQ3pGLGtCQUFrQjtBQUNsQixNQUFNRSxXQUFXLElBQUlDLFlBQVk7SUFDN0I7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0NBQ3ZGO0FBQ0QseUdBQXlHO0FBQ3pHLGtCQUFrQjtBQUNsQixNQUFNQyxLQUFLLElBQUlELFlBQVk7SUFDdkI7SUFBWTtJQUFZO0lBQVk7SUFB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QUMsR0FBSTtRQUNuQkMsSUFBSSxJQUFLLElBQUksQ0FBQ0EsQ0FBQyxHQUFJO1FBQ25CLElBQUksQ0FBQ0UsR0FBRyxDQUFDVCxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQyxHQUFHQztJQUNsQztJQUNBaUIsYUFBYTtRQUNUNUIsU0FBUzZCLElBQUksQ0FBQztJQUNsQjtJQUNBQyxVQUFVO1FBQ04sSUFBSSxDQUFDakIsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7UUFDOUIsSUFBSSxDQUFDa0IsTUFBTSxDQUFDRixJQUFJLENBQUM7SUFDckI7QUFDSjtBQUNBLDRFQUE0RTtBQUM1RSxNQUFNRyxlQUFlL0I7SUFDakJFLGFBQWM7UUFDVixLQUFLO1FBQ0wsSUFBSSxDQUFDQyxDQUFDLEdBQUcsYUFBYTtRQUN0QixJQUFJLENBQUNDLENBQUMsR0FBRyxhQUFhO1FBQ3RCLElBQUksQ0FBQ0MsQ0FBQyxHQUFHLGFBQWE7UUFDdEIsSUFBSSxDQUFDQyxDQUFDLEdBQUcsYUFBYTtRQUN0QixJQUFJLENBQUNDLENBQUMsR0FBRyxhQUFhO1FBQ3RCLElBQUksQ0FBQ0MsQ0FBQyxHQUFHLGFBQWE7UUFDdEIsSUFBSSxDQUFDQyxDQUFDLEdBQUcsYUFBYTtRQUN0QixJQUFJLENBQUNDLENBQUMsR0FBRyxhQUFhO1FBQ3RCLElBQUksQ0FBQ3NCLFNBQVMsR0FBRztJQUNyQjtBQUNKO0FBQ0E7OztDQUdDLEdBQ0RoRCxjQUFjLEdBQUcsQ0FBQyxHQUFHTSxXQUFXMkMsZUFBZSxFQUFFLElBQU0sSUFBSWpDO0FBQzNEaEIsY0FBYyxHQUFHLENBQUMsR0FBR00sV0FBVzJDLGVBQWUsRUFBRSxJQUFNLElBQUlGLFdBQzNELGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bS1jcnlwdG9ncmFwaHkvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc2hhMjU2LmpzP2QwZDUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNoYTIyNCA9IGV4cG9ydHMuc2hhMjU2ID0gdm9pZCAwO1xuY29uc3QgX3NoYTJfanNfMSA9IHJlcXVpcmUoXCIuL19zaGEyLmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gQ2hvaWNlOiBhID8gYiA6IGNcbmNvbnN0IENoaSA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKH5hICYgYyk7XG4vLyBNYWpvcml0eSBmdW5jdGlvbiwgdHJ1ZSBpZiBhbnkgdHdvIGlucHVzdCBpcyB0cnVlXG5jb25zdCBNYWogPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeIChhICYgYykgXiAoYiAmIGMpO1xuLy8gUm91bmQgY29uc3RhbnRzOlxuLy8gZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgNjQgcHJpbWVzIDIuLjMxMSlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0sgPSBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NDI4YTJmOTgsIDB4NzEzNzQ0OTEsIDB4YjVjMGZiY2YsIDB4ZTliNWRiYTUsIDB4Mzk1NmMyNWIsIDB4NTlmMTExZjEsIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsXG4gICAgMHhkODA3YWE5OCwgMHgxMjgzNWIwMSwgMHgyNDMxODViZSwgMHg1NTBjN2RjMywgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNywgMHhjMTliZjE3NCxcbiAgICAweGU0OWI2OWMxLCAweGVmYmU0Nzg2LCAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLCAweDJkZTkyYzZmLCAweDRhNzQ4NGFhLCAweDVjYjBhOWRjLCAweDc2Zjk4OGRhLFxuICAgIDB4OTgzZTUxNTIsIDB4YTgzMWM2NmQsIDB4YjAwMzI3YzgsIDB4YmY1OTdmYzcsIDB4YzZlMDBiZjMsIDB4ZDVhNzkxNDcsIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsXG4gICAgMHgyN2I3MGE4NSwgMHgyZTFiMjEzOCwgMHg0ZDJjNmRmYywgMHg1MzM4MGQxMywgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcbiAgICAweGEyYmZlOGExLCAweGE4MWE2NjRiLCAweGMyNGI4YjcwLCAweGM3NmM1MWEzLCAweGQxOTJlODE5LCAweGQ2OTkwNjI0LCAweGY0MGUzNTg1LCAweDEwNmFhMDcwLFxuICAgIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsIDB4NWI5Y2NhNGYsIDB4NjgyZTZmZjMsXG4gICAgMHg3NDhmODJlZSwgMHg3OGE1NjM2ZiwgMHg4NGM4NzgxNCwgMHg4Y2M3MDIwOCwgMHg5MGJlZmZmYSwgMHhhNDUwNmNlYiwgMHhiZWY5YTNmNywgMHhjNjcxNzhmMlxuXSk7XG4vLyBJbml0aWFsIHN0YXRlIChmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBzcXVhcmUgcm9vdHMgb2YgdGhlIGZpcnN0IDggcHJpbWVzIDIuLjE5KTpcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgSVYgPSBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTlcbl0pO1xuLy8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXG4vLyBOYW1lZCB0aGlzIHdheSBiZWNhdXNlIGl0IG1hdGNoZXMgc3BlY2lmaWNhdGlvbi5cbmNvbnN0IFNIQTI1Nl9XID0gbmV3IFVpbnQzMkFycmF5KDY0KTtcbmNsYXNzIFNIQTI1NiBleHRlbmRzIF9zaGEyX2pzXzEuU0hBMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAzMiwgOCwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgdGhpcy5BID0gSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkIgPSBJVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQyA9IElWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkUgPSBJVls0XSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IElWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkggPSBJVls3XSB8IDA7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0EsIEIsIEMsIEQsIEUsIEYsIEcsIEhdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCkge1xuICAgICAgICB0aGlzLkEgPSBBIHwgMDtcbiAgICAgICAgdGhpcy5CID0gQiB8IDA7XG4gICAgICAgIHRoaXMuQyA9IEMgfCAwO1xuICAgICAgICB0aGlzLkQgPSBEIHwgMDtcbiAgICAgICAgdGhpcy5FID0gRSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IEYgfCAwO1xuICAgICAgICB0aGlzLkcgPSBHIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDQ4IHdvcmRzIHdbMTYuLjYzXSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KVxuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgVzE1ID0gU0hBMjU2X1dbaSAtIDE1XTtcbiAgICAgICAgICAgIGNvbnN0IFcyID0gU0hBMjU2X1dbaSAtIDJdO1xuICAgICAgICAgICAgY29uc3QgczAgPSAoMCwgdXRpbHNfanNfMS5yb3RyKShXMTUsIDcpIF4gKDAsIHV0aWxzX2pzXzEucm90cikoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gKDAsIHV0aWxzX2pzXzEucm90cikoVzIsIDE3KSBeICgwLCB1dGlsc19qc18xLnJvdHIpKFcyLCAxOSkgXiAoVzIgPj4+IDEwKTtcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gKHMxICsgU0hBMjU2X1dbaSAtIDddICsgczAgKyBTSEEyNTZfV1tpIC0gMTZdKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA2NCByb3VuZHNcbiAgICAgICAgbGV0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTEgPSAoMCwgdXRpbHNfanNfMS5yb3RyKShFLCA2KSBeICgwLCB1dGlsc19qc18xLnJvdHIpKEUsIDExKSBeICgwLCB1dGlsc19qc18xLnJvdHIpKEUsIDI1KTtcbiAgICAgICAgICAgIGNvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTAgPSAoMCwgdXRpbHNfanNfMS5yb3RyKShBLCAyKSBeICgwLCB1dGlsc19qc18xLnJvdHIpKEEsIDEzKSBeICgwLCB1dGlsc19qc18xLnJvdHIpKEEsIDIyKTtcbiAgICAgICAgICAgIGNvbnN0IFQyID0gKHNpZ21hMCArIE1haihBLCBCLCBDKSkgfCAwO1xuICAgICAgICAgICAgSCA9IEc7XG4gICAgICAgICAgICBHID0gRjtcbiAgICAgICAgICAgIEYgPSBFO1xuICAgICAgICAgICAgRSA9IChEICsgVDEpIHwgMDtcbiAgICAgICAgICAgIEQgPSBDO1xuICAgICAgICAgICAgQyA9IEI7XG4gICAgICAgICAgICBCID0gQTtcbiAgICAgICAgICAgIEEgPSAoVDEgKyBUMikgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgIEEgPSAoQSArIHRoaXMuQSkgfCAwO1xuICAgICAgICBCID0gKEIgKyB0aGlzLkIpIHwgMDtcbiAgICAgICAgQyA9IChDICsgdGhpcy5DKSB8IDA7XG4gICAgICAgIEQgPSAoRCArIHRoaXMuRCkgfCAwO1xuICAgICAgICBFID0gKEUgKyB0aGlzLkUpIHwgMDtcbiAgICAgICAgRiA9IChGICsgdGhpcy5GKSB8IDA7XG4gICAgICAgIEcgPSAoRyArIHRoaXMuRykgfCAwO1xuICAgICAgICBIID0gKEggKyB0aGlzLkgpIHwgMDtcbiAgICAgICAgdGhpcy5zZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIFNIQTI1Nl9XLmZpbGwoMCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICAgIH1cbn1cbi8vIENvbnN0YW50cyBmcm9tIGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4xODAtNC5wZGZcbmNsYXNzIFNIQTIyNCBleHRlbmRzIFNIQTI1NiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuQSA9IDB4YzEwNTllZDggfCAwO1xuICAgICAgICB0aGlzLkIgPSAweDM2N2NkNTA3IHwgMDtcbiAgICAgICAgdGhpcy5DID0gMHgzMDcwZGQxNyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IDB4ZjcwZTU5MzkgfCAwO1xuICAgICAgICB0aGlzLkUgPSAweGZmYzAwYjMxIHwgMDtcbiAgICAgICAgdGhpcy5GID0gMHg2ODU4MTUxMSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IDB4NjRmOThmYTcgfCAwO1xuICAgICAgICB0aGlzLkggPSAweGJlZmE0ZmE0IHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSAyODtcbiAgICB9XG59XG4vKipcbiAqIFNIQTItMjU2IGhhc2ggZnVuY3Rpb25cbiAqIEBwYXJhbSBtZXNzYWdlIC0gZGF0YSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnRzLnNoYTI1NiA9ICgwLCB1dGlsc19qc18xLndyYXBDb25zdHJ1Y3RvcikoKCkgPT4gbmV3IFNIQTI1NigpKTtcbmV4cG9ydHMuc2hhMjI0ID0gKDAsIHV0aWxzX2pzXzEud3JhcENvbnN0cnVjdG9yKSgoKSA9PiBuZXcgU0hBMjI0KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMjU2LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInNoYTIyNCIsInNoYTI1NiIsIl9zaGEyX2pzXzEiLCJyZXF1aXJlIiwidXRpbHNfanNfMSIsIkNoaSIsImEiLCJiIiwiYyIsIk1haiIsIlNIQTI1Nl9LIiwiVWludDMyQXJyYXkiLCJJViIsIlNIQTI1Nl9XIiwiU0hBMjU2IiwiU0hBMiIsImNvbnN0cnVjdG9yIiwiQSIsIkIiLCJDIiwiRCIsIkUiLCJGIiwiRyIsIkgiLCJnZXQiLCJzZXQiLCJwcm9jZXNzIiwidmlldyIsIm9mZnNldCIsImkiLCJnZXRVaW50MzIiLCJXMTUiLCJXMiIsInMwIiwicm90ciIsInMxIiwic2lnbWExIiwiVDEiLCJzaWdtYTAiLCJUMiIsInJvdW5kQ2xlYW4iLCJmaWxsIiwiZGVzdHJveSIsImJ1ZmZlciIsIlNIQTIyNCIsIm91dHB1dExlbiIsIndyYXBDb25zdHJ1Y3RvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/sha256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/sha3.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/ethereum-cryptography/node_modules/@noble/hashes/sha3.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/_assert.js\");\nconst _u64_js_1 = __webpack_require__(/*! ./_u64.js */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/_u64.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/utils.js\");\n// Various per round constants calculations\nconst [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [\n    [],\n    [],\n    []\n];\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _7n = BigInt(7);\nconst _256n = BigInt(256);\nconst _0x71n = BigInt(0x71);\nfor(let round = 0, R = _1n, x = 1, y = 0; round < 24; round++){\n    // Pi\n    [x, y] = [\n        y,\n        (2 * x + 3 * y) % 5\n    ];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);\n    // Iota\n    let t = _0n;\n    for(let j = 0; j < 7; j++){\n        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;\n        if (R & _2n) t ^= _1n << (_1n << BigInt(j)) - _1n;\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = _u64_js_1.default.split(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s)=>s > 32 ? _u64_js_1.default.rotlBH(h, l, s) : _u64_js_1.default.rotlSH(h, l, s);\nconst rotlL = (h, l, s)=>s > 32 ? _u64_js_1.default.rotlBL(h, l, s) : _u64_js_1.default.rotlSL(h, l, s);\n// Same as keccakf1600, but allows to skip some rounds\nfunction keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for(let round = 24 - rounds; round < 24; round++){\n        // Theta Œ∏\n        for(let x = 0; x < 10; x++)B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for(let x = 0; x < 10; x += 2){\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for(let y = 0; y < 50; y += 10){\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho (œÅ) and Pi (œÄ)\n        let curH = s[2];\n        let curL = s[3];\n        for(let t = 0; t < 24; t++){\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi (œá)\n        for(let y = 0; y < 50; y += 10){\n            for(let x = 0; x < 10; x++)B[x] = s[y + x];\n            for(let x = 0; x < 10; x++)s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota (Œπ)\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nexports.keccakP = keccakP;\nclass Keccak extends utils_js_1.Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24){\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        _assert_js_1.default.number(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200) throw new Error(\"Sha3 supports only keccak-f1600 function\");\n        this.state = new Uint8Array(200);\n        this.state32 = (0, utils_js_1.u32)(this.state);\n    }\n    keccak() {\n        keccakP(this.state32, this.rounds);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        _assert_js_1.default.exists(this);\n        const { blockLen, state } = this;\n        data = (0, utils_js_1.toBytes)(data);\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for(let i = 0; i < take; i++)state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen) this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished) return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        _assert_js_1.default.exists(this, false);\n        _assert_js_1.default.bytes(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for(let pos = 0, len = out.length; pos < len;){\n            if (this.posOut >= blockLen) this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF) throw new Error(\"XOF is not possible for this instance\");\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        _assert_js_1.default.number(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        _assert_js_1.default.output(out, this);\n        if (this.finished) throw new Error(\"digest() was already called\");\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nexports.Keccak = Keccak;\nconst gen = (suffix, blockLen, outputLen)=>(0, utils_js_1.wrapConstructor)(()=>new Keccak(blockLen, suffix, outputLen));\nexports.sha3_224 = gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */ exports.sha3_256 = gen(0x06, 136, 256 / 8);\nexports.sha3_384 = gen(0x06, 104, 384 / 8);\nexports.sha3_512 = gen(0x06, 72, 512 / 8);\nexports.keccak_224 = gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */ exports.keccak_256 = gen(0x01, 136, 256 / 8);\nexports.keccak_384 = gen(0x01, 104, 384 / 8);\nexports.keccak_512 = gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen)=>(0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {})=>new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\nexports.shake128 = genShake(0x1f, 168, 128 / 8);\nexports.shake256 = genShake(0x1f, 136, 256 / 8); //# sourceMappingURL=sha3.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3NoYTMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGdCQUFnQixHQUFHQSxnQkFBZ0IsR0FBR0Esa0JBQWtCLEdBQUdBLGtCQUFrQixHQUFHQSxrQkFBa0IsR0FBR0Esa0JBQWtCLEdBQUdBLGdCQUFnQixHQUFHQSxnQkFBZ0IsR0FBR0EsZ0JBQWdCLEdBQUdBLGdCQUFnQixHQUFHQSxjQUFjLEdBQUdBLGVBQWUsR0FBRyxLQUFLO0FBQzlPLE1BQU1jLGVBQWVDLG1CQUFPQSxDQUFDLHNHQUFjO0FBQzNDLE1BQU1DLFlBQVlELG1CQUFPQSxDQUFDLGdHQUFXO0FBQ3JDLE1BQU1FLGFBQWFGLG1CQUFPQSxDQUFDLGtHQUFZO0FBQ3ZDLDJDQUEyQztBQUMzQyxNQUFNLENBQUNHLFNBQVNDLFdBQVdDLFdBQVcsR0FBRztJQUFDLEVBQUU7SUFBRSxFQUFFO0lBQUUsRUFBRTtDQUFDO0FBQ3JELE1BQU1DLE1BQU1DLE9BQU87QUFDbkIsTUFBTUMsTUFBTUQsT0FBTztBQUNuQixNQUFNRSxNQUFNRixPQUFPO0FBQ25CLE1BQU1HLE1BQU1ILE9BQU87QUFDbkIsTUFBTUksUUFBUUosT0FBTztBQUNyQixNQUFNSyxTQUFTTCxPQUFPO0FBQ3RCLElBQUssSUFBSU0sUUFBUSxHQUFHQyxJQUFJTixLQUFLTyxJQUFJLEdBQUdDLElBQUksR0FBR0gsUUFBUSxJQUFJQSxRQUFTO0lBQzVELEtBQUs7SUFDTCxDQUFDRSxHQUFHQyxFQUFFLEdBQUc7UUFBQ0E7UUFBSSxLQUFJRCxJQUFJLElBQUlDLENBQUFBLElBQUs7S0FBRTtJQUNqQ2IsUUFBUWMsSUFBSSxDQUFDLElBQUssS0FBSUQsSUFBSUQsQ0FBQUE7SUFDMUIsYUFBYTtJQUNiWCxVQUFVYSxJQUFJLENBQUMsQ0FBR0osUUFBUSxLQUFNQSxDQUFBQSxRQUFRLEtBQU0sSUFBSztJQUNuRCxPQUFPO0lBQ1AsSUFBSUssSUFBSVo7SUFDUixJQUFLLElBQUlhLElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFLO1FBQ3hCTCxJQUFJLENBQUMsS0FBTU4sTUFBUSxDQUFDTSxLQUFLSixHQUFFLElBQUtFLE1BQU0sSUFBS0Q7UUFDM0MsSUFBSUcsSUFBSUwsS0FDSlMsS0FBS1YsT0FBUSxDQUFDQSxPQUFPRCxPQUFPWSxFQUFDLElBQUtYO0lBQzFDO0lBQ0FILFdBQVdZLElBQUksQ0FBQ0M7QUFDcEI7QUFDQSxNQUFNLENBQUNFLGFBQWFDLFlBQVksR0FBR3BCLFVBQVVxQixPQUFPLENBQUNDLEtBQUssQ0FBQ2xCLFlBQVk7QUFDdkUsb0NBQW9DO0FBQ3BDLE1BQU1tQixRQUFRLENBQUNDLEdBQUdDLEdBQUdDLElBQU1BLElBQUksS0FBSzFCLFVBQVVxQixPQUFPLENBQUNNLE1BQU0sQ0FBQ0gsR0FBR0MsR0FBR0MsS0FBSzFCLFVBQVVxQixPQUFPLENBQUNPLE1BQU0sQ0FBQ0osR0FBR0MsR0FBR0M7QUFDdkcsTUFBTUcsUUFBUSxDQUFDTCxHQUFHQyxHQUFHQyxJQUFNQSxJQUFJLEtBQUsxQixVQUFVcUIsT0FBTyxDQUFDUyxNQUFNLENBQUNOLEdBQUdDLEdBQUdDLEtBQUsxQixVQUFVcUIsT0FBTyxDQUFDVSxNQUFNLENBQUNQLEdBQUdDLEdBQUdDO0FBQ3ZHLHNEQUFzRDtBQUN0RCxTQUFTN0IsUUFBUTZCLENBQUMsRUFBRU0sU0FBUyxFQUFFO0lBQzNCLE1BQU1DLElBQUksSUFBSUMsWUFBWSxJQUFJO0lBQzlCLDhGQUE4RjtJQUM5RixJQUFLLElBQUl0QixRQUFRLEtBQUtvQixRQUFRcEIsUUFBUSxJQUFJQSxRQUFTO1FBQy9DLFVBQVU7UUFDVixJQUFLLElBQUlFLElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUNwQm1CLENBQUMsQ0FBQ25CLEVBQUUsR0FBR1ksQ0FBQyxDQUFDWixFQUFFLEdBQUdZLENBQUMsQ0FBQ1osSUFBSSxHQUFHLEdBQUdZLENBQUMsQ0FBQ1osSUFBSSxHQUFHLEdBQUdZLENBQUMsQ0FBQ1osSUFBSSxHQUFHLEdBQUdZLENBQUMsQ0FBQ1osSUFBSSxHQUFHO1FBQy9ELElBQUssSUFBSUEsSUFBSSxHQUFHQSxJQUFJLElBQUlBLEtBQUssRUFBRztZQUM1QixNQUFNcUIsT0FBTyxDQUFDckIsSUFBSSxLQUFLO1lBQ3ZCLE1BQU1zQixPQUFPLENBQUN0QixJQUFJLEtBQUs7WUFDdkIsTUFBTXVCLEtBQUtKLENBQUMsQ0FBQ0csS0FBSztZQUNsQixNQUFNRSxLQUFLTCxDQUFDLENBQUNHLE9BQU8sRUFBRTtZQUN0QixNQUFNRyxLQUFLaEIsTUFBTWMsSUFBSUMsSUFBSSxLQUFLTCxDQUFDLENBQUNFLEtBQUs7WUFDckMsTUFBTUssS0FBS1gsTUFBTVEsSUFBSUMsSUFBSSxLQUFLTCxDQUFDLENBQUNFLE9BQU8sRUFBRTtZQUN6QyxJQUFLLElBQUlwQixJQUFJLEdBQUdBLElBQUksSUFBSUEsS0FBSyxHQUFJO2dCQUM3QlcsQ0FBQyxDQUFDWixJQUFJQyxFQUFFLElBQUl3QjtnQkFDWmIsQ0FBQyxDQUFDWixJQUFJQyxJQUFJLEVBQUUsSUFBSXlCO1lBQ3BCO1FBQ0o7UUFDQSxxQkFBcUI7UUFDckIsSUFBSUMsT0FBT2YsQ0FBQyxDQUFDLEVBQUU7UUFDZixJQUFJZ0IsT0FBT2hCLENBQUMsQ0FBQyxFQUFFO1FBQ2YsSUFBSyxJQUFJVCxJQUFJLEdBQUdBLElBQUksSUFBSUEsSUFBSztZQUN6QixNQUFNMEIsUUFBUXhDLFNBQVMsQ0FBQ2MsRUFBRTtZQUMxQixNQUFNc0IsS0FBS2hCLE1BQU1rQixNQUFNQyxNQUFNQztZQUM3QixNQUFNSCxLQUFLWCxNQUFNWSxNQUFNQyxNQUFNQztZQUM3QixNQUFNQyxLQUFLMUMsT0FBTyxDQUFDZSxFQUFFO1lBQ3JCd0IsT0FBT2YsQ0FBQyxDQUFDa0IsR0FBRztZQUNaRixPQUFPaEIsQ0FBQyxDQUFDa0IsS0FBSyxFQUFFO1lBQ2hCbEIsQ0FBQyxDQUFDa0IsR0FBRyxHQUFHTDtZQUNSYixDQUFDLENBQUNrQixLQUFLLEVBQUUsR0FBR0o7UUFDaEI7UUFDQSxVQUFVO1FBQ1YsSUFBSyxJQUFJekIsSUFBSSxHQUFHQSxJQUFJLElBQUlBLEtBQUssR0FBSTtZQUM3QixJQUFLLElBQUlELElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUNwQm1CLENBQUMsQ0FBQ25CLEVBQUUsR0FBR1ksQ0FBQyxDQUFDWCxJQUFJRCxFQUFFO1lBQ25CLElBQUssSUFBSUEsSUFBSSxHQUFHQSxJQUFJLElBQUlBLElBQ3BCWSxDQUFDLENBQUNYLElBQUlELEVBQUUsSUFBSSxDQUFDbUIsQ0FBQyxDQUFDLENBQUNuQixJQUFJLEtBQUssR0FBRyxHQUFHbUIsQ0FBQyxDQUFDLENBQUNuQixJQUFJLEtBQUssR0FBRztRQUN0RDtRQUNBLFdBQVc7UUFDWFksQ0FBQyxDQUFDLEVBQUUsSUFBSVAsV0FBVyxDQUFDUCxNQUFNO1FBQzFCYyxDQUFDLENBQUMsRUFBRSxJQUFJTixXQUFXLENBQUNSLE1BQU07SUFDOUI7SUFDQXFCLEVBQUVZLElBQUksQ0FBQztBQUNYO0FBQ0E3RCxlQUFlLEdBQUdhO0FBQ2xCLE1BQU1ELGVBQWVLLFdBQVc2QyxJQUFJO0lBQ2hDLDJEQUEyRDtJQUMzREMsWUFBWUMsUUFBUSxFQUFFQyxNQUFNLEVBQUVDLFNBQVMsRUFBRUMsWUFBWSxLQUFLLEVBQUVuQixTQUFTLEVBQUUsQ0FBRTtRQUNyRSxLQUFLO1FBQ0wsSUFBSSxDQUFDZ0IsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNDLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNDLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDQyxTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ25CLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNvQixHQUFHLEdBQUc7UUFDWCxJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsU0FBUyxHQUFHO1FBQ2pCLG1DQUFtQztRQUNuQ3pELGFBQWF1QixPQUFPLENBQUNtQyxNQUFNLENBQUNOO1FBQzVCLHVEQUF1RDtRQUN2RCxJQUFJLEtBQUssSUFBSSxDQUFDRixRQUFRLElBQUksSUFBSSxDQUFDQSxRQUFRLElBQUksS0FDdkMsTUFBTSxJQUFJUyxNQUFNO1FBQ3BCLElBQUksQ0FBQ0MsS0FBSyxHQUFHLElBQUlDLFdBQVc7UUFDNUIsSUFBSSxDQUFDQyxPQUFPLEdBQUcsQ0FBQyxHQUFHM0QsV0FBVzRELEdBQUcsRUFBRSxJQUFJLENBQUNILEtBQUs7SUFDakQ7SUFDQUksU0FBUztRQUNMakUsUUFBUSxJQUFJLENBQUMrRCxPQUFPLEVBQUUsSUFBSSxDQUFDNUIsTUFBTTtRQUNqQyxJQUFJLENBQUNxQixNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNELEdBQUcsR0FBRztJQUNmO0lBQ0FXLE9BQU9DLElBQUksRUFBRTtRQUNUbEUsYUFBYXVCLE9BQU8sQ0FBQzRDLE1BQU0sQ0FBQyxJQUFJO1FBQ2hDLE1BQU0sRUFBRWpCLFFBQVEsRUFBRVUsS0FBSyxFQUFFLEdBQUcsSUFBSTtRQUNoQ00sT0FBTyxDQUFDLEdBQUcvRCxXQUFXaUUsT0FBTyxFQUFFRjtRQUMvQixNQUFNRyxNQUFNSCxLQUFLSSxNQUFNO1FBQ3ZCLElBQUssSUFBSWhCLE1BQU0sR0FBR0EsTUFBTWUsS0FBTTtZQUMxQixNQUFNRSxPQUFPQyxLQUFLQyxHQUFHLENBQUN2QixXQUFXLElBQUksQ0FBQ0ksR0FBRyxFQUFFZSxNQUFNZjtZQUNqRCxJQUFLLElBQUlvQixJQUFJLEdBQUdBLElBQUlILE1BQU1HLElBQ3RCZCxLQUFLLENBQUMsSUFBSSxDQUFDTixHQUFHLEdBQUcsSUFBSVksSUFBSSxDQUFDWixNQUFNO1lBQ3BDLElBQUksSUFBSSxDQUFDQSxHQUFHLEtBQUtKLFVBQ2IsSUFBSSxDQUFDYyxNQUFNO1FBQ25CO1FBQ0EsT0FBTyxJQUFJO0lBQ2Y7SUFDQVcsU0FBUztRQUNMLElBQUksSUFBSSxDQUFDbkIsUUFBUSxFQUNiO1FBQ0osSUFBSSxDQUFDQSxRQUFRLEdBQUc7UUFDaEIsTUFBTSxFQUFFSSxLQUFLLEVBQUVULE1BQU0sRUFBRUcsR0FBRyxFQUFFSixRQUFRLEVBQUUsR0FBRyxJQUFJO1FBQzdDLGlCQUFpQjtRQUNqQlUsS0FBSyxDQUFDTixJQUFJLElBQUlIO1FBQ2QsSUFBSSxDQUFDQSxTQUFTLElBQUcsTUFBTyxLQUFLRyxRQUFRSixXQUFXLEdBQzVDLElBQUksQ0FBQ2MsTUFBTTtRQUNmSixLQUFLLENBQUNWLFdBQVcsRUFBRSxJQUFJO1FBQ3ZCLElBQUksQ0FBQ2MsTUFBTTtJQUNmO0lBQ0FZLFVBQVVDLEdBQUcsRUFBRTtRQUNYN0UsYUFBYXVCLE9BQU8sQ0FBQzRDLE1BQU0sQ0FBQyxJQUFJLEVBQUU7UUFDbENuRSxhQUFhdUIsT0FBTyxDQUFDdUQsS0FBSyxDQUFDRDtRQUMzQixJQUFJLENBQUNGLE1BQU07UUFDWCxNQUFNSSxZQUFZLElBQUksQ0FBQ25CLEtBQUs7UUFDNUIsTUFBTSxFQUFFVixRQUFRLEVBQUUsR0FBRyxJQUFJO1FBQ3pCLElBQUssSUFBSUksTUFBTSxHQUFHZSxNQUFNUSxJQUFJUCxNQUFNLEVBQUVoQixNQUFNZSxLQUFNO1lBQzVDLElBQUksSUFBSSxDQUFDZCxNQUFNLElBQUlMLFVBQ2YsSUFBSSxDQUFDYyxNQUFNO1lBQ2YsTUFBTU8sT0FBT0MsS0FBS0MsR0FBRyxDQUFDdkIsV0FBVyxJQUFJLENBQUNLLE1BQU0sRUFBRWMsTUFBTWY7WUFDcER1QixJQUFJRyxHQUFHLENBQUNELFVBQVVFLFFBQVEsQ0FBQyxJQUFJLENBQUMxQixNQUFNLEVBQUUsSUFBSSxDQUFDQSxNQUFNLEdBQUdnQixPQUFPakI7WUFDN0QsSUFBSSxDQUFDQyxNQUFNLElBQUlnQjtZQUNmakIsT0FBT2lCO1FBQ1g7UUFDQSxPQUFPTTtJQUNYO0lBQ0FLLFFBQVFMLEdBQUcsRUFBRTtRQUNULGtGQUFrRjtRQUNsRixJQUFJLENBQUMsSUFBSSxDQUFDeEIsU0FBUyxFQUNmLE1BQU0sSUFBSU0sTUFBTTtRQUNwQixPQUFPLElBQUksQ0FBQ2lCLFNBQVMsQ0FBQ0M7SUFDMUI7SUFDQU0sSUFBSUwsS0FBSyxFQUFFO1FBQ1A5RSxhQUFhdUIsT0FBTyxDQUFDbUMsTUFBTSxDQUFDb0I7UUFDNUIsT0FBTyxJQUFJLENBQUNJLE9BQU8sQ0FBQyxJQUFJckIsV0FBV2lCO0lBQ3ZDO0lBQ0FNLFdBQVdQLEdBQUcsRUFBRTtRQUNaN0UsYUFBYXVCLE9BQU8sQ0FBQzhELE1BQU0sQ0FBQ1IsS0FBSyxJQUFJO1FBQ3JDLElBQUksSUFBSSxDQUFDckIsUUFBUSxFQUNiLE1BQU0sSUFBSUcsTUFBTTtRQUNwQixJQUFJLENBQUNpQixTQUFTLENBQUNDO1FBQ2YsSUFBSSxDQUFDUyxPQUFPO1FBQ1osT0FBT1Q7SUFDWDtJQUNBVSxTQUFTO1FBQ0wsT0FBTyxJQUFJLENBQUNILFVBQVUsQ0FBQyxJQUFJdkIsV0FBVyxJQUFJLENBQUNULFNBQVM7SUFDeEQ7SUFDQWtDLFVBQVU7UUFDTixJQUFJLENBQUM3QixTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDRyxLQUFLLENBQUNiLElBQUksQ0FBQztJQUNwQjtJQUNBeUMsV0FBV0MsRUFBRSxFQUFFO1FBQ1gsTUFBTSxFQUFFdkMsUUFBUSxFQUFFQyxNQUFNLEVBQUVDLFNBQVMsRUFBRWxCLE1BQU0sRUFBRW1CLFNBQVMsRUFBRSxHQUFHLElBQUk7UUFDL0RvQyxNQUFPQSxDQUFBQSxLQUFLLElBQUkzRixPQUFPb0QsVUFBVUMsUUFBUUMsV0FBV0MsV0FBV25CLE9BQU07UUFDckV1RCxHQUFHM0IsT0FBTyxDQUFDa0IsR0FBRyxDQUFDLElBQUksQ0FBQ2xCLE9BQU87UUFDM0IyQixHQUFHbkMsR0FBRyxHQUFHLElBQUksQ0FBQ0EsR0FBRztRQUNqQm1DLEdBQUdsQyxNQUFNLEdBQUcsSUFBSSxDQUFDQSxNQUFNO1FBQ3ZCa0MsR0FBR2pDLFFBQVEsR0FBRyxJQUFJLENBQUNBLFFBQVE7UUFDM0JpQyxHQUFHdkQsTUFBTSxHQUFHQTtRQUNaLDhCQUE4QjtRQUM5QnVELEdBQUd0QyxNQUFNLEdBQUdBO1FBQ1pzQyxHQUFHckMsU0FBUyxHQUFHQTtRQUNmcUMsR0FBR3BDLFNBQVMsR0FBR0E7UUFDZm9DLEdBQUdoQyxTQUFTLEdBQUcsSUFBSSxDQUFDQSxTQUFTO1FBQzdCLE9BQU9nQztJQUNYO0FBQ0o7QUFDQXZHLGNBQWMsR0FBR1k7QUFDakIsTUFBTTRGLE1BQU0sQ0FBQ3ZDLFFBQVFELFVBQVVFLFlBQWMsQ0FBQyxHQUFHakQsV0FBV3dGLGVBQWUsRUFBRSxJQUFNLElBQUk3RixPQUFPb0QsVUFBVUMsUUFBUUM7QUFDaEhsRSxnQkFBZ0IsR0FBR3dHLElBQUksTUFBTSxLQUFLLE1BQU07QUFDeEM7OztDQUdDLEdBQ0R4RyxnQkFBZ0IsR0FBR3dHLElBQUksTUFBTSxLQUFLLE1BQU07QUFDeEN4RyxnQkFBZ0IsR0FBR3dHLElBQUksTUFBTSxLQUFLLE1BQU07QUFDeEN4RyxnQkFBZ0IsR0FBR3dHLElBQUksTUFBTSxJQUFJLE1BQU07QUFDdkN4RyxrQkFBa0IsR0FBR3dHLElBQUksTUFBTSxLQUFLLE1BQU07QUFDMUM7OztDQUdDLEdBQ0R4RyxrQkFBa0IsR0FBR3dHLElBQUksTUFBTSxLQUFLLE1BQU07QUFDMUN4RyxrQkFBa0IsR0FBR3dHLElBQUksTUFBTSxLQUFLLE1BQU07QUFDMUN4RyxrQkFBa0IsR0FBR3dHLElBQUksTUFBTSxJQUFJLE1BQU07QUFDekMsTUFBTUUsV0FBVyxDQUFDekMsUUFBUUQsVUFBVUUsWUFBYyxDQUFDLEdBQUdqRCxXQUFXMEYsMEJBQTBCLEVBQUUsQ0FBQ0MsT0FBTyxDQUFDLENBQUMsR0FBSyxJQUFJaEcsT0FBT29ELFVBQVVDLFFBQVEyQyxLQUFLQyxLQUFLLEtBQUtDLFlBQVk1QyxZQUFZMEMsS0FBS0MsS0FBSyxFQUFFO0FBQzVMN0csZ0JBQWdCLEdBQUcwRyxTQUFTLE1BQU0sS0FBSyxNQUFNO0FBQzdDMUcsZ0JBQWdCLEdBQUcwRyxTQUFTLE1BQU0sS0FBSyxNQUFNLElBQzdDLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bS1jcnlwdG9ncmFwaHkvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc2hhMy5qcz9lZTczIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaGFrZTI1NiA9IGV4cG9ydHMuc2hha2UxMjggPSBleHBvcnRzLmtlY2Nha181MTIgPSBleHBvcnRzLmtlY2Nha18zODQgPSBleHBvcnRzLmtlY2Nha18yNTYgPSBleHBvcnRzLmtlY2Nha18yMjQgPSBleHBvcnRzLnNoYTNfNTEyID0gZXhwb3J0cy5zaGEzXzM4NCA9IGV4cG9ydHMuc2hhM18yNTYgPSBleHBvcnRzLnNoYTNfMjI0ID0gZXhwb3J0cy5LZWNjYWsgPSBleHBvcnRzLmtlY2Nha1AgPSB2b2lkIDA7XG5jb25zdCBfYXNzZXJ0X2pzXzEgPSByZXF1aXJlKFwiLi9fYXNzZXJ0LmpzXCIpO1xuY29uc3QgX3U2NF9qc18xID0gcmVxdWlyZShcIi4vX3U2NC5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8vIFZhcmlvdXMgcGVyIHJvdW5kIGNvbnN0YW50cyBjYWxjdWxhdGlvbnNcbmNvbnN0IFtTSEEzX1BJLCBTSEEzX1JPVEwsIF9TSEEzX0lPVEFdID0gW1tdLCBbXSwgW11dO1xuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gQmlnSW50KDIpO1xuY29uc3QgXzduID0gQmlnSW50KDcpO1xuY29uc3QgXzI1Nm4gPSBCaWdJbnQoMjU2KTtcbmNvbnN0IF8weDcxbiA9IEJpZ0ludCgweDcxKTtcbmZvciAobGV0IHJvdW5kID0gMCwgUiA9IF8xbiwgeCA9IDEsIHkgPSAwOyByb3VuZCA8IDI0OyByb3VuZCsrKSB7XG4gICAgLy8gUGlcbiAgICBbeCwgeV0gPSBbeSwgKDIgKiB4ICsgMyAqIHkpICUgNV07XG4gICAgU0hBM19QSS5wdXNoKDIgKiAoNSAqIHkgKyB4KSk7XG4gICAgLy8gUm90YXRpb25hbFxuICAgIFNIQTNfUk9UTC5wdXNoKCgoKHJvdW5kICsgMSkgKiAocm91bmQgKyAyKSkgLyAyKSAlIDY0KTtcbiAgICAvLyBJb3RhXG4gICAgbGV0IHQgPSBfMG47XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCA3OyBqKyspIHtcbiAgICAgICAgUiA9ICgoUiA8PCBfMW4pIF4gKChSID4+IF83bikgKiBfMHg3MW4pKSAlIF8yNTZuO1xuICAgICAgICBpZiAoUiAmIF8ybilcbiAgICAgICAgICAgIHQgXj0gXzFuIDw8ICgoXzFuIDw8IEJpZ0ludChqKSkgLSBfMW4pO1xuICAgIH1cbiAgICBfU0hBM19JT1RBLnB1c2godCk7XG59XG5jb25zdCBbU0hBM19JT1RBX0gsIFNIQTNfSU9UQV9MXSA9IF91NjRfanNfMS5kZWZhdWx0LnNwbGl0KF9TSEEzX0lPVEEsIHRydWUpO1xuLy8gTGVmdCByb3RhdGlvbiAod2l0aG91dCAwLCAzMiwgNjQpXG5jb25zdCByb3RsSCA9IChoLCBsLCBzKSA9PiBzID4gMzIgPyBfdTY0X2pzXzEuZGVmYXVsdC5yb3RsQkgoaCwgbCwgcykgOiBfdTY0X2pzXzEuZGVmYXVsdC5yb3RsU0goaCwgbCwgcyk7XG5jb25zdCByb3RsTCA9IChoLCBsLCBzKSA9PiBzID4gMzIgPyBfdTY0X2pzXzEuZGVmYXVsdC5yb3RsQkwoaCwgbCwgcykgOiBfdTY0X2pzXzEuZGVmYXVsdC5yb3RsU0woaCwgbCwgcyk7XG4vLyBTYW1lIGFzIGtlY2Nha2YxNjAwLCBidXQgYWxsb3dzIHRvIHNraXAgc29tZSByb3VuZHNcbmZ1bmN0aW9uIGtlY2Nha1Aocywgcm91bmRzID0gMjQpIHtcbiAgICBjb25zdCBCID0gbmV3IFVpbnQzMkFycmF5KDUgKiAyKTtcbiAgICAvLyBOT1RFOiBhbGwgaW5kaWNlcyBhcmUgeDIgc2luY2Ugd2Ugc3RvcmUgc3RhdGUgYXMgdTMyIGluc3RlYWQgb2YgdTY0IChiaWdpbnRzIHRvIHNsb3cgaW4ganMpXG4gICAgZm9yIChsZXQgcm91bmQgPSAyNCAtIHJvdW5kczsgcm91bmQgPCAyNDsgcm91bmQrKykge1xuICAgICAgICAvLyBUaGV0YSDOuFxuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICBCW3hdID0gc1t4XSBeIHNbeCArIDEwXSBeIHNbeCArIDIwXSBeIHNbeCArIDMwXSBeIHNbeCArIDQwXTtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCArPSAyKSB7XG4gICAgICAgICAgICBjb25zdCBpZHgxID0gKHggKyA4KSAlIDEwO1xuICAgICAgICAgICAgY29uc3QgaWR4MCA9ICh4ICsgMikgJSAxMDtcbiAgICAgICAgICAgIGNvbnN0IEIwID0gQltpZHgwXTtcbiAgICAgICAgICAgIGNvbnN0IEIxID0gQltpZHgwICsgMV07XG4gICAgICAgICAgICBjb25zdCBUaCA9IHJvdGxIKEIwLCBCMSwgMSkgXiBCW2lkeDFdO1xuICAgICAgICAgICAgY29uc3QgVGwgPSByb3RsTChCMCwgQjEsIDEpIF4gQltpZHgxICsgMV07XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDUwOyB5ICs9IDEwKSB7XG4gICAgICAgICAgICAgICAgc1t4ICsgeV0gXj0gVGg7XG4gICAgICAgICAgICAgICAgc1t4ICsgeSArIDFdIF49IFRsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJobyAoz4EpIGFuZCBQaSAoz4ApXG4gICAgICAgIGxldCBjdXJIID0gc1syXTtcbiAgICAgICAgbGV0IGN1ckwgPSBzWzNdO1xuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IDI0OyB0KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0ID0gU0hBM19ST1RMW3RdO1xuICAgICAgICAgICAgY29uc3QgVGggPSByb3RsSChjdXJILCBjdXJMLCBzaGlmdCk7XG4gICAgICAgICAgICBjb25zdCBUbCA9IHJvdGxMKGN1ckgsIGN1ckwsIHNoaWZ0KTtcbiAgICAgICAgICAgIGNvbnN0IFBJID0gU0hBM19QSVt0XTtcbiAgICAgICAgICAgIGN1ckggPSBzW1BJXTtcbiAgICAgICAgICAgIGN1ckwgPSBzW1BJICsgMV07XG4gICAgICAgICAgICBzW1BJXSA9IFRoO1xuICAgICAgICAgICAgc1tQSSArIDFdID0gVGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hpICjPhylcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA1MDsgeSArPSAxMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgICAgIEJbeF0gPSBzW3kgKyB4XTtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgICAgICBzW3kgKyB4XSBePSB+QlsoeCArIDIpICUgMTBdICYgQlsoeCArIDQpICUgMTBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIElvdGEgKM65KVxuICAgICAgICBzWzBdIF49IFNIQTNfSU9UQV9IW3JvdW5kXTtcbiAgICAgICAgc1sxXSBePSBTSEEzX0lPVEFfTFtyb3VuZF07XG4gICAgfVxuICAgIEIuZmlsbCgwKTtcbn1cbmV4cG9ydHMua2VjY2FrUCA9IGtlY2Nha1A7XG5jbGFzcyBLZWNjYWsgZXh0ZW5kcyB1dGlsc19qc18xLkhhc2gge1xuICAgIC8vIE5PVEU6IHdlIGFjY2VwdCBhcmd1bWVudHMgaW4gYnl0ZXMgaW5zdGVhZCBvZiBiaXRzIGhlcmUuXG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCBlbmFibGVYT0YgPSBmYWxzZSwgcm91bmRzID0gMjQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLnN1ZmZpeCA9IHN1ZmZpeDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMuZW5hYmxlWE9GID0gZW5hYmxlWE9GO1xuICAgICAgICB0aGlzLnJvdW5kcyA9IHJvdW5kcztcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLnBvc091dCA9IDA7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gQ2FuIGJlIHBhc3NlZCBmcm9tIHVzZXIgYXMgZGtMZW5cbiAgICAgICAgX2Fzc2VydF9qc18xLmRlZmF1bHQubnVtYmVyKG91dHB1dExlbik7XG4gICAgICAgIC8vIDE2MDAgPSA1eDUgbWF0cml4IG9mIDY0Yml0LiAgMTYwMCBiaXRzID09PSAyMDAgYnl0ZXNcbiAgICAgICAgaWYgKDAgPj0gdGhpcy5ibG9ja0xlbiB8fCB0aGlzLmJsb2NrTGVuID49IDIwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2hhMyBzdXBwb3J0cyBvbmx5IGtlY2Nhay1mMTYwMCBmdW5jdGlvbicpO1xuICAgICAgICB0aGlzLnN0YXRlID0gbmV3IFVpbnQ4QXJyYXkoMjAwKTtcbiAgICAgICAgdGhpcy5zdGF0ZTMyID0gKDAsIHV0aWxzX2pzXzEudTMyKSh0aGlzLnN0YXRlKTtcbiAgICB9XG4gICAga2VjY2FrKCkge1xuICAgICAgICBrZWNjYWtQKHRoaXMuc3RhdGUzMiwgdGhpcy5yb3VuZHMpO1xuICAgICAgICB0aGlzLnBvc091dCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgX2Fzc2VydF9qc18xLmRlZmF1bHQuZXhpc3RzKHRoaXMpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBzdGF0ZSB9ID0gdGhpcztcbiAgICAgICAgZGF0YSA9ICgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRha2U7IGkrKylcbiAgICAgICAgICAgICAgICBzdGF0ZVt0aGlzLnBvcysrXSBePSBkYXRhW3BvcysrXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICBpZiAodGhpcy5maW5pc2hlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHsgc3RhdGUsIHN1ZmZpeCwgcG9zLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgLy8gRG8gdGhlIHBhZGRpbmdcbiAgICAgICAgc3RhdGVbcG9zXSBePSBzdWZmaXg7XG4gICAgICAgIGlmICgoc3VmZml4ICYgMHg4MCkgIT09IDAgJiYgcG9zID09PSBibG9ja0xlbiAtIDEpXG4gICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICBzdGF0ZVtibG9ja0xlbiAtIDFdIF49IDB4ODA7XG4gICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgfVxuICAgIHdyaXRlSW50byhvdXQpIHtcbiAgICAgICAgX2Fzc2VydF9qc18xLmRlZmF1bHQuZXhpc3RzKHRoaXMsIGZhbHNlKTtcbiAgICAgICAgX2Fzc2VydF9qc18xLmRlZmF1bHQuYnl0ZXMob3V0KTtcbiAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgY29uc3QgYnVmZmVyT3V0ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgbGVuID0gb3V0Lmxlbmd0aDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zT3V0ID49IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvc091dCwgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIG91dC5zZXQoYnVmZmVyT3V0LnN1YmFycmF5KHRoaXMucG9zT3V0LCB0aGlzLnBvc091dCArIHRha2UpLCBwb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3NPdXQgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHhvZkludG8ob3V0KSB7XG4gICAgICAgIC8vIFNoYTMvS2VjY2FrIHVzYWdlIHdpdGggWE9GIGlzIHByb2JhYmx5IG1pc3Rha2UsIG9ubHkgU0hBS0UgaW5zdGFuY2VzIGNhbiBkbyBYT0ZcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZVhPRilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWE9GIGlzIG5vdCBwb3NzaWJsZSBmb3IgdGhpcyBpbnN0YW5jZScpO1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICB9XG4gICAgeG9mKGJ5dGVzKSB7XG4gICAgICAgIF9hc3NlcnRfanNfMS5kZWZhdWx0Lm51bWJlcihieXRlcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnhvZkludG8obmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKTtcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgX2Fzc2VydF9qc18xLmRlZmF1bHQub3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3QoKSB3YXMgYWxyZWFkeSBjYWxsZWQnKTtcbiAgICAgICAgdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlnZXN0SW50byhuZXcgVWludDhBcnJheSh0aGlzLm91dHB1dExlbikpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhdGUuZmlsbCgwKTtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgcm91bmRzLCBlbmFibGVYT0YgfSA9IHRoaXM7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCBlbmFibGVYT0YsIHJvdW5kcykpO1xuICAgICAgICB0by5zdGF0ZTMyLnNldCh0aGlzLnN0YXRlMzIpO1xuICAgICAgICB0by5wb3MgPSB0aGlzLnBvcztcbiAgICAgICAgdG8ucG9zT3V0ID0gdGhpcy5wb3NPdXQ7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gdGhpcy5maW5pc2hlZDtcbiAgICAgICAgdG8ucm91bmRzID0gcm91bmRzO1xuICAgICAgICAvLyBTdWZmaXggY2FuIGNoYW5nZSBpbiBjU0hBS0VcbiAgICAgICAgdG8uc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRvLmVuYWJsZVhPRiA9IGVuYWJsZVhPRjtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gdGhpcy5kZXN0cm95ZWQ7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG5leHBvcnRzLktlY2NhayA9IEtlY2NhaztcbmNvbnN0IGdlbiA9IChzdWZmaXgsIGJsb2NrTGVuLCBvdXRwdXRMZW4pID0+ICgwLCB1dGlsc19qc18xLndyYXBDb25zdHJ1Y3RvcikoKCkgPT4gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4pKTtcbmV4cG9ydHMuc2hhM18yMjQgPSBnZW4oMHgwNiwgMTQ0LCAyMjQgLyA4KTtcbi8qKlxuICogU0hBMy0yNTYgaGFzaCBmdW5jdGlvblxuICogQHBhcmFtIG1lc3NhZ2UgLSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnRzLnNoYTNfMjU2ID0gZ2VuKDB4MDYsIDEzNiwgMjU2IC8gOCk7XG5leHBvcnRzLnNoYTNfMzg0ID0gZ2VuKDB4MDYsIDEwNCwgMzg0IC8gOCk7XG5leHBvcnRzLnNoYTNfNTEyID0gZ2VuKDB4MDYsIDcyLCA1MTIgLyA4KTtcbmV4cG9ydHMua2VjY2FrXzIyNCA9IGdlbigweDAxLCAxNDQsIDIyNCAvIDgpO1xuLyoqXG4gKiBrZWNjYWstMjU2IGhhc2ggZnVuY3Rpb24uIERpZmZlcmVudCBmcm9tIFNIQTMtMjU2LlxuICogQHBhcmFtIG1lc3NhZ2UgLSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnRzLmtlY2Nha18yNTYgPSBnZW4oMHgwMSwgMTM2LCAyNTYgLyA4KTtcbmV4cG9ydHMua2VjY2FrXzM4NCA9IGdlbigweDAxLCAxMDQsIDM4NCAvIDgpO1xuZXhwb3J0cy5rZWNjYWtfNTEyID0gZ2VuKDB4MDEsIDcyLCA1MTIgLyA4KTtcbmNvbnN0IGdlblNoYWtlID0gKHN1ZmZpeCwgYmxvY2tMZW4sIG91dHB1dExlbikgPT4gKDAsIHV0aWxzX2pzXzEud3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMpKChvcHRzID0ge30pID0+IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3B0cy5ka0xlbiA9PT0gdW5kZWZpbmVkID8gb3V0cHV0TGVuIDogb3B0cy5ka0xlbiwgdHJ1ZSkpO1xuZXhwb3J0cy5zaGFrZTEyOCA9IGdlblNoYWtlKDB4MWYsIDE2OCwgMTI4IC8gOCk7XG5leHBvcnRzLnNoYWtlMjU2ID0gZ2VuU2hha2UoMHgxZiwgMTM2LCAyNTYgLyA4KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic2hha2UyNTYiLCJzaGFrZTEyOCIsImtlY2Nha181MTIiLCJrZWNjYWtfMzg0Iiwia2VjY2FrXzI1NiIsImtlY2Nha18yMjQiLCJzaGEzXzUxMiIsInNoYTNfMzg0Iiwic2hhM18yNTYiLCJzaGEzXzIyNCIsIktlY2NhayIsImtlY2Nha1AiLCJfYXNzZXJ0X2pzXzEiLCJyZXF1aXJlIiwiX3U2NF9qc18xIiwidXRpbHNfanNfMSIsIlNIQTNfUEkiLCJTSEEzX1JPVEwiLCJfU0hBM19JT1RBIiwiXzBuIiwiQmlnSW50IiwiXzFuIiwiXzJuIiwiXzduIiwiXzI1Nm4iLCJfMHg3MW4iLCJyb3VuZCIsIlIiLCJ4IiwieSIsInB1c2giLCJ0IiwiaiIsIlNIQTNfSU9UQV9IIiwiU0hBM19JT1RBX0wiLCJkZWZhdWx0Iiwic3BsaXQiLCJyb3RsSCIsImgiLCJsIiwicyIsInJvdGxCSCIsInJvdGxTSCIsInJvdGxMIiwicm90bEJMIiwicm90bFNMIiwicm91bmRzIiwiQiIsIlVpbnQzMkFycmF5IiwiaWR4MSIsImlkeDAiLCJCMCIsIkIxIiwiVGgiLCJUbCIsImN1ckgiLCJjdXJMIiwic2hpZnQiLCJQSSIsImZpbGwiLCJIYXNoIiwiY29uc3RydWN0b3IiLCJibG9ja0xlbiIsInN1ZmZpeCIsIm91dHB1dExlbiIsImVuYWJsZVhPRiIsInBvcyIsInBvc091dCIsImZpbmlzaGVkIiwiZGVzdHJveWVkIiwibnVtYmVyIiwiRXJyb3IiLCJzdGF0ZSIsIlVpbnQ4QXJyYXkiLCJzdGF0ZTMyIiwidTMyIiwia2VjY2FrIiwidXBkYXRlIiwiZGF0YSIsImV4aXN0cyIsInRvQnl0ZXMiLCJsZW4iLCJsZW5ndGgiLCJ0YWtlIiwiTWF0aCIsIm1pbiIsImkiLCJmaW5pc2giLCJ3cml0ZUludG8iLCJvdXQiLCJieXRlcyIsImJ1ZmZlck91dCIsInNldCIsInN1YmFycmF5IiwieG9mSW50byIsInhvZiIsImRpZ2VzdEludG8iLCJvdXRwdXQiLCJkZXN0cm95IiwiZGlnZXN0IiwiX2Nsb25lSW50byIsInRvIiwiZ2VuIiwid3JhcENvbnN0cnVjdG9yIiwiZ2VuU2hha2UiLCJ3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyIsIm9wdHMiLCJka0xlbiIsInVuZGVmaW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/sha3.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/utils.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ethereum-cryptography/node_modules/@noble/hashes/utils.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\nconst crypto_1 = __webpack_require__(/*! @noble/hashes/crypto */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/cryptoNode.js\");\nconst u8a = (a)=>a instanceof Uint8Array;\n// Cast array to different type\nconst u8 = (arr)=>new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.u8 = u8;\nconst u32 = (arr)=>new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nexports.u32 = u32;\n// Cast array to view\nconst createView = (arr)=>new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.createView = createView;\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift)=>word << 32 - shift | word >>> shift;\nexports.rotr = rotr;\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nexports.isLE = new Uint8Array(new Uint32Array([\n    0x11223344\n]).buffer)[0] === 0x44;\nif (!exports.isLE) throw new Error(\"Non little-endian hardware is not supported\");\nconst hexes = Array.from({\n    length: 256\n}, (v, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    if (!u8a(bytes)) throw new Error(\"Uint8Array expected\");\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nexports.bytesToHex = bytesToHex;\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    const len = hex.length;\n    if (len % 2) throw new Error(\"padded hex string expected, got unpadded hex of length \" + len);\n    const array = new Uint8Array(len / 2);\n    for(let i = 0; i < array.length; i++){\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0) throw new Error(\"Invalid byte sequence\");\n        array[i] = byte;\n    }\n    return array;\n}\nexports.hexToBytes = hexToBytes;\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async ()=>{};\nexports.nextTick = nextTick;\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for(let i = 0; i < iters; i++){\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick) continue;\n        await (0, exports.nextTick)();\n        ts += diff;\n    }\n}\nexports.asyncLoop = asyncLoop;\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\nexports.utf8ToBytes = utf8ToBytes;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */ function toBytes(data) {\n    if (typeof data === \"string\") data = utf8ToBytes(data);\n    if (!u8a(data)) throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\nexports.toBytes = toBytes;\n/**\n * Copies several Uint8Arrays into one.\n */ function concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a)=>sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a)=>{\n        if (!u8a(a)) throw new Error(\"Uint8Array expected\");\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nexports.concatBytes = concatBytes;\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nexports.Hash = Hash;\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj)=>Object.prototype.toString.call(obj) === \"[object Object]\" && obj.constructor === Object;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && (typeof opts !== \"object\" || !isPlainObject(opts))) throw new Error(\"Options should be object or undefined\");\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexports.checkOpts = checkOpts;\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg)=>hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = ()=>hashCons();\n    return hashC;\n}\nexports.wrapConstructor = wrapConstructor;\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nexports.wrapConstructorWithOpts = wrapConstructorWithOpts;\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nexports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */ function randomBytes(bytesLength = 32) {\n    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === \"function\") {\n        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error(\"crypto.getRandomValues must be defined\");\n}\nexports.randomBytes = randomBytes; //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2Isb0VBQW9FLEdBQ3BFQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUJBQW1CLEdBQUdBLGtDQUFrQyxHQUFHQSwrQkFBK0IsR0FBR0EsdUJBQXVCLEdBQUdBLGlCQUFpQixHQUFHQSxZQUFZLEdBQUdBLG1CQUFtQixHQUFHQSxlQUFlLEdBQUdBLG1CQUFtQixHQUFHQSxpQkFBaUIsR0FBR0EsZ0JBQWdCLEdBQUdBLGtCQUFrQixHQUFHQSxrQkFBa0IsR0FBR0EsWUFBWSxHQUFHQSxZQUFZLEdBQUdBLGtCQUFrQixHQUFHQSxXQUFXLEdBQUdBLFVBQVUsR0FBRyxLQUFLO0FBQzVYLG9GQUFvRjtBQUNwRixzRUFBc0U7QUFDdEUsa0VBQWtFO0FBQ2xFLDhEQUE4RDtBQUM5RCwrREFBK0Q7QUFDL0QsOERBQThEO0FBQzlELE1BQU1vQixXQUFXQyxtQkFBT0EsQ0FBQyxpSEFBc0I7QUFDL0MsTUFBTUMsTUFBTSxDQUFDQyxJQUFNQSxhQUFhQztBQUNoQywrQkFBK0I7QUFDL0IsTUFBTUwsS0FBSyxDQUFDTSxNQUFRLElBQUlELFdBQVdDLElBQUlDLE1BQU0sRUFBRUQsSUFBSUUsVUFBVSxFQUFFRixJQUFJRyxVQUFVO0FBQzdFNUIsVUFBVSxHQUFHbUI7QUFDYixNQUFNRCxNQUFNLENBQUNPLE1BQVEsSUFBSUksWUFBWUosSUFBSUMsTUFBTSxFQUFFRCxJQUFJRSxVQUFVLEVBQUVHLEtBQUtDLEtBQUssQ0FBQ04sSUFBSUcsVUFBVSxHQUFHO0FBQzdGNUIsV0FBVyxHQUFHa0I7QUFDZCxxQkFBcUI7QUFDckIsTUFBTUQsYUFBYSxDQUFDUSxNQUFRLElBQUlPLFNBQVNQLElBQUlDLE1BQU0sRUFBRUQsSUFBSUUsVUFBVSxFQUFFRixJQUFJRyxVQUFVO0FBQ25G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QU0sQ0FBQ0MsZUFBZSxDQUFDLElBQUl4RSxXQUFXc0U7SUFDMUQ7SUFDQSxNQUFNLElBQUkzRCxNQUFNO0FBQ3BCO0FBQ0FuQyxtQkFBbUIsR0FBR0UsYUFDdEIsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy91dGlscy5qcz9iZWEyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyohIG5vYmxlLWhhc2hlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yYW5kb21CeXRlcyA9IGV4cG9ydHMud3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMgPSBleHBvcnRzLndyYXBDb25zdHJ1Y3RvcldpdGhPcHRzID0gZXhwb3J0cy53cmFwQ29uc3RydWN0b3IgPSBleHBvcnRzLmNoZWNrT3B0cyA9IGV4cG9ydHMuSGFzaCA9IGV4cG9ydHMuY29uY2F0Qnl0ZXMgPSBleHBvcnRzLnRvQnl0ZXMgPSBleHBvcnRzLnV0ZjhUb0J5dGVzID0gZXhwb3J0cy5hc3luY0xvb3AgPSBleHBvcnRzLm5leHRUaWNrID0gZXhwb3J0cy5oZXhUb0J5dGVzID0gZXhwb3J0cy5ieXRlc1RvSGV4ID0gZXhwb3J0cy5pc0xFID0gZXhwb3J0cy5yb3RyID0gZXhwb3J0cy5jcmVhdGVWaWV3ID0gZXhwb3J0cy51MzIgPSBleHBvcnRzLnU4ID0gdm9pZCAwO1xuLy8gV2UgdXNlIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBicm93c2VycyBhbmQgbm9kZS5qcyAxNisuXG4vLyBub2RlLmpzIHZlcnNpb25zIGVhcmxpZXIgdGhhbiB2MTkgZG9uJ3QgZGVjbGFyZSBpdCBpbiBnbG9iYWwgc2NvcGUuXG4vLyBGb3Igbm9kZS5qcywgcGFja2FnZS5qc29uI2V4cG9ydHMgZmllbGQgbWFwcGluZyByZXdyaXRlcyBpbXBvcnRcbi8vIGZyb20gYGNyeXB0b2AgdG8gYGNyeXB0b05vZGVgLCB3aGljaCBpbXBvcnRzIG5hdGl2ZSBtb2R1bGUuXG4vLyBNYWtlcyB0aGUgdXRpbHMgdW4taW1wb3J0YWJsZSBpbiBicm93c2VycyB3aXRob3V0IGEgYnVuZGxlci5cbi8vIE9uY2Ugbm9kZS5qcyAxOCBpcyBkZXByZWNhdGVkLCB3ZSBjYW4ganVzdCBkcm9wIHRoZSBpbXBvcnQuXG5jb25zdCBjcnlwdG9fMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL2NyeXB0b1wiKTtcbmNvbnN0IHU4YSA9IChhKSA9PiBhIGluc3RhbmNlb2YgVWludDhBcnJheTtcbi8vIENhc3QgYXJyYXkgdG8gZGlmZmVyZW50IHR5cGVcbmNvbnN0IHU4ID0gKGFycikgPT4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbmV4cG9ydHMudTggPSB1ODtcbmNvbnN0IHUzMiA9IChhcnIpID0+IG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbmV4cG9ydHMudTMyID0gdTMyO1xuLy8gQ2FzdCBhcnJheSB0byB2aWV3XG5jb25zdCBjcmVhdGVWaWV3ID0gKGFycikgPT4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG5leHBvcnRzLmNyZWF0ZVZpZXcgPSBjcmVhdGVWaWV3O1xuLy8gVGhlIHJvdGF0ZSByaWdodCAoY2lyY3VsYXIgcmlnaHQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5jb25zdCByb3RyID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCAoMzIgLSBzaGlmdCkpIHwgKHdvcmQgPj4+IHNoaWZ0KTtcbmV4cG9ydHMucm90ciA9IHJvdHI7XG4vLyBiaWctZW5kaWFuIGhhcmR3YXJlIGlzIHJhcmUuIEp1c3QgaW4gY2FzZSBzb21lb25lIHN0aWxsIGRlY2lkZXMgdG8gcnVuIGhhc2hlczpcbi8vIGVhcmx5LXRocm93IGFuIGVycm9yIGJlY2F1c2Ugd2UgZG9uJ3Qgc3VwcG9ydCBCRSB5ZXQuXG5leHBvcnRzLmlzTEUgPSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0O1xuaWYgKCFleHBvcnRzLmlzTEUpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb24gbGl0dGxlLWVuZGlhbiBoYXJkd2FyZSBpcyBub3Qgc3VwcG9ydGVkJyk7XG5jb25zdCBoZXhlcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAodiwgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGlmICghdThhKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbmV4cG9ydHMuYnl0ZXNUb0hleCA9IGJ5dGVzVG9IZXg7XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBsZW4gPSBoZXgubGVuZ3RoO1xuICAgIGlmIChsZW4gJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgbGVuKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbiAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaiA9IGkgKiAyO1xuICAgICAgICBjb25zdCBoZXhCeXRlID0gaGV4LnNsaWNlKGosIGogKyAyKTtcbiAgICAgICAgY29uc3QgYnl0ZSA9IE51bWJlci5wYXJzZUludChoZXhCeXRlLCAxNik7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZSkgfHwgYnl0ZSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZSBzZXF1ZW5jZScpO1xuICAgICAgICBhcnJheVtpXSA9IGJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbmV4cG9ydHMuaGV4VG9CeXRlcyA9IGhleFRvQnl0ZXM7XG4vLyBUaGVyZSBpcyBubyBzZXRJbW1lZGlhdGUgaW4gYnJvd3NlciBhbmQgc2V0VGltZW91dCBpcyBzbG93LlxuLy8gY2FsbCBvZiBhc3luYyBmbiB3aWxsIHJldHVybiBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGZ1bGxmaWxlZCBvbmx5IG9uXG4vLyBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG5jb25zdCBuZXh0VGljayA9IGFzeW5jICgpID0+IHsgfTtcbmV4cG9ydHMubmV4dFRpY2sgPSBuZXh0VGljaztcbi8vIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmdcbmFzeW5jIGZ1bmN0aW9uIGFzeW5jTG9vcChpdGVycywgdGljaywgY2IpIHtcbiAgICBsZXQgdHMgPSBEYXRlLm5vdygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcnM7IGkrKykge1xuICAgICAgICBjYihpKTtcbiAgICAgICAgLy8gRGF0ZS5ub3coKSBpcyBub3QgbW9ub3RvbmljLCBzbyBpbiBjYXNlIGlmIGNsb2NrIGdvZXMgYmFja3dhcmRzIHdlIHJldHVybiByZXR1cm4gY29udHJvbCB0b29cbiAgICAgICAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSB0cztcbiAgICAgICAgaWYgKGRpZmYgPj0gMCAmJiBkaWZmIDwgdGljaylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBhd2FpdCAoMCwgZXhwb3J0cy5uZXh0VGljaykoKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG5leHBvcnRzLmFzeW5jTG9vcCA9IGFzeW5jTG9vcDtcbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG5leHBvcnRzLnV0ZjhUb0J5dGVzID0gdXRmOFRvQnl0ZXM7XG4vKipcbiAqIE5vcm1hbGl6ZXMgKG5vbi1oZXgpIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFVpbnQ4QXJyYXkuXG4gKiBXYXJuaW5nOiB3aGVuIFVpbnQ4QXJyYXkgaXMgcGFzc2VkLCBpdCB3b3VsZCBOT1QgZ2V0IGNvcGllZC5cbiAqIEtlZXAgaW4gbWluZCBmb3IgZnV0dXJlIG11dGFibGUgb3BlcmF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gdG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGlmICghdThhKGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIFVpbnQ4QXJyYXksIGdvdCAke3R5cGVvZiBkYXRhfWApO1xuICAgIHJldHVybiBkYXRhO1xufVxuZXhwb3J0cy50b0J5dGVzID0gdG9CeXRlcztcbi8qKlxuICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGNvbnN0IHIgPSBuZXcgVWludDhBcnJheShhcnJheXMucmVkdWNlKChzdW0sIGEpID0+IHN1bSArIGEubGVuZ3RoLCAwKSk7XG4gICAgbGV0IHBhZCA9IDA7IC8vIHdhbGsgdGhyb3VnaCBlYWNoIGl0ZW0sIGVuc3VyZSB0aGV5IGhhdmUgcHJvcGVyIHR5cGVcbiAgICBhcnJheXMuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgICBpZiAoIXU4YShhKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgICAgICByLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHI7XG59XG5leHBvcnRzLmNvbmNhdEJ5dGVzID0gY29uY2F0Qnl0ZXM7XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuY2xhc3MgSGFzaCB7XG4gICAgLy8gU2FmZSB2ZXJzaW9uIHRoYXQgY2xvbmVzIGludGVybmFsIHN0YXRlXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG59XG5leHBvcnRzLkhhc2ggPSBIYXNoO1xuLy8gQ2hlY2sgaWYgb2JqZWN0IGRvZW5zJ3QgaGF2ZSBjdXN0b20gY29uc3RydWN0b3IgKGxpa2UgVWludDhBcnJheS9BcnJheSlcbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAob2JqKSA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG5mdW5jdGlvbiBjaGVja09wdHMoZGVmYXVsdHMsIG9wdHMpIHtcbiAgICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkICYmICh0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcgfHwgIWlzUGxhaW5PYmplY3Qob3B0cykpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuZXhwb3J0cy5jaGVja09wdHMgPSBjaGVja09wdHM7XG5mdW5jdGlvbiB3cmFwQ29uc3RydWN0b3IoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2cpID0+IGhhc2hDb25zKCkudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoKTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9ICgpID0+IGhhc2hDb25zKCk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0cy53cmFwQ29uc3RydWN0b3IgPSB3cmFwQ29uc3RydWN0b3I7XG5mdW5jdGlvbiB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydHMud3JhcENvbnN0cnVjdG9yV2l0aE9wdHMgPSB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cztcbmZ1bmN0aW9uIHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0cy53cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyA9IHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzO1xuLyoqXG4gKiBTZWN1cmUgUFJORy4gVXNlcyBgY3J5cHRvLmdldFJhbmRvbVZhbHVlc2AsIHdoaWNoIGRlZmVycyB0byBPUy5cbiAqL1xuZnVuY3Rpb24gcmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGggPSAzMikge1xuICAgIGlmIChjcnlwdG9fMS5jcnlwdG8gJiYgdHlwZW9mIGNyeXB0b18xLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0b18xLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZCcpO1xufVxuZXhwb3J0cy5yYW5kb21CeXRlcyA9IHJhbmRvbUJ5dGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicmFuZG9tQnl0ZXMiLCJ3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyIsIndyYXBDb25zdHJ1Y3RvcldpdGhPcHRzIiwid3JhcENvbnN0cnVjdG9yIiwiY2hlY2tPcHRzIiwiSGFzaCIsImNvbmNhdEJ5dGVzIiwidG9CeXRlcyIsInV0ZjhUb0J5dGVzIiwiYXN5bmNMb29wIiwibmV4dFRpY2siLCJoZXhUb0J5dGVzIiwiYnl0ZXNUb0hleCIsImlzTEUiLCJyb3RyIiwiY3JlYXRlVmlldyIsInUzMiIsInU4IiwiY3J5cHRvXzEiLCJyZXF1aXJlIiwidThhIiwiYSIsIlVpbnQ4QXJyYXkiLCJhcnIiLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsIlVpbnQzMkFycmF5IiwiTWF0aCIsImZsb29yIiwiRGF0YVZpZXciLCJ3b3JkIiwic2hpZnQiLCJFcnJvciIsImhleGVzIiwiQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwidiIsImkiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiYnl0ZXMiLCJoZXgiLCJsZW4iLCJhcnJheSIsImoiLCJoZXhCeXRlIiwic2xpY2UiLCJieXRlIiwiTnVtYmVyIiwicGFyc2VJbnQiLCJpc05hTiIsIml0ZXJzIiwidGljayIsImNiIiwidHMiLCJEYXRlIiwibm93IiwiZGlmZiIsInN0ciIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwiZGF0YSIsImFycmF5cyIsInIiLCJyZWR1Y2UiLCJzdW0iLCJwYWQiLCJmb3JFYWNoIiwic2V0IiwiY2xvbmUiLCJfY2xvbmVJbnRvIiwiaXNQbGFpbk9iamVjdCIsIm9iaiIsInByb3RvdHlwZSIsImNhbGwiLCJjb25zdHJ1Y3RvciIsImRlZmF1bHRzIiwib3B0cyIsInVuZGVmaW5lZCIsIm1lcmdlZCIsImFzc2lnbiIsImhhc2hDb25zIiwiaGFzaEMiLCJtc2ciLCJ1cGRhdGUiLCJkaWdlc3QiLCJ0bXAiLCJvdXRwdXRMZW4iLCJibG9ja0xlbiIsImNyZWF0ZSIsImJ5dGVzTGVuZ3RoIiwiY3J5cHRvIiwiZ2V0UmFuZG9tVmFsdWVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereum-cryptography/secp256k1.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethereum-cryptography/secp256k1.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.secp256k1 = void 0;\nvar secp256k1_1 = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/curves/secp256k1.js\");\nObject.defineProperty(exports, \"secp256k1\", ({\n    enumerable: true,\n    get: function() {\n        return secp256k1_1.secp256k1;\n    }\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L3NlY3AyNTZrMS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsaUJBQWlCLEdBQUcsS0FBSztBQUN6QixJQUFJRyxjQUFjQyxtQkFBT0EsQ0FBQyxtSEFBeUI7QUFDbkROLDZDQUE0QztJQUFFTyxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPSCxZQUFZRCxTQUFTO0lBQUU7QUFBRSxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L3NlY3AyNTZrMS5qcz8yN2NlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZWNwMjU2azEgPSB2b2lkIDA7XG52YXIgc2VjcDI1NmsxXzEgPSByZXF1aXJlKFwiQG5vYmxlL2N1cnZlcy9zZWNwMjU2azFcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzZWNwMjU2azFcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlY3AyNTZrMV8xLnNlY3AyNTZrMTsgfSB9KTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInNlY3AyNTZrMSIsInNlY3AyNTZrMV8xIiwicmVxdWlyZSIsImVudW1lcmFibGUiLCJnZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereum-cryptography/secp256k1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereum-cryptography/utils.js":
/*!*****************************************************!*\
  !*** ./node_modules/ethereum-cryptography/utils.js ***!
  \*****************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.crypto = exports.wrapHash = exports.equalsBytes = exports.hexToBytes = exports.bytesToUtf8 = exports.utf8ToBytes = exports.createView = exports.concatBytes = exports.toHex = exports.bytesToHex = exports.assertBytes = exports.assertBool = void 0;\nconst _assert_1 = __importDefault(__webpack_require__(/*! @noble/hashes/_assert */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/_assert.js\"));\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/utils.js\");\nconst assertBool = _assert_1.default.bool;\nexports.assertBool = assertBool;\nconst assertBytes = _assert_1.default.bytes;\nexports.assertBytes = assertBytes;\nvar utils_2 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/utils.js\");\nObject.defineProperty(exports, \"bytesToHex\", ({\n    enumerable: true,\n    get: function() {\n        return utils_2.bytesToHex;\n    }\n}));\nObject.defineProperty(exports, \"toHex\", ({\n    enumerable: true,\n    get: function() {\n        return utils_2.bytesToHex;\n    }\n}));\nObject.defineProperty(exports, \"concatBytes\", ({\n    enumerable: true,\n    get: function() {\n        return utils_2.concatBytes;\n    }\n}));\nObject.defineProperty(exports, \"createView\", ({\n    enumerable: true,\n    get: function() {\n        return utils_2.createView;\n    }\n}));\nObject.defineProperty(exports, \"utf8ToBytes\", ({\n    enumerable: true,\n    get: function() {\n        return utils_2.utf8ToBytes;\n    }\n}));\n// buf.toString('utf8') -> bytesToUtf8(buf)\nfunction bytesToUtf8(data) {\n    if (!(data instanceof Uint8Array)) {\n        throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);\n    }\n    return new TextDecoder().decode(data);\n}\nexports.bytesToUtf8 = bytesToUtf8;\nfunction hexToBytes(data) {\n    const sliced = data.startsWith(\"0x\") ? data.substring(2) : data;\n    return (0, utils_1.hexToBytes)(sliced);\n}\nexports.hexToBytes = hexToBytes;\n// buf.equals(buf2) -> equalsBytes(buf, buf2)\nfunction equalsBytes(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for(let i = 0; i < a.length; i++){\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.equalsBytes = equalsBytes;\n// Internal utils\nfunction wrapHash(hash) {\n    return (msg)=>{\n        _assert_1.default.bytes(msg);\n        return hash(msg);\n    };\n}\nexports.wrapHash = wrapHash;\n// TODO(v3): switch away from node crypto, remove this unnecessary variable.\nexports.crypto = (()=>{\n    const webCrypto = typeof globalThis === \"object\" && \"crypto\" in globalThis ? globalThis.crypto : undefined;\n    const nodeRequire =  true && typeof module.require === \"function\" && module.require.bind(module);\n    return {\n        node: nodeRequire && !webCrypto ? nodeRequire(\"crypto\") : undefined,\n        web: webCrypto\n    };\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiLElBQUlBLGtCQUFrQixJQUFLLElBQUksSUFBSSxDQUFDQSxlQUFlLElBQUssU0FBVUMsR0FBRztJQUNqRSxPQUFPLE9BQVFBLElBQUlDLFVBQVUsR0FBSUQsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFDNUQ7QUFDQUUsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGNBQWMsR0FBR0EsZ0JBQWdCLEdBQUdBLG1CQUFtQixHQUFHQSxrQkFBa0IsR0FBR0EsbUJBQW1CLEdBQUdBLG1CQUFtQixHQUFHQSxrQkFBa0IsR0FBR0EsbUJBQW1CLEdBQUdBLGFBQWEsR0FBR0Esa0JBQWtCLEdBQUdBLG1CQUFtQixHQUFHQSxrQkFBa0IsR0FBRyxLQUFLO0FBQzNQLE1BQU1jLFlBQVluQixnQkFBZ0JvQixtQkFBT0EsQ0FBQywrR0FBdUI7QUFDakUsTUFBTUMsVUFBVUQsbUJBQU9BLENBQUMsMkdBQXFCO0FBQzdDLE1BQU1GLGFBQWFDLFVBQVVHLE9BQU8sQ0FBQ0MsSUFBSTtBQUN6Q2xCLGtCQUFrQixHQUFHYTtBQUNyQixNQUFNRCxjQUFjRSxVQUFVRyxPQUFPLENBQUNFLEtBQUs7QUFDM0NuQixtQkFBbUIsR0FBR1k7QUFDdEIsSUFBSVEsVUFBVUwsbUJBQU9BLENBQUMsMkdBQXFCO0FBQzNDakIsOENBQTZDO0lBQUV1QixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRixRQUFRVCxVQUFVO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDbkhiLHlDQUF3QztJQUFFdUIsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0YsUUFBUVQsVUFBVTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzlHYiwrQ0FBOEM7SUFBRXVCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9GLFFBQVFYLFdBQVc7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNySFgsOENBQTZDO0lBQUV1QixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRixRQUFRWixVQUFVO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDbkhWLCtDQUE4QztJQUFFdUIsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0YsUUFBUWIsV0FBVztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3JILDJDQUEyQztBQUMzQyxTQUFTRCxZQUFZaUIsSUFBSTtJQUNyQixJQUFJLENBQUVBLENBQUFBLGdCQUFnQkMsVUFBUyxHQUFJO1FBQy9CLE1BQU0sSUFBSUMsVUFBVSxDQUFDLHFDQUFxQyxFQUFFLE9BQU9GLEtBQUssQ0FBQztJQUM3RTtJQUNBLE9BQU8sSUFBSUcsY0FBY0MsTUFBTSxDQUFDSjtBQUNwQztBQUNBdkIsbUJBQW1CLEdBQUdNO0FBQ3RCLFNBQVNELFdBQVdrQixJQUFJO0lBQ3BCLE1BQU1LLFNBQVNMLEtBQUtNLFVBQVUsQ0FBQyxRQUFRTixLQUFLTyxTQUFTLENBQUMsS0FBS1A7SUFDM0QsT0FBTyxDQUFDLEdBQUdQLFFBQVFYLFVBQVUsRUFBRXVCO0FBQ25DO0FBQ0E1QixrQkFBa0IsR0FBR0s7QUFDckIsNkNBQTZDO0FBQzdDLFNBQVNELFlBQVkyQixDQUFDLEVBQUVDLENBQUM7SUFDckIsSUFBSUQsRUFBRUUsTUFBTSxLQUFLRCxFQUFFQyxNQUFNLEVBQUU7UUFDdkIsT0FBTztJQUNYO0lBQ0EsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILEVBQUVFLE1BQU0sRUFBRUMsSUFBSztRQUMvQixJQUFJSCxDQUFDLENBQUNHLEVBQUUsS0FBS0YsQ0FBQyxDQUFDRSxFQUFFLEVBQUU7WUFDZixPQUFPO1FBQ1g7SUFDSjtJQUNBLE9BQU87QUFDWDtBQUNBbEMsbUJBQW1CLEdBQUdJO0FBQ3RCLGlCQUFpQjtBQUNqQixTQUFTRCxTQUFTZ0MsSUFBSTtJQUNsQixPQUFPLENBQUNDO1FBQ0p0QixVQUFVRyxPQUFPLENBQUNFLEtBQUssQ0FBQ2lCO1FBQ3hCLE9BQU9ELEtBQUtDO0lBQ2hCO0FBQ0o7QUFDQXBDLGdCQUFnQixHQUFHRztBQUNuQiw0RUFBNEU7QUFDNUVILGNBQWMsR0FBRyxDQUFDO0lBQ2QsTUFBTXFDLFlBQVksT0FBT0MsZUFBZSxZQUFZLFlBQVlBLGFBQWFBLFdBQVdwQyxNQUFNLEdBQUdxQztJQUNqRyxNQUFNQyxjQUFjLEtBQTZCLElBQzdDLE9BQU9DLE9BQU8xQixPQUFPLEtBQUssY0FDMUIwQixPQUFPMUIsT0FBTyxDQUFDMkIsSUFBSSxDQUFDRDtJQUN4QixPQUFPO1FBQ0hFLE1BQU1ILGVBQWUsQ0FBQ0gsWUFBWUcsWUFBWSxZQUFZRDtRQUMxREssS0FBS1A7SUFDVDtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtLWNyeXB0b2dyYXBoeS91dGlscy5qcz81NDNmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcnlwdG8gPSBleHBvcnRzLndyYXBIYXNoID0gZXhwb3J0cy5lcXVhbHNCeXRlcyA9IGV4cG9ydHMuaGV4VG9CeXRlcyA9IGV4cG9ydHMuYnl0ZXNUb1V0ZjggPSBleHBvcnRzLnV0ZjhUb0J5dGVzID0gZXhwb3J0cy5jcmVhdGVWaWV3ID0gZXhwb3J0cy5jb25jYXRCeXRlcyA9IGV4cG9ydHMudG9IZXggPSBleHBvcnRzLmJ5dGVzVG9IZXggPSBleHBvcnRzLmFzc2VydEJ5dGVzID0gZXhwb3J0cy5hc3NlcnRCb29sID0gdm9pZCAwO1xuY29uc3QgX2Fzc2VydF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL19hc3NlcnRcIikpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCIpO1xuY29uc3QgYXNzZXJ0Qm9vbCA9IF9hc3NlcnRfMS5kZWZhdWx0LmJvb2w7XG5leHBvcnRzLmFzc2VydEJvb2wgPSBhc3NlcnRCb29sO1xuY29uc3QgYXNzZXJ0Qnl0ZXMgPSBfYXNzZXJ0XzEuZGVmYXVsdC5ieXRlcztcbmV4cG9ydHMuYXNzZXJ0Qnl0ZXMgPSBhc3NlcnRCeXRlcztcbnZhciB1dGlsc18yID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvdXRpbHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJieXRlc1RvSGV4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18yLmJ5dGVzVG9IZXg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b0hleFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMi5ieXRlc1RvSGV4OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29uY2F0Qnl0ZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzIuY29uY2F0Qnl0ZXM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVWaWV3XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18yLmNyZWF0ZVZpZXc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1dGY4VG9CeXRlc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMi51dGY4VG9CeXRlczsgfSB9KTtcbi8vIGJ1Zi50b1N0cmluZygndXRmOCcpIC0+IGJ5dGVzVG9VdGY4KGJ1ZilcbmZ1bmN0aW9uIGJ5dGVzVG9VdGY4KGRhdGEpIHtcbiAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgYnl0ZXNUb1V0ZjggZXhwZWN0ZWQgVWludDhBcnJheSwgZ290ICR7dHlwZW9mIGRhdGF9YCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoZGF0YSk7XG59XG5leHBvcnRzLmJ5dGVzVG9VdGY4ID0gYnl0ZXNUb1V0Zjg7XG5mdW5jdGlvbiBoZXhUb0J5dGVzKGRhdGEpIHtcbiAgICBjb25zdCBzbGljZWQgPSBkYXRhLnN0YXJ0c1dpdGgoXCIweFwiKSA/IGRhdGEuc3Vic3RyaW5nKDIpIDogZGF0YTtcbiAgICByZXR1cm4gKDAsIHV0aWxzXzEuaGV4VG9CeXRlcykoc2xpY2VkKTtcbn1cbmV4cG9ydHMuaGV4VG9CeXRlcyA9IGhleFRvQnl0ZXM7XG4vLyBidWYuZXF1YWxzKGJ1ZjIpIC0+IGVxdWFsc0J5dGVzKGJ1ZiwgYnVmMilcbmZ1bmN0aW9uIGVxdWFsc0J5dGVzKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmVxdWFsc0J5dGVzID0gZXF1YWxzQnl0ZXM7XG4vLyBJbnRlcm5hbCB1dGlsc1xuZnVuY3Rpb24gd3JhcEhhc2goaGFzaCkge1xuICAgIHJldHVybiAobXNnKSA9PiB7XG4gICAgICAgIF9hc3NlcnRfMS5kZWZhdWx0LmJ5dGVzKG1zZyk7XG4gICAgICAgIHJldHVybiBoYXNoKG1zZyk7XG4gICAgfTtcbn1cbmV4cG9ydHMud3JhcEhhc2ggPSB3cmFwSGFzaDtcbi8vIFRPRE8odjMpOiBzd2l0Y2ggYXdheSBmcm9tIG5vZGUgY3J5cHRvLCByZW1vdmUgdGhpcyB1bm5lY2Vzc2FyeSB2YXJpYWJsZS5cbmV4cG9ydHMuY3J5cHRvID0gKCgpID0+IHtcbiAgICBjb25zdCB3ZWJDcnlwdG8gPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gXCJvYmplY3RcIiAmJiBcImNyeXB0b1wiIGluIGdsb2JhbFRoaXMgPyBnbG9iYWxUaGlzLmNyeXB0byA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBub2RlUmVxdWlyZSA9IHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgdHlwZW9mIG1vZHVsZS5yZXF1aXJlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgbW9kdWxlLnJlcXVpcmUuYmluZChtb2R1bGUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5vZGU6IG5vZGVSZXF1aXJlICYmICF3ZWJDcnlwdG8gPyBub2RlUmVxdWlyZShcImNyeXB0b1wiKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgd2ViOiB3ZWJDcnlwdG9cbiAgICB9O1xufSkoKTtcbiJdLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjcnlwdG8iLCJ3cmFwSGFzaCIsImVxdWFsc0J5dGVzIiwiaGV4VG9CeXRlcyIsImJ5dGVzVG9VdGY4IiwidXRmOFRvQnl0ZXMiLCJjcmVhdGVWaWV3IiwiY29uY2F0Qnl0ZXMiLCJ0b0hleCIsImJ5dGVzVG9IZXgiLCJhc3NlcnRCeXRlcyIsImFzc2VydEJvb2wiLCJfYXNzZXJ0XzEiLCJyZXF1aXJlIiwidXRpbHNfMSIsImRlZmF1bHQiLCJib29sIiwiYnl0ZXMiLCJ1dGlsc18yIiwiZW51bWVyYWJsZSIsImdldCIsImRhdGEiLCJVaW50OEFycmF5IiwiVHlwZUVycm9yIiwiVGV4dERlY29kZXIiLCJkZWNvZGUiLCJzbGljZWQiLCJzdGFydHNXaXRoIiwic3Vic3RyaW5nIiwiYSIsImIiLCJsZW5ndGgiLCJpIiwiaGFzaCIsIm1zZyIsIndlYkNyeXB0byIsImdsb2JhbFRoaXMiLCJ1bmRlZmluZWQiLCJub2RlUmVxdWlyZSIsIm1vZHVsZSIsImJpbmQiLCJub2RlIiwid2ViIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereum-cryptography/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereum-cryptography/esm/keccak.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethereum-cryptography/esm/keccak.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keccak224: () => (/* binding */ keccak224),\n/* harmony export */   keccak256: () => (/* binding */ keccak256),\n/* harmony export */   keccak384: () => (/* binding */ keccak384),\n/* harmony export */   keccak512: () => (/* binding */ keccak512)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ethereum-cryptography/esm/utils.js\");\n\n\nconst keccak224 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapHash)(_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__.keccak_224);\nconst keccak256 = (()=>{\n    const k = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapHash)(_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__.keccak_256);\n    k.create = _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__.keccak_256.create;\n    return k;\n})();\nconst keccak384 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapHash)(_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__.keccak_384);\nconst keccak512 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapHash)(_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__.keccak_512);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2VzbS9rZWNjYWsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQW9GO0FBQzlDO0FBQy9CLE1BQU1LLFlBQVlELG1EQUFRQSxDQUFDSiwwREFBVUEsRUFBRTtBQUN2QyxNQUFNTSxZQUFZLENBQUM7SUFDdEIsTUFBTUMsSUFBSUgsbURBQVFBLENBQUNILDBEQUFVQTtJQUM3Qk0sRUFBRUMsTUFBTSxHQUFHUCwwREFBVUEsQ0FBQ08sTUFBTTtJQUM1QixPQUFPRDtBQUNYLEtBQUs7QUFDRSxNQUFNRSxZQUFZTCxtREFBUUEsQ0FBQ0YsMERBQVVBLEVBQUU7QUFDdkMsTUFBTVEsWUFBWU4sbURBQVFBLENBQUNELDBEQUFVQSxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9lc20va2VjY2FrLmpzP2UyM2EiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsga2VjY2FrXzIyNCwga2VjY2FrXzI1Niwga2VjY2FrXzM4NCwga2VjY2FrXzUxMiB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3NoYTNcIjtcbmltcG9ydCB7IHdyYXBIYXNoIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmV4cG9ydCBjb25zdCBrZWNjYWsyMjQgPSB3cmFwSGFzaChrZWNjYWtfMjI0KTtcbmV4cG9ydCBjb25zdCBrZWNjYWsyNTYgPSAoKCkgPT4ge1xuICAgIGNvbnN0IGsgPSB3cmFwSGFzaChrZWNjYWtfMjU2KTtcbiAgICBrLmNyZWF0ZSA9IGtlY2Nha18yNTYuY3JlYXRlO1xuICAgIHJldHVybiBrO1xufSkoKTtcbmV4cG9ydCBjb25zdCBrZWNjYWszODQgPSB3cmFwSGFzaChrZWNjYWtfMzg0KTtcbmV4cG9ydCBjb25zdCBrZWNjYWs1MTIgPSB3cmFwSGFzaChrZWNjYWtfNTEyKTtcbiJdLCJuYW1lcyI6WyJrZWNjYWtfMjI0Iiwia2VjY2FrXzI1NiIsImtlY2Nha18zODQiLCJrZWNjYWtfNTEyIiwid3JhcEhhc2giLCJrZWNjYWsyMjQiLCJrZWNjYWsyNTYiLCJrIiwiY3JlYXRlIiwia2VjY2FrMzg0Iiwia2VjY2FrNTEyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereum-cryptography/esm/keccak.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereum-cryptography/esm/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethereum-cryptography/esm/utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertBool: () => (/* binding */ assertBool),\n/* harmony export */   assertBytes: () => (/* binding */ assertBytes),\n/* harmony export */   bytesToHex: () => (/* reexport safe */ _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.bytesToHex),\n/* harmony export */   bytesToUtf8: () => (/* binding */ bytesToUtf8),\n/* harmony export */   concatBytes: () => (/* reexport safe */ _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes),\n/* harmony export */   createView: () => (/* reexport safe */ _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.createView),\n/* harmony export */   crypto: () => (/* binding */ crypto),\n/* harmony export */   equalsBytes: () => (/* binding */ equalsBytes),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   toHex: () => (/* reexport safe */ _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.bytesToHex),\n/* harmony export */   utf8ToBytes: () => (/* reexport safe */ _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.utf8ToBytes),\n/* harmony export */   wrapHash: () => (/* binding */ wrapHash)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/_assert */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/utils.js\");\n\n\nconst assertBool = _noble_hashes_assert__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bool;\nconst assertBytes = _noble_hashes_assert__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bytes;\n\n\n// buf.toString('utf8') -> bytesToUtf8(buf)\nfunction bytesToUtf8(data) {\n    if (!(data instanceof Uint8Array)) {\n        throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);\n    }\n    return new TextDecoder().decode(data);\n}\nfunction hexToBytes(data) {\n    const sliced = data.startsWith(\"0x\") ? data.substring(2) : data;\n    return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.hexToBytes)(sliced);\n}\n// buf.equals(buf2) -> equalsBytes(buf, buf2)\nfunction equalsBytes(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for(let i = 0; i < a.length; i++){\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n// Internal utils\nfunction wrapHash(hash) {\n    return (msg)=>{\n        _noble_hashes_assert__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bytes(msg);\n        return hash(msg);\n    };\n}\n// TODO(v3): switch away from node crypto, remove this unnecessary variable.\nconst crypto = (()=>{\n    const webCrypto = typeof globalThis === \"object\" && \"crypto\" in globalThis ? globalThis.crypto : undefined;\n    const nodeRequire = typeof module !== \"undefined\" && typeof module.require === \"function\" && module.require.bind(module);\n    return {\n        node: nodeRequire && !webCrypto ? nodeRequire(\"crypto\") : undefined,\n        web: webCrypto\n    };\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUEyQztBQUNxQjtBQUNoRSxNQUFNRyxhQUFhSCxpRUFBVztBQUM5QixNQUFNSyxjQUFjTCxrRUFBWTtBQUNHO0FBQ3lFO0FBQzVHLDJDQUEyQztBQUNwQyxTQUFTWSxZQUFZQyxJQUFJO0lBQzVCLElBQUksQ0FBRUEsQ0FBQUEsZ0JBQWdCQyxVQUFTLEdBQUk7UUFDL0IsTUFBTSxJQUFJQyxVQUFVLENBQUMscUNBQXFDLEVBQUUsT0FBT0YsS0FBSyxDQUFDO0lBQzdFO0lBQ0EsT0FBTyxJQUFJRyxjQUFjQyxNQUFNLENBQUNKO0FBQ3BDO0FBQ08sU0FBU1osV0FBV1ksSUFBSTtJQUMzQixNQUFNSyxTQUFTTCxLQUFLTSxVQUFVLENBQUMsUUFBUU4sS0FBS08sU0FBUyxDQUFDLEtBQUtQO0lBQzNELE9BQU9YLCtEQUFXQSxDQUFDZ0I7QUFDdkI7QUFDQSw2Q0FBNkM7QUFDdEMsU0FBU0csWUFBWUMsQ0FBQyxFQUFFQyxDQUFDO0lBQzVCLElBQUlELEVBQUVFLE1BQU0sS0FBS0QsRUFBRUMsTUFBTSxFQUFFO1FBQ3ZCLE9BQU87SUFDWDtJQUNBLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSCxFQUFFRSxNQUFNLEVBQUVDLElBQUs7UUFDL0IsSUFBSUgsQ0FBQyxDQUFDRyxFQUFFLEtBQUtGLENBQUMsQ0FBQ0UsRUFBRSxFQUFFO1lBQ2YsT0FBTztRQUNYO0lBQ0o7SUFDQSxPQUFPO0FBQ1g7QUFDQSxpQkFBaUI7QUFDVixTQUFTQyxTQUFTQyxJQUFJO0lBQ3pCLE9BQU8sQ0FBQ0M7UUFDSjVCLGtFQUFZLENBQUM0QjtRQUNiLE9BQU9ELEtBQUtDO0lBQ2hCO0FBQ0o7QUFDQSw0RUFBNEU7QUFDckUsTUFBTUMsU0FBUyxDQUFDO0lBQ25CLE1BQU1DLFlBQVksT0FBT0MsZUFBZSxZQUFZLFlBQVlBLGFBQWFBLFdBQVdGLE1BQU0sR0FBR0c7SUFDakcsTUFBTUMsY0FBYyxPQUFPQyxXQUFXLGVBQ2xDLE9BQU9BLE9BQU9DLE9BQU8sS0FBSyxjQUMxQkQsT0FBT0MsT0FBTyxDQUFDQyxJQUFJLENBQUNGO0lBQ3hCLE9BQU87UUFDSEcsTUFBTUosZUFBZSxDQUFDSCxZQUFZRyxZQUFZLFlBQVlEO1FBQzFETSxLQUFLUjtJQUNUO0FBQ0osS0FBSyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bS1jcnlwdG9ncmFwaHkvZXNtL3V0aWxzLmpzP2RmMWEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFzc2VydCBmcm9tIFwiQG5vYmxlL2hhc2hlcy9fYXNzZXJ0XCI7XG5pbXBvcnQgeyBoZXhUb0J5dGVzIGFzIF9oZXhUb0J5dGVzIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvdXRpbHNcIjtcbmNvbnN0IGFzc2VydEJvb2wgPSBhc3NlcnQuYm9vbDtcbmNvbnN0IGFzc2VydEJ5dGVzID0gYXNzZXJ0LmJ5dGVzO1xuZXhwb3J0IHsgYXNzZXJ0Qm9vbCwgYXNzZXJ0Qnl0ZXMgfTtcbmV4cG9ydCB7IGJ5dGVzVG9IZXgsIGJ5dGVzVG9IZXggYXMgdG9IZXgsIGNvbmNhdEJ5dGVzLCBjcmVhdGVWaWV3LCB1dGY4VG9CeXRlcyB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCI7XG4vLyBidWYudG9TdHJpbmcoJ3V0ZjgnKSAtPiBieXRlc1RvVXRmOChidWYpXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb1V0ZjgoZGF0YSkge1xuICAgIGlmICghKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBieXRlc1RvVXRmOCBleHBlY3RlZCBVaW50OEFycmF5LCBnb3QgJHt0eXBlb2YgZGF0YX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShkYXRhKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0J5dGVzKGRhdGEpIHtcbiAgICBjb25zdCBzbGljZWQgPSBkYXRhLnN0YXJ0c1dpdGgoXCIweFwiKSA/IGRhdGEuc3Vic3RyaW5nKDIpIDogZGF0YTtcbiAgICByZXR1cm4gX2hleFRvQnl0ZXMoc2xpY2VkKTtcbn1cbi8vIGJ1Zi5lcXVhbHMoYnVmMikgLT4gZXF1YWxzQnl0ZXMoYnVmLCBidWYyKVxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsc0J5dGVzKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBJbnRlcm5hbCB1dGlsc1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBIYXNoKGhhc2gpIHtcbiAgICByZXR1cm4gKG1zZykgPT4ge1xuICAgICAgICBhc3NlcnQuYnl0ZXMobXNnKTtcbiAgICAgICAgcmV0dXJuIGhhc2gobXNnKTtcbiAgICB9O1xufVxuLy8gVE9ETyh2Myk6IHN3aXRjaCBhd2F5IGZyb20gbm9kZSBjcnlwdG8sIHJlbW92ZSB0aGlzIHVubmVjZXNzYXJ5IHZhcmlhYmxlLlxuZXhwb3J0IGNvbnN0IGNyeXB0byA9ICgoKSA9PiB7XG4gICAgY29uc3Qgd2ViQ3J5cHRvID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09IFwib2JqZWN0XCIgJiYgXCJjcnlwdG9cIiBpbiBnbG9iYWxUaGlzID8gZ2xvYmFsVGhpcy5jcnlwdG8gOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgbm9kZVJlcXVpcmUgPSB0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIHR5cGVvZiBtb2R1bGUucmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIG1vZHVsZS5yZXF1aXJlLmJpbmQobW9kdWxlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBub2RlOiBub2RlUmVxdWlyZSAmJiAhd2ViQ3J5cHRvID8gbm9kZVJlcXVpcmUoXCJjcnlwdG9cIikgOiB1bmRlZmluZWQsXG4gICAgICAgIHdlYjogd2ViQ3J5cHRvXG4gICAgfTtcbn0pKCk7XG4iXSwibmFtZXMiOlsiYXNzZXJ0IiwiaGV4VG9CeXRlcyIsIl9oZXhUb0J5dGVzIiwiYXNzZXJ0Qm9vbCIsImJvb2wiLCJhc3NlcnRCeXRlcyIsImJ5dGVzIiwiYnl0ZXNUb0hleCIsInRvSGV4IiwiY29uY2F0Qnl0ZXMiLCJjcmVhdGVWaWV3IiwidXRmOFRvQnl0ZXMiLCJieXRlc1RvVXRmOCIsImRhdGEiLCJVaW50OEFycmF5IiwiVHlwZUVycm9yIiwiVGV4dERlY29kZXIiLCJkZWNvZGUiLCJzbGljZWQiLCJzdGFydHNXaXRoIiwic3Vic3RyaW5nIiwiZXF1YWxzQnl0ZXMiLCJhIiwiYiIsImxlbmd0aCIsImkiLCJ3cmFwSGFzaCIsImhhc2giLCJtc2ciLCJjcnlwdG8iLCJ3ZWJDcnlwdG8iLCJnbG9iYWxUaGlzIiwidW5kZWZpbmVkIiwibm9kZVJlcXVpcmUiLCJtb2R1bGUiLCJyZXF1aXJlIiwiYmluZCIsIm5vZGUiLCJ3ZWIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereum-cryptography/esm/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/_assert.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/_assert.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== \"boolean\") throw new Error(`Expected boolean, not ${b}`);\n}\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array)) throw new Error(\"Expected Uint8Array\");\n    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== \"function\" || typeof hash.create !== \"function\") throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed) throw new Error(\"Hash instance has been destroyed\");\n    if (checkFinished && instance.finished) throw new Error(\"Hash#digest() has already been called\");\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nconst assert = {\n    number,\n    bool,\n    bytes,\n    hash,\n    exists,\n    output\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert); //# sourceMappingURL=_assert.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBTyxTQUFTQSxPQUFPQyxDQUFDO0lBQ3BCLElBQUksQ0FBQ0MsT0FBT0MsYUFBYSxDQUFDRixNQUFNQSxJQUFJLEdBQ2hDLE1BQU0sSUFBSUcsTUFBTSxDQUFDLHdCQUF3QixFQUFFSCxFQUFFLENBQUM7QUFDdEQ7QUFDTyxTQUFTSSxLQUFLQyxDQUFDO0lBQ2xCLElBQUksT0FBT0EsTUFBTSxXQUNiLE1BQU0sSUFBSUYsTUFBTSxDQUFDLHNCQUFzQixFQUFFRSxFQUFFLENBQUM7QUFDcEQ7QUFDTyxTQUFTQyxNQUFNRCxDQUFDLEVBQUUsR0FBR0UsT0FBTztJQUMvQixJQUFJLENBQUVGLENBQUFBLGFBQWFHLFVBQVMsR0FDeEIsTUFBTSxJQUFJTCxNQUFNO0lBQ3BCLElBQUlJLFFBQVFFLE1BQU0sR0FBRyxLQUFLLENBQUNGLFFBQVFHLFFBQVEsQ0FBQ0wsRUFBRUksTUFBTSxHQUNoRCxNQUFNLElBQUlOLE1BQU0sQ0FBQyw4QkFBOEIsRUFBRUksUUFBUSxnQkFBZ0IsRUFBRUYsRUFBRUksTUFBTSxDQUFDLENBQUM7QUFDN0Y7QUFDTyxTQUFTRSxLQUFLQSxJQUFJO0lBQ3JCLElBQUksT0FBT0EsU0FBUyxjQUFjLE9BQU9BLEtBQUtDLE1BQU0sS0FBSyxZQUNyRCxNQUFNLElBQUlULE1BQU07SUFDcEJKLE9BQU9ZLEtBQUtFLFNBQVM7SUFDckJkLE9BQU9ZLEtBQUtHLFFBQVE7QUFDeEI7QUFDTyxTQUFTQyxPQUFPQyxRQUFRLEVBQUVDLGdCQUFnQixJQUFJO0lBQ2pELElBQUlELFNBQVNFLFNBQVMsRUFDbEIsTUFBTSxJQUFJZixNQUFNO0lBQ3BCLElBQUljLGlCQUFpQkQsU0FBU0csUUFBUSxFQUNsQyxNQUFNLElBQUloQixNQUFNO0FBQ3hCO0FBQ08sU0FBU2lCLE9BQU9DLEdBQUcsRUFBRUwsUUFBUTtJQUNoQ1YsTUFBTWU7SUFDTixNQUFNQyxNQUFNTixTQUFTSCxTQUFTO0lBQzlCLElBQUlRLElBQUlaLE1BQU0sR0FBR2EsS0FBSztRQUNsQixNQUFNLElBQUluQixNQUFNLENBQUMsc0RBQXNELEVBQUVtQixJQUFJLENBQUM7SUFDbEY7QUFDSjtBQUNBLE1BQU1DLFNBQVM7SUFDWHhCO0lBQ0FLO0lBQ0FFO0lBQ0FLO0lBQ0FJO0lBQ0FLO0FBQ0o7QUFDQSxpRUFBZUcsTUFBTUEsRUFBQyxDQUN0QixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzP2YwNzciXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIG51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBwb3NpdGl2ZSBpbnRlZ2VyOiAke259YCk7XG59XG5leHBvcnQgZnVuY3Rpb24gYm9vbChiKSB7XG4gICAgaWYgKHR5cGVvZiBiICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiwgbm90ICR7Yn1gKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBieXRlcyhiLCAuLi5sZW5ndGhzKSB7XG4gICAgaWYgKCEoYiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFVpbnQ4QXJyYXknKTtcbiAgICBpZiAobGVuZ3Rocy5sZW5ndGggPiAwICYmICFsZW5ndGhzLmluY2x1ZGVzKGIubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBVaW50OEFycmF5IG9mIGxlbmd0aCAke2xlbmd0aHN9LCBub3Qgb2YgbGVuZ3RoPSR7Yi5sZW5ndGh9YCk7XG59XG5leHBvcnQgZnVuY3Rpb24gaGFzaChoYXNoKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoYXNoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvcicpO1xuICAgIG51bWJlcihoYXNoLm91dHB1dExlbik7XG4gICAgbnVtYmVyKGhhc2guYmxvY2tMZW4pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG91dHB1dChvdXQsIGluc3RhbmNlKSB7XG4gICAgYnl0ZXMob3V0KTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAke21pbn1gKTtcbiAgICB9XG59XG5jb25zdCBhc3NlcnQgPSB7XG4gICAgbnVtYmVyLFxuICAgIGJvb2wsXG4gICAgYnl0ZXMsXG4gICAgaGFzaCxcbiAgICBleGlzdHMsXG4gICAgb3V0cHV0LFxufTtcbmV4cG9ydCBkZWZhdWx0IGFzc2VydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9hc3NlcnQuanMubWFwIl0sIm5hbWVzIjpbIm51bWJlciIsIm4iLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwiRXJyb3IiLCJib29sIiwiYiIsImJ5dGVzIiwibGVuZ3RocyIsIlVpbnQ4QXJyYXkiLCJsZW5ndGgiLCJpbmNsdWRlcyIsImhhc2giLCJjcmVhdGUiLCJvdXRwdXRMZW4iLCJibG9ja0xlbiIsImV4aXN0cyIsImluc3RhbmNlIiwiY2hlY2tGaW5pc2hlZCIsImRlc3Ryb3llZCIsImZpbmlzaGVkIiwib3V0cHV0Iiwib3V0IiwibWluIiwiYXNzZXJ0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/_assert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/_u64.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/_u64.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fromBig: () => (/* binding */ fromBig),\n/* harmony export */   split: () => (/* binding */ split),\n/* harmony export */   toBig: () => (/* binding */ toBig)\n/* harmony export */ });\nconst U32_MASK64 = BigInt(2 ** 32 - 1);\nconst _32n = BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le) return {\n        h: Number(n & U32_MASK64),\n        l: Number(n >> _32n & U32_MASK64)\n    };\n    return {\n        h: Number(n >> _32n & U32_MASK64) | 0,\n        l: Number(n & U32_MASK64) | 0\n    };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for(let i = 0; i < lst.length; i++){\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [\n            h,\n            l\n        ];\n    }\n    return [\n        Ah,\n        Al\n    ];\n}\nconst toBig = (h, l)=>BigInt(h >>> 0) << _32n | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, l, s)=>h >>> s;\nconst shrSL = (h, l, s)=>h << 32 - s | l >>> s;\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s)=>h >>> s | l << 32 - s;\nconst rotrSL = (h, l, s)=>h << 32 - s | l >>> s;\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s)=>h << 64 - s | l >>> s - 32;\nconst rotrBL = (h, l, s)=>h >>> s - 32 | l << 64 - s;\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (h, l)=>l;\nconst rotr32L = (h, l)=>h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s)=>h << s | l >>> 32 - s;\nconst rotlSL = (h, l, s)=>l << s | h >>> 32 - s;\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s)=>l << s - 32 | h >>> 64 - s;\nconst rotlBL = (h, l, s)=>h << s - 32 | l >>> 64 - s;\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\n// Removing \"export\" has 5% perf penalty -_-\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return {\n        h: Ah + Bh + (l / 2 ** 32 | 0) | 0,\n        l: l | 0\n    };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch)=>Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;\nconst add4L = (Al, Bl, Cl, Dl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh)=>Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh)=>Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;\n// prettier-ignore\nconst u64 = {\n    fromBig,\n    split,\n    toBig,\n    shrSH,\n    shrSL,\n    rotrSH,\n    rotrSL,\n    rotrBH,\n    rotrBL,\n    rotr32H,\n    rotr32L,\n    rotlSH,\n    rotlSL,\n    rotlBH,\n    rotlBL,\n    add,\n    add3L,\n    add3H,\n    add4L,\n    add4H,\n    add5H,\n    add5L\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (u64); //# sourceMappingURL=_u64.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fdTY0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsTUFBTUEsYUFBYUMsT0FBTyxLQUFLLEtBQUs7QUFDcEMsTUFBTUMsT0FBT0QsT0FBTztBQUNwQiwrRUFBK0U7QUFDeEUsU0FBU0UsUUFBUUMsQ0FBQyxFQUFFQyxLQUFLLEtBQUs7SUFDakMsSUFBSUEsSUFDQSxPQUFPO1FBQUVDLEdBQUdDLE9BQU9ILElBQUlKO1FBQWFRLEdBQUdELE9BQU8sS0FBTUwsT0FBUUY7SUFBWTtJQUM1RSxPQUFPO1FBQUVNLEdBQUdDLE9BQU8sS0FBTUwsT0FBUUYsY0FBYztRQUFHUSxHQUFHRCxPQUFPSCxJQUFJSixjQUFjO0lBQUU7QUFDcEY7QUFDTyxTQUFTUyxNQUFNQyxHQUFHLEVBQUVMLEtBQUssS0FBSztJQUNqQyxJQUFJTSxLQUFLLElBQUlDLFlBQVlGLElBQUlHLE1BQU07SUFDbkMsSUFBSUMsS0FBSyxJQUFJRixZQUFZRixJQUFJRyxNQUFNO0lBQ25DLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJTCxJQUFJRyxNQUFNLEVBQUVFLElBQUs7UUFDakMsTUFBTSxFQUFFVCxDQUFDLEVBQUVFLENBQUMsRUFBRSxHQUFHTCxRQUFRTyxHQUFHLENBQUNLLEVBQUUsRUFBRVY7UUFDakMsQ0FBQ00sRUFBRSxDQUFDSSxFQUFFLEVBQUVELEVBQUUsQ0FBQ0MsRUFBRSxDQUFDLEdBQUc7WUFBQ1Q7WUFBR0U7U0FBRTtJQUMzQjtJQUNBLE9BQU87UUFBQ0c7UUFBSUc7S0FBRztBQUNuQjtBQUNPLE1BQU1FLFFBQVEsQ0FBQ1YsR0FBR0UsSUFBTSxPQUFRRixNQUFNLE1BQU1KLE9BQVFELE9BQU9PLE1BQU0sR0FBRztBQUMzRSx1QkFBdUI7QUFDdkIsTUFBTVMsUUFBUSxDQUFDWCxHQUFHRSxHQUFHVSxJQUFNWixNQUFNWTtBQUNqQyxNQUFN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c291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3U2NC5qcz85YzE3Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFUzMl9NQVNLNjQgPSBCaWdJbnQoMiAqKiAzMiAtIDEpO1xuY29uc3QgXzMybiA9IEJpZ0ludCgzMik7XG4vLyBXZSBhcmUgbm90IHVzaW5nIEJpZ1VpbnQ2NEFycmF5LCBiZWNhdXNlIHRoZXkgYXJlIGV4dHJlbWVseSBzbG93IGFzIHBlciAyMDIyXG5leHBvcnQgZnVuY3Rpb24gZnJvbUJpZyhuLCBsZSA9IGZhbHNlKSB7XG4gICAgaWYgKGxlKVxuICAgICAgICByZXR1cm4geyBoOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpLCBsOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB9O1xuICAgIHJldHVybiB7IGg6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIHwgMCwgbDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSB8IDAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdChsc3QsIGxlID0gZmFsc2UpIHtcbiAgICBsZXQgQWggPSBuZXcgVWludDMyQXJyYXkobHN0Lmxlbmd0aCk7XG4gICAgbGV0IEFsID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbHN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHsgaCwgbCB9ID0gZnJvbUJpZyhsc3RbaV0sIGxlKTtcbiAgICAgICAgW0FoW2ldLCBBbFtpXV0gPSBbaCwgbF07XG4gICAgfVxuICAgIHJldHVybiBbQWgsIEFsXTtcbn1cbmV4cG9ydCBjb25zdCB0b0JpZyA9IChoLCBsKSA9PiAoQmlnSW50KGggPj4+IDApIDw8IF8zMm4pIHwgQmlnSW50KGwgPj4+IDApO1xuLy8gZm9yIFNoaWZ0IGluIFswLCAzMilcbmNvbnN0IHNoclNIID0gKGgsIGwsIHMpID0+IGggPj4+IHM7XG5jb25zdCBzaHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdHJTSCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gcykgfCAobCA8PCAoMzIgLSBzKSk7XG5jb25zdCByb3RyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90ckJIID0gKGgsIGwsIHMpID0+IChoIDw8ICg2NCAtIHMpKSB8IChsID4+PiAocyAtIDMyKSk7XG5jb25zdCByb3RyQkwgPSAoaCwgbCwgcykgPT4gKGggPj4+IChzIC0gMzIpKSB8IChsIDw8ICg2NCAtIHMpKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3Igc2hpZnQ9PT0zMiAoanVzdCBzd2FwcyBsJmgpXG5jb25zdCByb3RyMzJIID0gKGgsIGwpID0+IGw7XG5jb25zdCByb3RyMzJMID0gKGgsIGwpID0+IGg7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90bFNIID0gKGgsIGwsIHMpID0+IChoIDw8IHMpIHwgKGwgPj4+ICgzMiAtIHMpKTtcbmNvbnN0IHJvdGxTTCA9IChoLCBsLCBzKSA9PiAobCA8PCBzKSB8IChoID4+PiAoMzIgLSBzKSk7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdGxCSCA9IChoLCBsLCBzKSA9PiAobCA8PCAocyAtIDMyKSkgfCAoaCA+Pj4gKDY0IC0gcykpO1xuY29uc3Qgcm90bEJMID0gKGgsIGwsIHMpID0+IChoIDw8IChzIC0gMzIpKSB8IChsID4+PiAoNjQgLSBzKSk7XG4vLyBKUyB1c2VzIDMyLWJpdCBzaWduZWQgaW50ZWdlcnMgZm9yIGJpdHdpc2Ugb3BlcmF0aW9ucyB3aGljaCBtZWFucyB3ZSBjYW5ub3Rcbi8vIHNpbXBsZSB0YWtlIGNhcnJ5IG91dCBvZiBsb3cgYml0IHN1bSBieSBzaGlmdCwgd2UgbmVlZCB0byB1c2UgZGl2aXNpb24uXG4vLyBSZW1vdmluZyBcImV4cG9ydFwiIGhhcyA1JSBwZXJmIHBlbmFsdHkgLV8tXG5leHBvcnQgZnVuY3Rpb24gYWRkKEFoLCBBbCwgQmgsIEJsKSB7XG4gICAgY29uc3QgbCA9IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApO1xuICAgIHJldHVybiB7IGg6IChBaCArIEJoICsgKChsIC8gMiAqKiAzMikgfCAwKSkgfCAwLCBsOiBsIHwgMCB9O1xufVxuLy8gQWRkaXRpb24gd2l0aCBtb3JlIHRoYW4gMiBlbGVtZW50c1xuY29uc3QgYWRkM0wgPSAoQWwsIEJsLCBDbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApO1xuY29uc3QgYWRkM0ggPSAobG93LCBBaCwgQmgsIENoKSA9PiAoQWggKyBCaCArIENoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ0TCA9IChBbCwgQmwsIENsLCBEbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKTtcbmNvbnN0IGFkZDRIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuY29uc3QgYWRkNUwgPSAoQWwsIEJsLCBDbCwgRGwsIEVsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApICsgKEVsID4+PiAwKTtcbmNvbnN0IGFkZDVIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgsIEVoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyBFaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB1NjQgPSB7XG4gICAgZnJvbUJpZywgc3BsaXQsIHRvQmlnLFxuICAgIHNoclNILCBzaHJTTCxcbiAgICByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsXG4gICAgcm90cjMySCwgcm90cjMyTCxcbiAgICByb3RsU0gsIHJvdGxTTCwgcm90bEJILCByb3RsQkwsXG4gICAgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLFxufTtcbmV4cG9ydCBkZWZhdWx0IHU2NDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV91NjQuanMubWFwIl0sIm5hbWVzIjpbIlUzMl9NQVNLNjQiLCJCaWdJbnQiLCJfMzJuIiwiZnJvbUJpZyIsIm4iLCJsZSIsImgiLCJOdW1iZXIiLCJsIiwic3BsaXQiLCJsc3QiLCJBaCIsIlVpbnQzMkFycmF5IiwibGVuZ3RoIiwiQWwiLCJpIiwidG9CaWciLCJzaHJTSCIsInMiLCJzaHJTTCIsInJvdHJTSCIsInJvdHJTTCIsInJvdHJCSCIsInJvdHJCTCIsInJvdHIzMkgiLCJyb3RyMzJMIiwicm90bFNIIiwicm90bFNMIiwicm90bEJIIiwicm90bEJMIiwiYWRkIiwiQmgiLCJCbCIsImFkZDNMIiwiQ2wiLCJhZGQzSCIsImxvdyIsIkNoIiwiYWRkNEwiLCJEbCIsImFkZDRIIiwiRGgiLCJhZGQ1TCIsIkVsIiwiYWRkNUgiLCJFaCIsInU2NCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/_u64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/cryptoNode.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/cryptoNode.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\n// The file will throw on node.js 14 and earlier.\n// @ts-ignore\n\nconst crypto = /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) && typeof /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) === \"object\" && \"webcrypto\" in /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) ? node_crypto__WEBPACK_IMPORTED_MODULE_0__.webcrypto : undefined; //# sourceMappingURL=cryptoNode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG9Ob2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLG9GQUFvRjtBQUNwRiw0QkFBNEI7QUFDNUIsaURBQWlEO0FBQ2pELGFBQWE7QUFDcUI7QUFDM0IsTUFBTUMsU0FBU0QsMk1BQUVBLElBQUksT0FBT0EsMk1BQUVBLEtBQUssWUFBWSwwTkFBaUJBLEdBQUdBLGtEQUFZLEdBQUdHLFVBQVUsQ0FDbkcsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vY3J5cHRvTm9kZS5qcz8wM2ExIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gU2VlIHV0aWxzLnRzIGZvciBkZXRhaWxzLlxuLy8gVGhlIGZpbGUgd2lsbCB0aHJvdyBvbiBub2RlLmpzIDE0IGFuZCBlYXJsaWVyLlxuLy8gQHRzLWlnbm9yZVxuaW1wb3J0ICogYXMgbmMgZnJvbSAnbm9kZTpjcnlwdG8nO1xuZXhwb3J0IGNvbnN0IGNyeXB0byA9IG5jICYmIHR5cGVvZiBuYyA9PT0gJ29iamVjdCcgJiYgJ3dlYmNyeXB0bycgaW4gbmMgPyBuYy53ZWJjcnlwdG8gOiB1bmRlZmluZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG9Ob2RlLmpzLm1hcCJdLCJuYW1lcyI6WyJuYyIsImNyeXB0byIsIndlYmNyeXB0byIsInVuZGVmaW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/cryptoNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/sha3.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/sha3.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Keccak: () => (/* binding */ Keccak),\n/* harmony export */   keccakP: () => (/* binding */ keccakP),\n/* harmony export */   keccak_224: () => (/* binding */ keccak_224),\n/* harmony export */   keccak_256: () => (/* binding */ keccak_256),\n/* harmony export */   keccak_384: () => (/* binding */ keccak_384),\n/* harmony export */   keccak_512: () => (/* binding */ keccak_512),\n/* harmony export */   sha3_224: () => (/* binding */ sha3_224),\n/* harmony export */   sha3_256: () => (/* binding */ sha3_256),\n/* harmony export */   sha3_384: () => (/* binding */ sha3_384),\n/* harmony export */   sha3_512: () => (/* binding */ sha3_512),\n/* harmony export */   shake128: () => (/* binding */ shake128),\n/* harmony export */   shake256: () => (/* binding */ shake256)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_u64.js */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// Various per round constants calculations\nconst [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [\n    [],\n    [],\n    []\n];\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _7n = BigInt(7);\nconst _256n = BigInt(256);\nconst _0x71n = BigInt(0x71);\nfor(let round = 0, R = _1n, x = 1, y = 0; round < 24; round++){\n    // Pi\n    [x, y] = [\n        y,\n        (2 * x + 3 * y) % 5\n    ];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);\n    // Iota\n    let t = _0n;\n    for(let j = 0; j < 7; j++){\n        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;\n        if (R & _2n) t ^= _1n << (_1n << BigInt(j)) - _1n;\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].split(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s)=>s > 32 ? _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotlBH(h, l, s) : _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotlSH(h, l, s);\nconst rotlL = (h, l, s)=>s > 32 ? _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotlBL(h, l, s) : _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotlSL(h, l, s);\n// Same as keccakf1600, but allows to skip some rounds\nfunction keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for(let round = 24 - rounds; round < 24; round++){\n        // Theta Œ∏\n        for(let x = 0; x < 10; x++)B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for(let x = 0; x < 10; x += 2){\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for(let y = 0; y < 50; y += 10){\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho (œÅ) and Pi (œÄ)\n        let curH = s[2];\n        let curL = s[3];\n        for(let t = 0; t < 24; t++){\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi (œá)\n        for(let y = 0; y < 50; y += 10){\n            for(let x = 0; x < 10; x++)B[x] = s[y + x];\n            for(let x = 0; x < 10; x++)s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota (Œπ)\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nclass Keccak extends _utils_js__WEBPACK_IMPORTED_MODULE_2__.Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24){\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].number(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200) throw new Error(\"Sha3 supports only keccak-f1600 function\");\n        this.state = new Uint8Array(200);\n        this.state32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.u32)(this.state);\n    }\n    keccak() {\n        keccakP(this.state32, this.rounds);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n        const { blockLen, state } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.toBytes)(data);\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for(let i = 0; i < take; i++)state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen) this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished) return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this, false);\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bytes(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for(let pos = 0, len = out.length; pos < len;){\n            if (this.posOut >= blockLen) this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF) throw new Error(\"XOF is not possible for this instance\");\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].number(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].output(out, this);\n        if (this.finished) throw new Error(\"digest() was already called\");\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen)=>(0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(()=>new Keccak(blockLen, suffix, outputLen));\nconst sha3_224 = gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */ const sha3_256 = gen(0x06, 136, 256 / 8);\nconst sha3_384 = gen(0x06, 104, 384 / 8);\nconst sha3_512 = gen(0x06, 72, 512 / 8);\nconst keccak_224 = gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */ const keccak_256 = gen(0x01, 136, 256 / 8);\nconst keccak_384 = gen(0x01, 104, 384 / 8);\nconst keccak_512 = gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen)=>(0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapXOFConstructorWithOpts)((opts = {})=>new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\nconst shake128 = genShake(0x1f, 168, 128 / 8);\nconst shake256 = genShake(0x1f, 136, 256 / 8); //# sourceMappingURL=sha3.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFrQztBQUNOO0FBQ2tFO0FBQzlGLDJDQUEyQztBQUMzQyxNQUFNLENBQUNPLFNBQVNDLFdBQVdDLFdBQVcsR0FBRztJQUFDLEVBQUU7SUFBRSxFQUFFO0lBQUUsRUFBRTtDQUFDO0FBQ3JELE1BQU1DLE1BQU1DLE9BQU87QUFDbkIsTUFBTUMsTUFBTUQsT0FBTztBQUNuQixNQUFNRSxNQUFNRixPQUFPO0FBQ25CLE1BQU1HLE1BQU1ILE9BQU87QUFDbkIsTUFBTUksUUFBUUosT0FBTztBQUNyQixNQUFNSyxTQUFTTCxPQUFPO0FBQ3RCLElBQUssSUFBSU0sUUFBUSxHQUFHQyxJQUFJTixLQUFLTyxJQUFJLEdBQUdDLElBQUksR0FBR0gsUUFBUSxJQUFJQSxRQUFTO0lBQzVELEtBQUs7SUFDTCxDQUFDRSxHQUFHQyxFQUFFLEdBQUc7UUFBQ0E7UUFBSSxLQUFJRCxJQUFJLElBQUlDLENBQUFBLElBQUs7S0FBRTtJQUNqQ2IsUUFBUWMsSUFBSSxDQUFDLElBQUssS0FBSUQsSUFBSUQsQ0FBQUE7SUFDMUIsYUFBYTtJQUNiWCxVQUFVYSxJQUFJLENBQUMsQ0FBR0osUUFBUSxLQUFNQSxDQUFBQSxRQUFRLEtBQU0sSUFBSztJQUNuRCxPQUFPO0lBQ1AsSUFBSUssSUFBSVo7SUFDUixJQUFLLElBQUlhLElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFLO1FBQ3hCTCxJQUFJLENBQUMsS0FBTU4sTUFBUSxDQUFDTSxLQUFLSixHQUFFLElBQUtFLE1BQU0sSUFBS0Q7UUFDM0MsSUFBSUcsSUFBSUwsS0FDSlMsS0FBS1YsT0FBUSxDQUFDQSxPQUFPRCxPQUFPWSxFQUFDLElBQUtYO0lBQzFDO0lBQ0FILFdBQVdZLElBQUksQ0FBQ0M7QUFDcEI7QUFDQSxNQUFNLENBQUNF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SSxNQUFNLEtBQUssTUFBTSxHQUFHO0FBQzNDLE1BQU1RLGFBQWFSLElBQUksTUFBTSxJQUFJLE1BQU0sR0FBRztBQUNqRCxNQUFNUyxXQUFXLENBQUM5QyxRQUFRRCxVQUFVRSxZQUFjakQscUVBQTBCQSxDQUFDLENBQUMrRixPQUFPLENBQUMsQ0FBQyxHQUFLLElBQUlsRCxPQUFPRSxVQUFVQyxRQUFRK0MsS0FBS0MsS0FBSyxLQUFLQyxZQUFZaEQsWUFBWThDLEtBQUtDLEtBQUssRUFBRTtBQUNySyxNQUFNRSxXQUFXSixTQUFTLE1BQU0sS0FBSyxNQUFNLEdBQUc7QUFDOUMsTUFBTUssV0FBV0wsU0FBUyxNQUFNLEtBQUssTUFBTSxHQUFHLENBQ3JELGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bS1jcnlwdG9ncmFwaHkvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTMuanM/NDk2OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXNzZXJ0IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgdTY0IGZyb20gJy4vX3U2NC5qcyc7XG5pbXBvcnQgeyBIYXNoLCB1MzIsIHRvQnl0ZXMsIHdyYXBDb25zdHJ1Y3Rvciwgd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMsIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBWYXJpb3VzIHBlciByb3VuZCBjb25zdGFudHMgY2FsY3VsYXRpb25zXG5jb25zdCBbU0hBM19QSSwgU0hBM19ST1RMLCBfU0hBM19JT1RBXSA9IFtbXSwgW10sIFtdXTtcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IF83biA9IEJpZ0ludCg3KTtcbmNvbnN0IF8yNTZuID0gQmlnSW50KDI1Nik7XG5jb25zdCBfMHg3MW4gPSBCaWdJbnQoMHg3MSk7XG5mb3IgKGxldCByb3VuZCA9IDAsIFIgPSBfMW4sIHggPSAxLCB5ID0gMDsgcm91bmQgPCAyNDsgcm91bmQrKykge1xuICAgIC8vIFBpXG4gICAgW3gsIHldID0gW3ksICgyICogeCArIDMgKiB5KSAlIDVdO1xuICAgIFNIQTNfUEkucHVzaCgyICogKDUgKiB5ICsgeCkpO1xuICAgIC8vIFJvdGF0aW9uYWxcbiAgICBTSEEzX1JPVEwucHVzaCgoKChyb3VuZCArIDEpICogKHJvdW5kICsgMikpIC8gMikgJSA2NCk7XG4gICAgLy8gSW90YVxuICAgIGxldCB0ID0gXzBuO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgNzsgaisrKSB7XG4gICAgICAgIFIgPSAoKFIgPDwgXzFuKSBeICgoUiA+PiBfN24pICogXzB4NzFuKSkgJSBfMjU2bjtcbiAgICAgICAgaWYgKFIgJiBfMm4pXG4gICAgICAgICAgICB0IF49IF8xbiA8PCAoKF8xbiA8PCBCaWdJbnQoaikpIC0gXzFuKTtcbiAgICB9XG4gICAgX1NIQTNfSU9UQS5wdXNoKHQpO1xufVxuY29uc3QgW1NIQTNfSU9UQV9ILCBTSEEzX0lPVEFfTF0gPSB1NjQuc3BsaXQoX1NIQTNfSU9UQSwgdHJ1ZSk7XG4vLyBMZWZ0IHJvdGF0aW9uICh3aXRob3V0IDAsIDMyLCA2NClcbmNvbnN0IHJvdGxIID0gKGgsIGwsIHMpID0+IHMgPiAzMiA/IHU2NC5yb3RsQkgoaCwgbCwgcykgOiB1NjQucm90bFNIKGgsIGwsIHMpO1xuY29uc3Qgcm90bEwgPSAoaCwgbCwgcykgPT4gcyA+IDMyID8gdTY0LnJvdGxCTChoLCBsLCBzKSA6IHU2NC5yb3RsU0woaCwgbCwgcyk7XG4vLyBTYW1lIGFzIGtlY2Nha2YxNjAwLCBidXQgYWxsb3dzIHRvIHNraXAgc29tZSByb3VuZHNcbmV4cG9ydCBmdW5jdGlvbiBrZWNjYWtQKHMsIHJvdW5kcyA9IDI0KSB7XG4gICAgY29uc3QgQiA9IG5ldyBVaW50MzJBcnJheSg1ICogMik7XG4gICAgLy8gTk9URTogYWxsIGluZGljZXMgYXJlIHgyIHNpbmNlIHdlIHN0b3JlIHN0YXRlIGFzIHUzMiBpbnN0ZWFkIG9mIHU2NCAoYmlnaW50cyB0byBzbG93IGluIGpzKVxuICAgIGZvciAobGV0IHJvdW5kID0gMjQgLSByb3VuZHM7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcbiAgICAgICAgLy8gVGhldGEgzrhcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgQlt4XSA9IHNbeF0gXiBzW3ggKyAxMF0gXiBzW3ggKyAyMF0gXiBzW3ggKyAzMF0gXiBzW3ggKyA0MF07XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHggKz0gMikge1xuICAgICAgICAgICAgY29uc3QgaWR4MSA9ICh4ICsgOCkgJSAxMDtcbiAgICAgICAgICAgIGNvbnN0IGlkeDAgPSAoeCArIDIpICUgMTA7XG4gICAgICAgICAgICBjb25zdCBCMCA9IEJbaWR4MF07XG4gICAgICAgICAgICBjb25zdCBCMSA9IEJbaWR4MCArIDFdO1xuICAgICAgICAgICAgY29uc3QgVGggPSByb3RsSChCMCwgQjEsIDEpIF4gQltpZHgxXTtcbiAgICAgICAgICAgIGNvbnN0IFRsID0gcm90bEwoQjAsIEIxLCAxKSBeIEJbaWR4MSArIDFdO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA1MDsgeSArPSAxMCkge1xuICAgICAgICAgICAgICAgIHNbeCArIHldIF49IFRoO1xuICAgICAgICAgICAgICAgIHNbeCArIHkgKyAxXSBePSBUbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSaG8gKM+BKSBhbmQgUGkgKM+AKVxuICAgICAgICBsZXQgY3VySCA9IHNbMl07XG4gICAgICAgIGxldCBjdXJMID0gc1szXTtcbiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCAyNDsgdCsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaGlmdCA9IFNIQTNfUk9UTFt0XTtcbiAgICAgICAgICAgIGNvbnN0IFRoID0gcm90bEgoY3VySCwgY3VyTCwgc2hpZnQpO1xuICAgICAgICAgICAgY29uc3QgVGwgPSByb3RsTChjdXJILCBjdXJMLCBzaGlmdCk7XG4gICAgICAgICAgICBjb25zdCBQSSA9IFNIQTNfUElbdF07XG4gICAgICAgICAgICBjdXJIID0gc1tQSV07XG4gICAgICAgICAgICBjdXJMID0gc1tQSSArIDFdO1xuICAgICAgICAgICAgc1tQSV0gPSBUaDtcbiAgICAgICAgICAgIHNbUEkgKyAxXSA9IFRsO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoaSAoz4cpXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgICAgICBCW3hdID0gc1t5ICsgeF07XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICAgICAgc1t5ICsgeF0gXj0gfkJbKHggKyAyKSAlIDEwXSAmIEJbKHggKyA0KSAlIDEwXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJb3RhICjOuSlcbiAgICAgICAgc1swXSBePSBTSEEzX0lPVEFfSFtyb3VuZF07XG4gICAgICAgIHNbMV0gXj0gU0hBM19JT1RBX0xbcm91bmRdO1xuICAgIH1cbiAgICBCLmZpbGwoMCk7XG59XG5leHBvcnQgY2xhc3MgS2VjY2FrIGV4dGVuZHMgSGFzaCB7XG4gICAgLy8gTk9URTogd2UgYWNjZXB0IGFyZ3VtZW50cyBpbiBieXRlcyBpbnN0ZWFkIG9mIGJpdHMgaGVyZS5cbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiA9IGZhbHNlLCByb3VuZHMgPSAyNCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMuc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XG4gICAgICAgIHRoaXMucm91bmRzID0gcm91bmRzO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICAvLyBDYW4gYmUgcGFzc2VkIGZyb20gdXNlciBhcyBka0xlblxuICAgICAgICBhc3NlcnQubnVtYmVyKG91dHB1dExlbik7XG4gICAgICAgIC8vIDE2MDAgPSA1eDUgbWF0cml4IG9mIDY0Yml0LiAgMTYwMCBiaXRzID09PSAyMDAgYnl0ZXNcbiAgICAgICAgaWYgKDAgPj0gdGhpcy5ibG9ja0xlbiB8fCB0aGlzLmJsb2NrTGVuID49IDIwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2hhMyBzdXBwb3J0cyBvbmx5IGtlY2Nhay1mMTYwMCBmdW5jdGlvbicpO1xuICAgICAgICB0aGlzLnN0YXRlID0gbmV3IFVpbnQ4QXJyYXkoMjAwKTtcbiAgICAgICAgdGhpcy5zdGF0ZTMyID0gdTMyKHRoaXMuc3RhdGUpO1xuICAgIH1cbiAgICBrZWNjYWsoKSB7XG4gICAgICAgIGtlY2Nha1AodGhpcy5zdGF0ZTMyLCB0aGlzLnJvdW5kcyk7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBhc3NlcnQuZXhpc3RzKHRoaXMpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBzdGF0ZSB9ID0gdGhpcztcbiAgICAgICAgZGF0YSA9IHRvQnl0ZXMoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFrZTsgaSsrKVxuICAgICAgICAgICAgICAgIHN0YXRlW3RoaXMucG9zKytdIF49IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyBzdGF0ZSwgc3VmZml4LCBwb3MsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICAvLyBEbyB0aGUgcGFkZGluZ1xuICAgICAgICBzdGF0ZVtwb3NdIF49IHN1ZmZpeDtcbiAgICAgICAgaWYgKChzdWZmaXggJiAweDgwKSAhPT0gMCAmJiBwb3MgPT09IGJsb2NrTGVuIC0gMSlcbiAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgIHN0YXRlW2Jsb2NrTGVuIC0gMV0gXj0gMHg4MDtcbiAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICB9XG4gICAgd3JpdGVJbnRvKG91dCkge1xuICAgICAgICBhc3NlcnQuZXhpc3RzKHRoaXMsIGZhbHNlKTtcbiAgICAgICAgYXNzZXJ0LmJ5dGVzKG91dCk7XG4gICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlck91dCA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDAsIGxlbiA9IG91dC5sZW5ndGg7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc091dCA+PSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3NPdXQsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICBvdXQuc2V0KGJ1ZmZlck91dC5zdWJhcnJheSh0aGlzLnBvc091dCwgdGhpcy5wb3NPdXQgKyB0YWtlKSwgcG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zT3V0ICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICB4b2ZJbnRvKG91dCkge1xuICAgICAgICAvLyBTaGEzL0tlY2NhayB1c2FnZSB3aXRoIFhPRiBpcyBwcm9iYWJseSBtaXN0YWtlLCBvbmx5IFNIQUtFIGluc3RhbmNlcyBjYW4gZG8gWE9GXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVYT0YpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1hPRiBpcyBub3QgcG9zc2libGUgZm9yIHRoaXMgaW5zdGFuY2UnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVJbnRvKG91dCk7XG4gICAgfVxuICAgIHhvZihieXRlcykge1xuICAgICAgICBhc3NlcnQubnVtYmVyKGJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMueG9mSW50byhuZXcgVWludDhBcnJheShieXRlcykpO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhc3NlcnQub3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3QoKSB3YXMgYWxyZWFkeSBjYWxsZWQnKTtcbiAgICAgICAgdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlnZXN0SW50byhuZXcgVWludDhBcnJheSh0aGlzLm91dHB1dExlbikpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhdGUuZmlsbCgwKTtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgcm91bmRzLCBlbmFibGVYT0YgfSA9IHRoaXM7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCBlbmFibGVYT0YsIHJvdW5kcykpO1xuICAgICAgICB0by5zdGF0ZTMyLnNldCh0aGlzLnN0YXRlMzIpO1xuICAgICAgICB0by5wb3MgPSB0aGlzLnBvcztcbiAgICAgICAgdG8ucG9zT3V0ID0gdGhpcy5wb3NPdXQ7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gdGhpcy5maW5pc2hlZDtcbiAgICAgICAgdG8ucm91bmRzID0gcm91bmRzO1xuICAgICAgICAvLyBTdWZmaXggY2FuIGNoYW5nZSBpbiBjU0hBS0VcbiAgICAgICAgdG8uc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRvLmVuYWJsZVhPRiA9IGVuYWJsZVhPRjtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gdGhpcy5kZXN0cm95ZWQ7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG5jb25zdCBnZW4gPSAoc3VmZml4LCBibG9ja0xlbiwgb3V0cHV0TGVuKSA9PiB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4pKTtcbmV4cG9ydCBjb25zdCBzaGEzXzIyNCA9IGdlbigweDA2LCAxNDQsIDIyNCAvIDgpO1xuLyoqXG4gKiBTSEEzLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydCBjb25zdCBzaGEzXzI1NiA9IGdlbigweDA2LCAxMzYsIDI1NiAvIDgpO1xuZXhwb3J0IGNvbnN0IHNoYTNfMzg0ID0gZ2VuKDB4MDYsIDEwNCwgMzg0IC8gOCk7XG5leHBvcnQgY29uc3Qgc2hhM181MTIgPSBnZW4oMHgwNiwgNzIsIDUxMiAvIDgpO1xuZXhwb3J0IGNvbnN0IGtlY2Nha18yMjQgPSBnZW4oMHgwMSwgMTQ0LCAyMjQgLyA4KTtcbi8qKlxuICoga2VjY2FrLTI1NiBoYXNoIGZ1bmN0aW9uLiBEaWZmZXJlbnQgZnJvbSBTSEEzLTI1Ni5cbiAqIEBwYXJhbSBtZXNzYWdlIC0gdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0IGNvbnN0IGtlY2Nha18yNTYgPSBnZW4oMHgwMSwgMTM2LCAyNTYgLyA4KTtcbmV4cG9ydCBjb25zdCBrZWNjYWtfMzg0ID0gZ2VuKDB4MDEsIDEwNCwgMzg0IC8gOCk7XG5leHBvcnQgY29uc3Qga2VjY2FrXzUxMiA9IGdlbigweDAxLCA3MiwgNTEyIC8gOCk7XG5jb25zdCBnZW5TaGFrZSA9IChzdWZmaXgsIGJsb2NrTGVuLCBvdXRwdXRMZW4pID0+IHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzKChvcHRzID0ge30pID0+IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3B0cy5ka0xlbiA9PT0gdW5kZWZpbmVkID8gb3V0cHV0TGVuIDogb3B0cy5ka0xlbiwgdHJ1ZSkpO1xuZXhwb3J0IGNvbnN0IHNoYWtlMTI4ID0gZ2VuU2hha2UoMHgxZiwgMTY4LCAxMjggLyA4KTtcbmV4cG9ydCBjb25zdCBzaGFrZTI1NiA9IGdlblNoYWtlKDB4MWYsIDEzNiwgMjU2IC8gOCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEzLmpzLm1hcCJdLCJuYW1lcyI6WyJhc3NlcnQiLCJ1NjQiLCJIYXNoIiwidTMyIiwidG9CeXRlcyIsIndyYXBDb25zdHJ1Y3RvciIsIndyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzIiwiU0hBM19QSSIsIlNIQTNfUk9UTCIsIl9TSEEzX0lPVEEiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJfN24iLCJfMjU2biIsIl8weDcxbiIsInJvdW5kIiwiUiIsIngiLCJ5IiwicHVzaCIsInQiLCJqIiwiU0hBM19JT1RBX0giLCJTSEEzX0lPVEFfTCIsInNwbGl0Iiwicm90bEgiLCJoIiwibCIsInMiLCJyb3RsQkgiLCJyb3RsU0giLCJyb3RsTCIsInJvdGxCTCIsInJvdGxTTCIsImtlY2Nha1AiLCJyb3VuZHMiLCJCIiwiVWludDMyQXJyYXkiLCJpZHgxIiwiaWR4MCIsIkIwIiwiQjEiLCJUaCIsIlRsIiwiY3VySCIsImN1ckwiLCJzaGlmdCIsIlBJIiwiZmlsbCIsIktlY2NhayIsImNvbnN0cnVjdG9yIiwiYmxvY2tMZW4iLCJzdWZmaXgiLCJvdXRwdXRMZW4iLCJlbmFibGVYT0YiLCJwb3MiLCJwb3NPdXQiLCJmaW5pc2hlZCIsImRlc3Ryb3llZCIsIm51bWJlciIsIkVycm9yIiwic3RhdGUiLCJVaW50OEFycmF5Iiwic3RhdGUzMiIsImtlY2NhayIsInVwZGF0ZSIsImRhdGEiLCJleGlzdHMiLCJsZW4iLCJsZW5ndGgiLCJ0YWtlIiwiTWF0aCIsIm1pbiIsImkiLCJmaW5pc2giLCJ3cml0ZUludG8iLCJvdXQiLCJieXRlcyIsImJ1ZmZlck91dCIsInNldCIsInN1YmFycmF5IiwieG9mSW50byIsInhvZiIsImRpZ2VzdEludG8iLCJvdXRwdXQiLCJkZXN0cm95IiwiZGlnZXN0IiwiX2Nsb25lSW50byIsInRvIiwiZ2VuIiwic2hhM18yMjQiLCJzaGEzXzI1NiIsInNoYTNfMzg0Iiwic2hhM181MTIiLCJrZWNjYWtfMjI0Iiwia2VjY2FrXzI1NiIsImtlY2Nha18zODQiLCJrZWNjYWtfNTEyIiwiZ2VuU2hha2UiLCJvcHRzIiwiZGtMZW4iLCJ1bmRlZmluZWQiLCJzaGFrZTEyOCIsInNoYWtlMjU2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/sha3.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/utils.js":
/*!************************************************************************************!*\
  !*** ./node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/utils.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/cryptoNode.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\n\nconst u8a = (a)=>a instanceof Uint8Array;\n// Cast array to different type\nconst u8 = (arr)=>new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr)=>new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr)=>new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift)=>word << 32 - shift | word >>> shift;\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nconst isLE = new Uint8Array(new Uint32Array([\n    0x11223344\n]).buffer)[0] === 0x44;\nif (!isLE) throw new Error(\"Non little-endian hardware is not supported\");\nconst hexes = Array.from({\n    length: 256\n}, (v, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    if (!u8a(bytes)) throw new Error(\"Uint8Array expected\");\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    const len = hex.length;\n    if (len % 2) throw new Error(\"padded hex string expected, got unpadded hex of length \" + len);\n    const array = new Uint8Array(len / 2);\n    for(let i = 0; i < array.length; i++){\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0) throw new Error(\"Invalid byte sequence\");\n        array[i] = byte;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async ()=>{};\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for(let i = 0; i < iters; i++){\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick) continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */ function toBytes(data) {\n    if (typeof data === \"string\") data = utf8ToBytes(data);\n    if (!u8a(data)) throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */ function concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a)=>sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a)=>{\n        if (!u8a(a)) throw new Error(\"Uint8Array expected\");\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj)=>Object.prototype.toString.call(obj) === \"[object Object]\" && obj.constructor === Object;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && (typeof opts !== \"object\" || !isPlainObject(opts))) throw new Error(\"Options should be object or undefined\");\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg)=>hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = ()=>hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */ function randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === \"function\") {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error(\"crypto.getRandomValues must be defined\");\n} //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsb0VBQW9FLEdBQ3BFLG9GQUFvRjtBQUNwRixzRUFBc0U7QUFDdEUsa0VBQWtFO0FBQ2xFLDhEQUE4RDtBQUM5RCwrREFBK0Q7QUFDL0QsOERBQThEO0FBQ2hCO0FBQzlDLE1BQU1DLE1BQU0sQ0FBQ0MsSUFBTUEsYUFBYUM7QUFDaEMsK0JBQStCO0FBQ3hCLE1BQU1DLEtBQUssQ0FBQ0MsTUFBUSxJQUFJRixXQUFXRSxJQUFJQyxNQUFNLEVBQUVELElBQUlFLFVBQVUsRUFBRUYsSUFBSUcsVUFBVSxFQUFFO0FBQy9FLE1BQU1DLE1BQU0sQ0FBQ0osTUFBUSxJQUFJSyxZQUFZTCxJQUFJQyxNQUFNLEVBQUVELElBQUlFLFVBQVUsRUFBRUksS0FBS0MsS0FBSyxDQUFDUCxJQUFJRyxVQUFVLEdBQUcsSUFBSTtBQUN4RyxxQkFBcUI7QUFDZCxNQUFNSyxhQUFhLENBQUNSLE1BQVEsSUFBSVMsU0FBU1QsSUFBSUMsTUFBTSxFQUFFRCxJQUFJRSxVQUFVLEVBQUVGLElBQUlHLFVBQVUsRUFBRTtBQUM1RiwrREFBK0Q7QUFDeEQsTUFBTU8sT0FBTyxDQUFDQyxNQUFNQyxRQUFVLFFBQVUsS0FBS0EsUUFBV0QsU0FBU0MsTUFBTztBQUMvRSxpRkFBaUY7QUFDakYsd0RBQXdEO0FBQ2pELE1BQU1DLE9BQU8sSUFBSWYsV0FBVyxJQUFJTyxZQUFZO0lBQUM7Q0FBVyxFQUFFSixNQUFNLENBQUMsQ0FBQyxFQUFFLEtBQUssS0FBSztBQUNyRixJQUFJLENBQUNZLE1BQ0QsTUFBTSxJQUFJQyxNQUFNO0FBQ3BCLE1BQU1DLFFBQVFDLE1BQU1DLElBQUksQ0FBQztJQUFFQyxRQUFRO0FBQUksR0FBRyxDQUFDQyxHQUFHQyxJQUFNQSxFQUFFQyxRQUFRLENBQUMs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QUFDO0lBQ3RCQyxNQUFNSyxTQUFTLEdBQUdELElBQUlDLFNBQVM7SUFDL0JMLE1BQU1NLFFBQVEsR0FBR0YsSUFBSUUsUUFBUTtJQUM3Qk4sTUFBTU8sTUFBTSxHQUFHLENBQUNiLE9BQVNLLFNBQVNMO0lBQ2xDLE9BQU9NO0FBQ1g7QUFDQTs7Q0FFQyxHQUNNLFNBQVNVLFlBQVlDLGNBQWMsRUFBRTtJQUN4QyxJQUFJNUYsd0RBQU1BLElBQUksT0FBT0Esd0RBQU1BLENBQUM2RixlQUFlLEtBQUssWUFBWTtRQUN4RCxPQUFPN0Ysd0RBQU1BLENBQUM2RixlQUFlLENBQUMsSUFBSTFGLFdBQVd5RjtJQUNqRDtJQUNBLE1BQU0sSUFBSXpFLE1BQU07QUFDcEIsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcz80ZjhhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gbm9kZS5qcyB2ZXJzaW9ucyBlYXJsaWVyIHRoYW4gdjE5IGRvbid0IGRlY2xhcmUgaXQgaW4gZ2xvYmFsIHNjb3BlLlxuLy8gRm9yIG5vZGUuanMsIHBhY2thZ2UuanNvbiNleHBvcnRzIGZpZWxkIG1hcHBpbmcgcmV3cml0ZXMgaW1wb3J0XG4vLyBmcm9tIGBjcnlwdG9gIHRvIGBjcnlwdG9Ob2RlYCwgd2hpY2ggaW1wb3J0cyBuYXRpdmUgbW9kdWxlLlxuLy8gTWFrZXMgdGhlIHV0aWxzIHVuLWltcG9ydGFibGUgaW4gYnJvd3NlcnMgd2l0aG91dCBhIGJ1bmRsZXIuXG4vLyBPbmNlIG5vZGUuanMgMTggaXMgZGVwcmVjYXRlZCwgd2UgY2FuIGp1c3QgZHJvcCB0aGUgaW1wb3J0LlxuaW1wb3J0IHsgY3J5cHRvIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9jcnlwdG8nO1xuY29uc3QgdThhID0gKGEpID0+IGEgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuLy8gQ2FzdCBhcnJheSB0byBkaWZmZXJlbnQgdHlwZVxuZXhwb3J0IGNvbnN0IHU4ID0gKGFycikgPT4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbmV4cG9ydCBjb25zdCB1MzIgPSAoYXJyKSA9PiBuZXcgVWludDMyQXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIE1hdGguZmxvb3IoYXJyLmJ5dGVMZW5ndGggLyA0KSk7XG4vLyBDYXN0IGFycmF5IHRvIHZpZXdcbmV4cG9ydCBjb25zdCBjcmVhdGVWaWV3ID0gKGFycikgPT4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG4vLyBUaGUgcm90YXRlIHJpZ2h0IChjaXJjdWxhciByaWdodCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmV4cG9ydCBjb25zdCByb3RyID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCAoMzIgLSBzaGlmdCkpIHwgKHdvcmQgPj4+IHNoaWZ0KTtcbi8vIGJpZy1lbmRpYW4gaGFyZHdhcmUgaXMgcmFyZS4gSnVzdCBpbiBjYXNlIHNvbWVvbmUgc3RpbGwgZGVjaWRlcyB0byBydW4gaGFzaGVzOlxuLy8gZWFybHktdGhyb3cgYW4gZXJyb3IgYmVjYXVzZSB3ZSBkb24ndCBzdXBwb3J0IEJFIHlldC5cbmV4cG9ydCBjb25zdCBpc0xFID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsweDExMjIzMzQ0XSkuYnVmZmVyKVswXSA9PT0gMHg0NDtcbmlmICghaXNMRSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbiBsaXR0bGUtZW5kaWFuIGhhcmR3YXJlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbmNvbnN0IGhleGVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sICh2LCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGlmICghdThhKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBsZW4gPSBoZXgubGVuZ3RoO1xuICAgIGlmIChsZW4gJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgbGVuKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbiAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaiA9IGkgKiAyO1xuICAgICAgICBjb25zdCBoZXhCeXRlID0gaGV4LnNsaWNlKGosIGogKyAyKTtcbiAgICAgICAgY29uc3QgYnl0ZSA9IE51bWJlci5wYXJzZUludChoZXhCeXRlLCAxNik7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZSkgfHwgYnl0ZSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZSBzZXF1ZW5jZScpO1xuICAgICAgICBhcnJheVtpXSA9IGJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIFRoZXJlIGlzIG5vIHNldEltbWVkaWF0ZSBpbiBicm93c2VyIGFuZCBzZXRUaW1lb3V0IGlzIHNsb3cuXG4vLyBjYWxsIG9mIGFzeW5jIGZuIHdpbGwgcmV0dXJuIFByb21pc2UsIHdoaWNoIHdpbGwgYmUgZnVsbGZpbGVkIG9ubHkgb25cbi8vIG5leHQgc2NoZWR1bGVyIHF1ZXVlIHByb2Nlc3Npbmcgc3RlcCBhbmQgdGhpcyBpcyBleGFjdGx5IHdoYXQgd2UgbmVlZC5cbmV4cG9ydCBjb25zdCBuZXh0VGljayA9IGFzeW5jICgpID0+IHsgfTtcbi8vIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmdcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgbmV4dFRpY2soKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8qKlxuICogTm9ybWFsaXplcyAobm9uLWhleCkgc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gVWludDhBcnJheS5cbiAqIFdhcm5pbmc6IHdoZW4gVWludDhBcnJheSBpcyBwYXNzZWQsIGl0IHdvdWxkIE5PVCBnZXQgY29waWVkLlxuICogS2VlcCBpbiBtaW5kIGZvciBmdXR1cmUgbXV0YWJsZSBvcGVyYXRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGlmICghdThhKGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIFVpbnQ4QXJyYXksIGdvdCAke3R5cGVvZiBkYXRhfWApO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGNvbnN0IHIgPSBuZXcgVWludDhBcnJheShhcnJheXMucmVkdWNlKChzdW0sIGEpID0+IHN1bSArIGEubGVuZ3RoLCAwKSk7XG4gICAgbGV0IHBhZCA9IDA7IC8vIHdhbGsgdGhyb3VnaCBlYWNoIGl0ZW0sIGVuc3VyZSB0aGV5IGhhdmUgcHJvcGVyIHR5cGVcbiAgICBhcnJheXMuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgICBpZiAoIXU4YShhKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgICAgICByLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHI7XG59XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuZXhwb3J0IGNsYXNzIEhhc2gge1xuICAgIC8vIFNhZmUgdmVyc2lvbiB0aGF0IGNsb25lcyBpbnRlcm5hbCBzdGF0ZVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxufVxuLy8gQ2hlY2sgaWYgb2JqZWN0IGRvZW5zJ3QgaGF2ZSBjdXN0b20gY29uc3RydWN0b3IgKGxpa2UgVWludDhBcnJheS9BcnJheSlcbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAob2JqKSA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tPcHRzKGRlZmF1bHRzLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCAmJiAodHlwZW9mIG9wdHMgIT09ICdvYmplY3QnIHx8ICFpc1BsYWluT2JqZWN0KG9wdHMpKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb25zIHNob3VsZCBiZSBvYmplY3Qgb3IgdW5kZWZpbmVkJyk7XG4gICAgY29uc3QgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0cyk7XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3IoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2cpID0+IGhhc2hDb25zKCkudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoKTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9ICgpID0+IGhhc2hDb25zKCk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuLyoqXG4gKiBTZWN1cmUgUFJORy4gVXNlcyBgY3J5cHRvLmdldFJhbmRvbVZhbHVlc2AsIHdoaWNoIGRlZmVycyB0byBPUy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoID0gMzIpIHtcbiAgICBpZiAoY3J5cHRvICYmIHR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzTGVuZ3RoKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBtdXN0IGJlIGRlZmluZWQnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJjcnlwdG8iLCJ1OGEiLCJhIiwiVWludDhBcnJheSIsInU4IiwiYXJyIiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJ1MzIiLCJVaW50MzJBcnJheSIsIk1hdGgiLCJmbG9vciIsImNyZWF0ZVZpZXciLCJEYXRhVmlldyIsInJvdHIiLCJ3b3JkIiwic2hpZnQiLCJpc0xFIiwiRXJyb3IiLCJoZXhlcyIsIkFycmF5IiwiZnJvbSIsImxlbmd0aCIsInYiLCJpIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImJ5dGVzVG9IZXgiLCJieXRlcyIsImhleCIsImhleFRvQnl0ZXMiLCJsZW4iLCJhcnJheSIsImoiLCJoZXhCeXRlIiwic2xpY2UiLCJieXRlIiwiTnVtYmVyIiwicGFyc2VJbnQiLCJpc05hTiIsIm5leHRUaWNrIiwiYXN5bmNMb29wIiwiaXRlcnMiLCJ0aWNrIiwiY2IiLCJ0cyIsIkRhdGUiLCJub3ciLCJkaWZmIiwidXRmOFRvQnl0ZXMiLCJzdHIiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsInRvQnl0ZXMiLCJkYXRhIiwiY29uY2F0Qnl0ZXMiLCJhcnJheXMiLCJyIiwicmVkdWNlIiwic3VtIiwicGFkIiwiZm9yRWFjaCIsInNldCIsIkhhc2giLCJjbG9uZSIsIl9jbG9uZUludG8iLCJpc1BsYWluT2JqZWN0Iiwib2JqIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiY2FsbCIsImNvbnN0cnVjdG9yIiwiY2hlY2tPcHRzIiwiZGVmYXVsdHMiLCJvcHRzIiwidW5kZWZpbmVkIiwibWVyZ2VkIiwiYXNzaWduIiwid3JhcENvbnN0cnVjdG9yIiwiaGFzaENvbnMiLCJoYXNoQyIsIm1zZyIsInVwZGF0ZSIsImRpZ2VzdCIsInRtcCIsIm91dHB1dExlbiIsImJsb2NrTGVuIiwiY3JlYXRlIiwid3JhcENvbnN0cnVjdG9yV2l0aE9wdHMiLCJ3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyIsInJhbmRvbUJ5dGVzIiwiYnl0ZXNMZW5ndGgiLCJnZXRSYW5kb21WYWx1ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/utils.js\n");

/***/ })

};
;